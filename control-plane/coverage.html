
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>control-plane: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Keyring-Network/keyring-gavryn/control-plane/cmd/control-plane/main.go (70.0%)</option>
				
				<option value="file1">github.com/Keyring-Network/keyring-gavryn/control-plane/cmd/worker/main.go (70.0%)</option>
				
				<option value="file2">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/api/automation.go (63.3%)</option>
				
				<option value="file3">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/api/automations.go (36.1%)</option>
				
				<option value="file4">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/api/context.go (100.0%)</option>
				
				<option value="file5">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/api/llm_settings.go (67.0%)</option>
				
				<option value="file6">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/api/memory.go (100.0%)</option>
				
				<option value="file7">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/api/memory_index.go (42.3%)</option>
				
				<option value="file8">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/api/notifications.go (74.1%)</option>
				
				<option value="file9">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/api/personality_settings.go (56.4%)</option>
				
				<option value="file10">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/api/runs.go (65.3%)</option>
				
				<option value="file11">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/api/runs_artifacts.go (65.6%)</option>
				
				<option value="file12">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/api/runs_processes.go (53.7%)</option>
				
				<option value="file13">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/api/runs_workspace.go (50.0%)</option>
				
				<option value="file14">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/api/server.go (89.8%)</option>
				
				<option value="file15">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/api/skills.go (100.0%)</option>
				
				<option value="file16">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/config/config.go (100.0%)</option>
				
				<option value="file17">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/events/events.go (96.2%)</option>
				
				<option value="file18">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/llm/codex.go (96.0%)</option>
				
				<option value="file19">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/llm/errors.go (100.0%)</option>
				
				<option value="file20">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/llm/llm.go (84.6%)</option>
				
				<option value="file21">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/llm/local.go (100.0%)</option>
				
				<option value="file22">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/llm/openai.go (96.9%)</option>
				
				<option value="file23">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/llm/opencode.go (7.4%)</option>
				
				<option value="file24">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/personality/personality.go (0.0%)</option>
				
				<option value="file25">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/secrets/secrets.go (100.0%)</option>
				
				<option value="file26">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/skills/builtin.go (82.1%)</option>
				
				<option value="file27">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/skills/materialize.go (100.0%)</option>
				
				<option value="file28">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store/memory/memory.go (63.2%)</option>
				
				<option value="file29">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store/postgres/postgres.go (69.0%)</option>
				
				<option value="file30">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store/run_steps.go (67.5%)</option>
				
				<option value="file31">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/workflows/activities.go (74.0%)</option>
				
				<option value="file32">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/workflows/run_workflow.go (82.4%)</option>
				
				<option value="file33">github.com/Keyring-Network/keyring-gavryn/control-plane/internal/workflows/service.go (93.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"
        "os/signal"
        "syscall"

        "go.temporal.io/sdk/client"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/api"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/config"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/events"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/skills"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store/postgres"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/workflows"
)

type server interface {
        Start(ctx context.Context, addr string) error
}

var (
        loadConfig = func() (config.Config, error) <span class="cov0" title="0">{
                return config.Load(), nil
        }</span>
        newBroker = events.NewBroker
        newStore  = func(conn string) (*postgres.PostgresStore, error) <span class="cov0" title="0">{
                return postgres.New(conn)
        }</span>
        ensureBuiltins = func(ctx context.Context, st *postgres.PostgresStore) error <span class="cov0" title="0">{
                return skills.EnsureBuiltins(ctx, st)
        }</span>
        dialTemporal       = client.Dial
        newWorkflowService = workflows.NewService
        newServer          = func(store *postgres.PostgresStore, broker *events.Broker, workflows *workflows.Service, cfg config.Config) server <span class="cov0" title="0">{
                return api.NewServer(store, broker, workflows, cfg)
        }</span>
        notifyContext = signal.NotifyContext
)

func main() <span class="cov0" title="0">{
        if err := run(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}

func run() error <span class="cov8" title="1">{
        cfg, err := loadConfig()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">ctx, cancel := notifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
        defer cancel()

        broker := newBroker()
        store, err := newStore(cfg.PostgresURL)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if store != nil </span><span class="cov8" title="1">{
                if err := ensureBuiltins(ctx, store); err != nil </span><span class="cov0" title="0">{
                        log.Printf("warning: failed to bootstrap built-in skills: %v", err)
                }</span>
        }

        <span class="cov8" title="1">workflowClient, err := dialTemporal(client.Options{HostPort: cfg.TemporalAddress})
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if workflowClient != nil </span><span class="cov0" title="0">{
                defer workflowClient.Close()
        }</span>
        <span class="cov8" title="1">workflowService := newWorkflowService(workflowClient, cfg.TemporalTaskQueue)

        server := newServer(store, broker, workflowService, cfg)

        addr := fmt.Sprintf(":%s", cfg.ControlPlanePort)
        log.Printf("Gavryn control plane listening on %s", addr)
        if err := server.Start(ctx, addr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "log"

        "go.temporal.io/sdk/client"
        "go.temporal.io/sdk/worker"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/config"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/llm"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/secrets"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store/postgres"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/workflows"
)

var (
        loadConfig = func() (config.Config, error) <span class="cov0" title="0">{
                return config.Load(), nil
        }</span>
        dialTemporal = client.Dial
        newStore     = func(conn string) (*postgres.PostgresStore, error) <span class="cov0" title="0">{
                return postgres.New(conn)
        }</span>
        parseSecretsKey = secrets.ParseKey
        newActivities   = func(st *postgres.PostgresStore, cfg llm.Config, secretsKey []byte, controlPlaneURL string, toolRunnerURL string, opts ...workflows.RunActivitiesOption) *workflows.RunActivities <span class="cov0" title="0">{
                return workflows.NewRunActivities(st, cfg, secretsKey, controlPlaneURL, toolRunnerURL, opts...)
        }</span>
        newWorker       = worker.New
        workerInterrupt = worker.InterruptCh
)

func main() <span class="cov0" title="0">{
        if err := run(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}

func run() error <span class="cov8" title="1">{
        cfg, err := loadConfig()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">temporalClient, err := dialTemporal(client.Options{
                HostPort: cfg.TemporalAddress,
        })
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if temporalClient != nil </span><span class="cov0" title="0">{
                defer temporalClient.Close()
        }</span>

        <span class="cov8" title="1">store, err := newStore(cfg.PostgresURL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var secretsKey []byte
        if cfg.LLMSecretsKey != "" </span><span class="cov8" title="1">{
                parsed, err := parseSecretsKey(cfg.LLMSecretsKey)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov0" title="0">secretsKey = parsed</span>
        }

        <span class="cov8" title="1">activities := newActivities(store, llm.Config{
                Mode:             cfg.LLMMode,
                Provider:         cfg.LLMProvider,
                Model:            cfg.LLMModel,
                BaseURL:          cfg.LLMBaseURL,
                FallbackProvider: cfg.LLMFallbackProvider,
                FallbackModel:    cfg.LLMFallbackModel,
                FallbackBaseURL:  cfg.LLMFallbackBaseURL,
                OpenAIAPIKey:     cfg.OpenAIAPIKey,
                OpenRouterAPIKey: cfg.OpenRouterAPIKey,
                OpenCodeAPIKey:   cfg.OpenCodeAPIKey,
                CodexAuthPath:    cfg.CodexAuthPath,
                CodexHome:        cfg.CodexHome,
        }, secretsKey, cfg.ControlPlaneURL, cfg.ToolRunnerURL, workflows.WithMemoryConfig(cfg.MemoryMaxResults, cfg.MemoryMaxEntryChars))

        w := newWorker(temporalClient, cfg.TemporalTaskQueue, worker.Options{})
        w.RegisterWorkflow(workflows.RunWorkflow)
        w.RegisterActivity(activities)

        log.Println("Gavryn worker started")
        if err := w.Run(workerInterrupt()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "context"
        "encoding/json"
        "log"
        "net/http"
        "strings"
        "time"

        "github.com/google/uuid"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store"
)

type automationExecuteRequest struct {
        Prompt                 string         `json:"prompt"`
        Goal                   string         `json:"goal"`
        PolicyProfile          string         `json:"policy_profile"`
        ModelRoute             string         `json:"model_route"`
        Tags                   []string       `json:"tags"`
        Metadata               map[string]any `json:"metadata"`
        TimeoutMS              int            `json:"timeout_ms"`
        PollIntervalMS         int            `json:"poll_interval_ms"`
        WaitForCompletion      *bool          `json:"wait_for_completion"`
        BrowserMode            string         `json:"browser_mode"`
        BrowserInteraction     string         `json:"browser_interaction"`
        BrowserDomainAllowlist []string       `json:"browser_domain_allowlist"`
        BrowserPreferred       string         `json:"browser_preferred_browser"`
        BrowserUserAgent       string         `json:"browser_user_agent"`
}

type automationSourceDiagnostic struct {
        URL                string `json:"url,omitempty"`
        Title              string `json:"title,omitempty"`
        Status             string `json:"status,omitempty"`
        ReasonCode         string `json:"reason_code,omitempty"`
        ReasonDetail       string `json:"reason_detail,omitempty"`
        ExtractableContent bool   `json:"extractable_content,omitempty"`
        WordCount          int    `json:"word_count,omitempty"`
}

type automationDiagnostics struct {
        UsableSources    int                          `json:"usable_sources"`
        BlockedSources   int                          `json:"blocked_sources"`
        LowQuality       int                          `json:"low_quality_sources"`
        Sources          []automationSourceDiagnostic `json:"sources"`
        TerminalEvent    string                       `json:"terminal_event,omitempty"`
        TerminalReason   string                       `json:"terminal_reason,omitempty"`
        TotalEvents      int                          `json:"total_events"`
        AssistantMessage int                          `json:"assistant_messages"`
}

type automationExecuteResponse struct {
        RunID            string                `json:"run_id"`
        Status           string                `json:"status"`
        Phase            string                `json:"phase"`
        CompletionReason string                `json:"completion_reason,omitempty"`
        TimedOut         bool                  `json:"timed_out"`
        FinalResponse    string                `json:"final_response,omitempty"`
        Diagnostics      automationDiagnostics `json:"diagnostics"`
}

const (
        defaultAutomationTimeout      = 3 * time.Minute
        defaultAutomationPollInterval = 500 * time.Millisecond
)

func (s *Server) executeAutomationRun(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if !s.ensureLLMConfigured(w, r.Context()) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">req := automationExecuteRequest{}
        if r.Body != nil </span><span class="cov8" title="1">{
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "invalid request", http.StatusBadRequest)
                        return
                }</span>
        }

        <span class="cov8" title="1">prompt := strings.TrimSpace(req.Prompt)
        if prompt == "" </span><span class="cov0" title="0">{
                prompt = strings.TrimSpace(req.Goal)
        }</span>
        <span class="cov8" title="1">if prompt == "" </span><span class="cov0" title="0">{
                http.Error(w, "prompt is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">runID := uuid.New().String()
        now := time.Now().UTC().Format(time.RFC3339Nano)
        policyProfile := strings.TrimSpace(req.PolicyProfile)
        if policyProfile == "" </span><span class="cov8" title="1">{
                policyProfile = "default"
        }</span>

        <span class="cov8" title="1">run := store.Run{
                ID:            runID,
                Status:        "running",
                Phase:         "planning",
                PolicyProfile: policyProfile,
                ModelRoute:    strings.TrimSpace(req.ModelRoute),
                Tags:          req.Tags,
                CreatedAt:     now,
                UpdatedAt:     now,
        }
        if err := s.store.CreateRun(r.Context(), run); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if s.workflows != nil </span><span class="cov8" title="1">{
                _ = s.workflows.StartRun(r.Context(), runID)
        }</span>

        <span class="cov8" title="1">seq, _ := s.store.NextSeq(r.Context(), runID)
        startedEvent := store.RunEvent{
                RunID:     runID,
                Seq:       seq,
                Type:      "run.started",
                Timestamp: now,
                Source:    "control_plane",
                TraceID:   uuid.New().String(),
                Payload: map[string]any{
                        "status":         "running",
                        "phase":          "planning",
                        "policy_profile": policyProfile,
                        "model_route":    run.ModelRoute,
                        "tags":           run.Tags,
                },
        }
        _ = s.store.AppendEvent(r.Context(), startedEvent)
        s.broker.Publish(toEvent(startedEvent))

        metadata := cloneMetadataMap(req.Metadata)
        if mode := strings.TrimSpace(req.BrowserMode); mode != "" </span><span class="cov8" title="1">{
                metadata["browser_mode"] = mode
        }</span>
        <span class="cov8" title="1">if interaction := strings.TrimSpace(req.BrowserInteraction); interaction != "" </span><span class="cov0" title="0">{
                metadata["browser_interaction"] = interaction
        }</span>
        <span class="cov8" title="1">if preferred := strings.TrimSpace(req.BrowserPreferred); preferred != "" </span><span class="cov8" title="1">{
                metadata["browser_preferred_browser"] = preferred
        }</span>
        <span class="cov8" title="1">if userAgent := strings.TrimSpace(req.BrowserUserAgent); userAgent != "" </span><span class="cov0" title="0">{
                metadata["browser_user_agent"] = userAgent
        }</span>
        <span class="cov8" title="1">if len(req.BrowserDomainAllowlist) &gt; 0 </span><span class="cov0" title="0">{
                trimmed := make([]string, 0, len(req.BrowserDomainAllowlist))
                for _, item := range req.BrowserDomainAllowlist </span><span class="cov0" title="0">{
                        if value := strings.TrimSpace(item); value != "" </span><span class="cov0" title="0">{
                                trimmed = append(trimmed, value)
                        }</span>
                }
                <span class="cov0" title="0">if len(trimmed) &gt; 0 </span><span class="cov0" title="0">{
                        metadata["browser_domain_allowlist"] = strings.Join(trimmed, ",")
                }</span>
        }

        <span class="cov8" title="1">msg := store.Message{
                ID:        uuid.New().String(),
                RunID:     runID,
                Role:      "user",
                Content:   prompt,
                Sequence:  time.Now().UnixNano(),
                CreatedAt: now,
                Metadata:  metadata,
        }
        if err := s.store.AddMessage(r.Context(), msg); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">s.indexMessageMemory(r.Context(), msg)
        if s.workflows != nil </span><span class="cov8" title="1">{
                _ = s.workflows.SignalMessage(r.Context(), runID, prompt)
        }</span>

        <span class="cov8" title="1">seq, _ = s.store.NextSeq(r.Context(), runID)
        messageEvent := store.RunEvent{
                RunID:     runID,
                Seq:       seq,
                Type:      "message.added",
                Timestamp: now,
                Source:    "control_plane",
                TraceID:   uuid.New().String(),
                Payload: map[string]any{
                        "message_id": msg.ID,
                        "role":       msg.Role,
                        "content":    msg.Content,
                },
        }
        _ = s.store.AppendEvent(r.Context(), messageEvent)
        s.broker.Publish(toEvent(messageEvent))

        waitForCompletion := true
        if req.WaitForCompletion != nil </span><span class="cov8" title="1">{
                waitForCompletion = *req.WaitForCompletion
        }</span>
        <span class="cov8" title="1">if !waitForCompletion </span><span class="cov8" title="1">{
                writeJSONStatus(w, automationExecuteResponse{
                        RunID:  runID,
                        Status: "running",
                        Phase:  "planning",
                        Diagnostics: automationDiagnostics{
                                Sources:     []automationSourceDiagnostic{},
                                TotalEvents: 2,
                        },
                }, http.StatusAccepted)
                return
        }</span>

        <span class="cov8" title="1">timeout := normalizeDuration(req.TimeoutMS, defaultAutomationTimeout, 5*time.Second, 30*time.Minute)
        poll := normalizeDuration(req.PollIntervalMS, defaultAutomationPollInterval, 100*time.Millisecond, 5*time.Second)
        waitCtx, cancel := contextWithTimeoutOrRequest(r.Context(), timeout)
        defer cancel()

        var (
                eventsList []store.RunEvent
                terminal   *store.RunEvent
        )
        for </span><span class="cov8" title="1">{
                currentEvents, err := s.store.ListEvents(waitCtx, runID, 0)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">eventsList = currentEvents
                terminal = latestTerminalEvent(eventsList)
                if terminal != nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">select </span>{
                case &lt;-waitCtx.Done():<span class="cov0" title="0">
                        break</span>
                case &lt;-time.After(poll):<span class="cov0" title="0"></span>
                }
                <span class="cov0" title="0">if waitCtx.Err() != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov8" title="1">messages, err := s.store.ListMessages(r.Context(), runID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">finalResponse, assistantMessages := latestAssistantMessage(messages)
        status, phase, completionReason := deriveAutomationStatusFromTerminalEvent(terminal)
        timedOut := terminal == nil
        if timedOut </span><span class="cov0" title="0">{
                status = "running"
                phase = "executing"
                completionReason = "timeout_waiting_for_terminal_event"
        }</span>

        <span class="cov8" title="1">diagnostics := buildAutomationDiagnostics(eventsList, assistantMessages)
        diagnostics.TerminalEvent = terminalEventType(terminal)
        diagnostics.TerminalReason = completionReason

        log.Printf("automation.execute run_id=%s status=%s reason=%s timed_out=%t", runID, status, completionReason, timedOut)
        if strings.TrimSpace(finalResponse) != "" </span><span class="cov8" title="1">{
                log.Printf("automation.final_response run_id=%s\n%s", runID, finalResponse)
        }</span>

        <span class="cov8" title="1">writeJSONStatus(w, automationExecuteResponse{
                RunID:            runID,
                Status:           status,
                Phase:            phase,
                CompletionReason: completionReason,
                TimedOut:         timedOut,
                FinalResponse:    finalResponse,
                Diagnostics:      diagnostics,
        }, http.StatusOK)</span>
}

func cloneMetadataMap(metadata map[string]any) map[string]any <span class="cov8" title="1">{
        if len(metadata) == 0 </span><span class="cov8" title="1">{
                return map[string]any{}
        }</span>
        <span class="cov0" title="0">copied := make(map[string]any, len(metadata))
        for key, value := range metadata </span><span class="cov0" title="0">{
                copied[key] = value
        }</span>
        <span class="cov0" title="0">return copied</span>
}

func normalizeDuration(rawMS int, fallback time.Duration, min time.Duration, max time.Duration) time.Duration <span class="cov8" title="1">{
        value := fallback
        if rawMS &gt; 0 </span><span class="cov8" title="1">{
                value = time.Duration(rawMS) * time.Millisecond
        }</span>
        <span class="cov8" title="1">if value &lt; min </span><span class="cov8" title="1">{
                return min
        }</span>
        <span class="cov8" title="1">if value &gt; max </span><span class="cov0" title="0">{
                return max
        }</span>
        <span class="cov8" title="1">return value</span>
}

func contextWithTimeoutOrRequest(parent context.Context, timeout time.Duration) (context.Context, context.CancelFunc) <span class="cov8" title="1">{
        if timeout &lt;= 0 </span><span class="cov0" title="0">{
                return context.WithCancel(parent)
        }</span>
        <span class="cov8" title="1">return context.WithTimeout(parent, timeout)</span>
}

func latestTerminalEvent(eventsList []store.RunEvent) *store.RunEvent <span class="cov8" title="1">{
        for i := len(eventsList) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                normalized := strings.TrimSpace(strings.ToLower(eventsList[i].Type))
                switch normalized </span>{
                case "run.completed", "run.partial", "run.failed", "run.cancelled":<span class="cov8" title="1">
                        event := eventsList[i]
                        return &amp;event</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func terminalEventType(event *store.RunEvent) string <span class="cov8" title="1">{
        if event == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(event.Type)</span>
}

func deriveAutomationStatusFromTerminalEvent(event *store.RunEvent) (string, string, string) <span class="cov8" title="1">{
        if event == nil </span><span class="cov0" title="0">{
                return "", "", ""
        }</span>
        <span class="cov8" title="1">status := strings.TrimSpace(toStringValue(event.Payload["status"]))
        phase := strings.TrimSpace(toStringValue(event.Payload["phase"]))
        reason := strings.TrimSpace(toStringValue(event.Payload["completion_reason"]))

        switch strings.TrimSpace(strings.ToLower(event.Type)) </span>{
        case "run.completed":<span class="cov8" title="1">
                if status == "" </span><span class="cov0" title="0">{
                        status = "completed"
                }</span>
                <span class="cov8" title="1">if phase == "" </span><span class="cov0" title="0">{
                        phase = "completed"
                }</span>
        case "run.partial":<span class="cov0" title="0">
                if status == "" </span><span class="cov0" title="0">{
                        status = "partial"
                }</span>
                <span class="cov0" title="0">if phase == "" </span><span class="cov0" title="0">{
                        phase = "completed"
                }</span>
        case "run.failed":<span class="cov0" title="0">
                if status == "" </span><span class="cov0" title="0">{
                        status = "failed"
                }</span>
                <span class="cov0" title="0">if phase == "" </span><span class="cov0" title="0">{
                        phase = "failed"
                }</span>
        case "run.cancelled":<span class="cov0" title="0">
                if status == "" </span><span class="cov0" title="0">{
                        status = "cancelled"
                }</span>
                <span class="cov0" title="0">if phase == "" </span><span class="cov0" title="0">{
                        phase = "cancelled"
                }</span>
        }

        <span class="cov8" title="1">if status == "" </span><span class="cov0" title="0">{
                status = "completed"
        }</span>
        <span class="cov8" title="1">if phase == "" </span><span class="cov0" title="0">{
                phase = "completed"
        }</span>
        <span class="cov8" title="1">return status, phase, reason</span>
}

func latestAssistantMessage(messages []store.Message) (string, int) <span class="cov8" title="1">{
        assistantCount := 0
        for i := len(messages) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if strings.TrimSpace(strings.ToLower(messages[i].Role)) != "assistant" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">assistantCount++</span>
        }
        <span class="cov8" title="1">for i := len(messages) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if strings.TrimSpace(strings.ToLower(messages[i].Role)) != "assistant" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">content := strings.TrimSpace(messages[i].Content)
                if content != "" </span><span class="cov8" title="1">{
                        return content, assistantCount
                }</span>
        }
        <span class="cov0" title="0">return "", assistantCount</span>
}

func toStringValue(value any) string <span class="cov8" title="1">{
        switch typed := value.(type) </span>{
        case string:<span class="cov8" title="1">
                return typed</span>
        case nil:<span class="cov8" title="1">
                return ""</span>
        default:<span class="cov0" title="0">
                return strings.TrimSpace(toJSONSafeString(typed))</span>
        }
}

func toJSONSafeString(value any) string <span class="cov0" title="0">{
        raw, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return string(raw)</span>
}

func toIntValue(value any) int <span class="cov8" title="1">{
        switch typed := value.(type) </span>{
        case int:<span class="cov8" title="1">
                return typed</span>
        case int32:<span class="cov0" title="0">
                return int(typed)</span>
        case int64:<span class="cov0" title="0">
                return int(typed)</span>
        case float32:<span class="cov0" title="0">
                return int(typed)</span>
        case float64:<span class="cov0" title="0">
                return int(typed)</span>
        case json.Number:<span class="cov0" title="0">
                if parsed, err := typed.Int64(); err == nil </span><span class="cov0" title="0">{
                        return int(parsed)
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func toBoolValue(value any) bool <span class="cov8" title="1">{
        switch typed := value.(type) </span>{
        case bool:<span class="cov8" title="1">
                return typed</span>
        case string:<span class="cov0" title="0">
                switch strings.TrimSpace(strings.ToLower(typed)) </span>{
                case "true", "1", "yes", "y":<span class="cov0" title="0">
                        return true</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func buildAutomationDiagnostics(eventsList []store.RunEvent, assistantMessages int) automationDiagnostics <span class="cov8" title="1">{
        diagnostics := automationDiagnostics{
                Sources:          []automationSourceDiagnostic{},
                TotalEvents:      len(eventsList),
                AssistantMessage: assistantMessages,
        }
        seen := map[string]struct{}{}
        addSource := func(candidate automationSourceDiagnostic) </span><span class="cov8" title="1">{
                parts := make([]string, 0, 5)
                for _, value := range []string{candidate.URL, candidate.Title, candidate.ReasonCode, candidate.Status, candidate.ReasonDetail} </span><span class="cov8" title="1">{
                        trimmed := strings.TrimSpace(strings.ToLower(value))
                        if trimmed != "" </span><span class="cov8" title="1">{
                                parts = append(parts, trimmed)
                        }</span>
                }
                <span class="cov8" title="1">key := strings.Join(parts, "|")
                if key == "" </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">if _, exists := seen[key]; exists </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">seen[key] = struct{}{}
                diagnostics.Sources = append(diagnostics.Sources, candidate)</span>
        }

        <span class="cov8" title="1">for _, event := range eventsList </span><span class="cov8" title="1">{
                eventType := strings.TrimSpace(strings.ToLower(event.Type))
                if eventType == "tool.completed" </span><span class="cov8" title="1">{
                        toolName := strings.TrimSpace(strings.ToLower(toStringValue(event.Payload["tool_name"])))
                        if toolName != "browser.extract" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">output, _ := event.Payload["output"].(map[string]any)
                        diagnostic := automationSourceDiagnostic{
                                URL:   strings.TrimSpace(toStringValue(output["url"])),
                                Title: strings.TrimSpace(toStringValue(output["title"])),
                        }
                        diagPayload, _ := output["diagnostics"].(map[string]any)
                        if diagPayload != nil </span><span class="cov8" title="1">{
                                diagnostic.Status = strings.TrimSpace(toStringValue(diagPayload["status"]))
                                diagnostic.ReasonCode = strings.TrimSpace(toStringValue(diagPayload["reason_code"]))
                                diagnostic.ReasonDetail = strings.TrimSpace(toStringValue(diagPayload["reason_detail"]))
                                diagnostic.ExtractableContent = toBoolValue(diagPayload["extractable_content"])
                                diagnostic.WordCount = toIntValue(diagPayload["word_count"])
                        }</span>
                        <span class="cov8" title="1">if diagnostic.ReasonCode == "" </span><span class="cov8" title="1">{
                                diagnostic.ReasonCode = strings.TrimSpace(toStringValue(output["reason_code"]))
                        }</span>
                        <span class="cov8" title="1">addSource(diagnostic)
                        continue</span>
                }

                <span class="cov8" title="1">if eventType == "browser.extract" </span><span class="cov0" title="0">{
                        diagnostic := automationSourceDiagnostic{
                                URL:   strings.TrimSpace(toStringValue(event.Payload["url"])),
                                Title: strings.TrimSpace(toStringValue(event.Payload["title"])),
                        }
                        diagPayload, _ := event.Payload["diagnostics"].(map[string]any)
                        if diagPayload != nil </span><span class="cov0" title="0">{
                                diagnostic.Status = strings.TrimSpace(toStringValue(diagPayload["status"]))
                                diagnostic.ReasonCode = strings.TrimSpace(toStringValue(diagPayload["reason_code"]))
                                diagnostic.ReasonDetail = strings.TrimSpace(toStringValue(diagPayload["reason_detail"]))
                                diagnostic.ExtractableContent = toBoolValue(diagPayload["extractable_content"])
                                diagnostic.WordCount = toIntValue(diagPayload["word_count"])
                        }</span>
                        <span class="cov0" title="0">if diagnostic.ReasonCode == "" </span><span class="cov0" title="0">{
                                diagnostic.ReasonCode = strings.TrimSpace(toStringValue(event.Payload["reason_code"]))
                        }</span>
                        <span class="cov0" title="0">addSource(diagnostic)</span>
                }
        }

        <span class="cov8" title="1">for _, source := range diagnostics.Sources </span><span class="cov8" title="1">{
                reasonCode := strings.TrimSpace(strings.ToLower(source.ReasonCode))
                status := strings.TrimSpace(strings.ToLower(source.Status))
                switch reasonCode </span>{
                case "blocked_by_bot_protection", "consent_wall", "login_wall":<span class="cov0" title="0">
                        diagnostics.BlockedSources++</span>
                case "no_extractable_content":<span class="cov8" title="1">
                        diagnostics.LowQuality++</span>
                default:<span class="cov8" title="1">
                        if source.ExtractableContent || status == "ok" </span><span class="cov8" title="1">{
                                diagnostics.UsableSources++
                        }</span> else<span class="cov0" title="0"> {
                                diagnostics.LowQuality++
                        }</span>
                }
        }

        <span class="cov8" title="1">return diagnostics</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "net/http"
        "net/http/httptest"
        "sort"
        "strings"
        "time"

        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store"
)

var weekdayIndex = map[string]time.Weekday{
        "sun": time.Sunday,
        "mon": time.Monday,
        "tue": time.Tuesday,
        "wed": time.Wednesday,
        "thu": time.Thursday,
        "fri": time.Friday,
        "sat": time.Saturday,
}

type automationSchedule struct {
        ID         string   `json:"id"`
        Name       string   `json:"name"`
        Prompt     string   `json:"prompt"`
        Model      string   `json:"model"`
        Days       []string `json:"days"`
        TimeOfDay  string   `json:"time"`
        Timezone   string   `json:"timezone"`
        Enabled    bool     `json:"enabled"`
        NextRunAt  string   `json:"next_run_at,omitempty"`
        LastRunAt  string   `json:"last_run_at,omitempty"`
        InProgress bool     `json:"in_progress"`
        Unread     int      `json:"unread_count"`
        LastStatus string   `json:"last_status,omitempty"`
        CreatedAt  string   `json:"created_at"`
        UpdatedAt  string   `json:"updated_at"`
}

type automationInboxEntry struct {
        ID               string                `json:"id"`
        AutomationID     string                `json:"automation_id"`
        RunID            string                `json:"run_id,omitempty"`
        Status           string                `json:"status"`
        Phase            string                `json:"phase,omitempty"`
        CompletionReason string                `json:"completion_reason,omitempty"`
        FinalResponse    string                `json:"final_response,omitempty"`
        TimedOut         bool                  `json:"timed_out"`
        Error            string                `json:"error,omitempty"`
        Unread           bool                  `json:"unread"`
        Trigger          string                `json:"trigger"`
        StartedAt        string                `json:"started_at"`
        CompletedAt      string                `json:"completed_at,omitempty"`
        Diagnostics      automationDiagnostics `json:"diagnostics"`
}

type automationUpsertRequest struct {
        Name      string   `json:"name"`
        Prompt    string   `json:"prompt"`
        Model     string   `json:"model"`
        Days      []string `json:"days"`
        TimeOfDay string   `json:"time"`
        Timezone  string   `json:"timezone"`
        Enabled   *bool    `json:"enabled"`
}

type automationsListResponse struct {
        Automations []automationSchedule `json:"automations"`
        UnreadCount int                  `json:"unread_count"`
}

type automationDetailResponse struct {
        Automation  automationSchedule     `json:"automation"`
        Inbox       []automationInboxEntry `json:"inbox"`
        UnreadCount int                    `json:"unread_count"`
}

type automationQueueResponse struct {
        Queued bool   `json:"queued"`
        Error  string `json:"error,omitempty"`
}

type automationProcessResponse struct {
        Queued int `json:"queued"`
}

func normalizeDays(days []string) []string <span class="cov8" title="1">{
        if len(days) == 0 </span><span class="cov0" title="0">{
                return []string{"mon", "tue", "wed", "thu", "fri"}
        }</span>
        <span class="cov8" title="1">seen := map[string]struct{}{}
        ordered := make([]string, 0, len(days))
        for _, raw := range days </span><span class="cov8" title="1">{
                day := strings.TrimSpace(strings.ToLower(raw))
                if _, ok := weekdayIndex[day]; !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, exists := seen[day]; exists </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">seen[day] = struct{}{}
                ordered = append(ordered, day)</span>
        }
        <span class="cov8" title="1">if len(ordered) == 0 </span><span class="cov0" title="0">{
                return []string{"mon", "tue", "wed", "thu", "fri"}
        }</span>
        <span class="cov8" title="1">sort.SliceStable(ordered, func(i, j int) bool </span><span class="cov8" title="1">{
                return weekdayIndex[ordered[i]] &lt; weekdayIndex[ordered[j]]
        }</span>)
        <span class="cov8" title="1">return ordered</span>
}

func normalizeTimezone(value string) string <span class="cov8" title="1">{
        tz := strings.TrimSpace(value)
        if tz == "" </span><span class="cov0" title="0">{
                return "UTC"
        }</span>
        <span class="cov8" title="1">if _, err := time.LoadLocation(tz); err != nil </span><span class="cov0" title="0">{
                return "UTC"
        }</span>
        <span class="cov8" title="1">return tz</span>
}

func normalizeTimeOfDay(value string) (string, error) <span class="cov8" title="1">{
        timePart := strings.TrimSpace(value)
        if timePart == "" </span><span class="cov0" title="0">{
                timePart = "09:00"
        }</span>
        <span class="cov8" title="1">parsed, err := time.Parse("15:04", timePart)
        if err != nil </span><span class="cov8" title="1">{
                return "", errors.New("time must use HH:MM format")
        }</span>
        <span class="cov8" title="1">return parsed.Format("15:04"), nil</span>
}

func computeNextRun(days []string, timeOfDay string, timezone string, from time.Time) (time.Time, error) <span class="cov8" title="1">{
        loc, err := time.LoadLocation(normalizeTimezone(timezone))
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov8" title="1">parsed, err := time.Parse("15:04", timeOfDay)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov8" title="1">hour := parsed.Hour()
        minute := parsed.Minute()
        allowed := map[time.Weekday]struct{}{}
        for _, day := range normalizeDays(days) </span><span class="cov8" title="1">{
                allowed[weekdayIndex[day]] = struct{}{}
        }</span>
        <span class="cov8" title="1">nowLocal := from.In(loc)
        for i := 0; i &lt; 14; i++ </span><span class="cov8" title="1">{
                candidateDay := nowLocal.AddDate(0, 0, i)
                candidate := time.Date(candidateDay.Year(), candidateDay.Month(), candidateDay.Day(), hour, minute, 0, 0, loc)
                if _, ok := allowed[candidate.Weekday()]; !ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if candidate.After(nowLocal) </span><span class="cov8" title="1">{
                        return candidate.UTC(), nil
                }</span>
        }
        <span class="cov0" title="0">return time.Time{}, errors.New("failed to compute next run")</span>
}

func toScheduleRecord(value store.Automation) automationSchedule <span class="cov8" title="1">{
        return automationSchedule{
                ID:         value.ID,
                Name:       value.Name,
                Prompt:     value.Prompt,
                Model:      value.Model,
                Days:       append([]string(nil), value.Days...),
                TimeOfDay:  value.TimeOfDay,
                Timezone:   value.Timezone,
                Enabled:    value.Enabled,
                NextRunAt:  value.NextRunAt,
                LastRunAt:  value.LastRunAt,
                InProgress: value.InProgress,
                CreatedAt:  value.CreatedAt,
                UpdatedAt:  value.UpdatedAt,
        }
}</span>

func toStoreAutomation(value automationSchedule) store.Automation <span class="cov8" title="1">{
        return store.Automation{
                ID:         value.ID,
                Name:       value.Name,
                Prompt:     value.Prompt,
                Model:      value.Model,
                Days:       append([]string(nil), value.Days...),
                TimeOfDay:  value.TimeOfDay,
                Timezone:   value.Timezone,
                Enabled:    value.Enabled,
                NextRunAt:  value.NextRunAt,
                LastRunAt:  value.LastRunAt,
                InProgress: value.InProgress,
                CreatedAt:  value.CreatedAt,
                UpdatedAt:  value.UpdatedAt,
        }
}</span>

func toInboxRecord(value store.AutomationInboxEntry) automationInboxEntry <span class="cov0" title="0">{
        return automationInboxEntry{
                ID:               value.ID,
                AutomationID:     value.AutomationID,
                RunID:            value.RunID,
                Status:           value.Status,
                Phase:            value.Phase,
                CompletionReason: value.CompletionReason,
                FinalResponse:    value.FinalResponse,
                TimedOut:         value.TimedOut,
                Error:            value.Error,
                Unread:           value.Unread,
                Trigger:          value.Trigger,
                StartedAt:        value.StartedAt,
                CompletedAt:      value.CompletedAt,
                Diagnostics:      decodeAutomationDiagnostics(value.Diagnostics),
        }
}</span>

func toStoreInboxEntry(value automationInboxEntry) store.AutomationInboxEntry <span class="cov0" title="0">{
        return store.AutomationInboxEntry{
                ID:               value.ID,
                AutomationID:     value.AutomationID,
                RunID:            value.RunID,
                Status:           value.Status,
                Phase:            value.Phase,
                CompletionReason: value.CompletionReason,
                FinalResponse:    value.FinalResponse,
                TimedOut:         value.TimedOut,
                Error:            value.Error,
                Unread:           value.Unread,
                Trigger:          value.Trigger,
                StartedAt:        value.StartedAt,
                CompletedAt:      value.CompletedAt,
                Diagnostics:      encodeAutomationDiagnostics(value.Diagnostics),
        }
}</span>

func decodeAutomationDiagnostics(value map[string]any) automationDiagnostics <span class="cov0" title="0">{
        if len(value) == 0 </span><span class="cov0" title="0">{
                return automationDiagnostics{Sources: []automationSourceDiagnostic{}}
        }</span>
        <span class="cov0" title="0">diag := automationDiagnostics{}
        encoded, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return automationDiagnostics{Sources: []automationSourceDiagnostic{}}
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal(encoded, &amp;diag); err != nil </span><span class="cov0" title="0">{
                return automationDiagnostics{Sources: []automationSourceDiagnostic{}}
        }</span>
        <span class="cov0" title="0">if diag.Sources == nil </span><span class="cov0" title="0">{
                diag.Sources = []automationSourceDiagnostic{}
        }</span>
        <span class="cov0" title="0">return diag</span>
}

func encodeAutomationDiagnostics(value automationDiagnostics) map[string]any <span class="cov0" title="0">{
        encoded, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return map[string]any{"sources": []any{}}
        }</span>
        <span class="cov0" title="0">payload := map[string]any{}
        if err := json.Unmarshal(encoded, &amp;payload); err != nil </span><span class="cov0" title="0">{
                return map[string]any{"sources": []any{}}
        }</span>
        <span class="cov0" title="0">return payload</span>
}

func findInboxEntry(entries []store.AutomationInboxEntry, entryID string) *store.AutomationInboxEntry <span class="cov0" title="0">{
        for idx := range entries </span><span class="cov0" title="0">{
                if entries[idx].ID == entryID </span><span class="cov0" title="0">{
                        copy := entries[idx]
                        return &amp;copy
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func summarizeInbox(entries []store.AutomationInboxEntry) (int, string) <span class="cov8" title="1">{
        unread := 0
        lastStatus := ""
        for idx, entry := range entries </span><span class="cov0" title="0">{
                if entry.Unread </span><span class="cov0" title="0">{
                        unread++
                }</span>
                <span class="cov0" title="0">if idx == 0 </span><span class="cov0" title="0">{
                        lastStatus = strings.TrimSpace(entry.Status)
                }</span>
        }
        <span class="cov8" title="1">return unread, lastStatus</span>
}

func (s *Server) listAutomations(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        now := time.Now().UTC()
        items, err := s.store.ListAutomations(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">result := make([]automationSchedule, 0, len(items))
        totalUnread := 0
        for _, item := range items </span><span class="cov8" title="1">{
                entries, inboxErr := s.store.ListAutomationInbox(r.Context(), item.ID)
                if inboxErr != nil </span><span class="cov0" title="0">{
                        http.Error(w, inboxErr.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">record := toScheduleRecord(item)
                unread, lastStatus := summarizeInbox(entries)
                record.Unread = unread
                record.LastStatus = lastStatus
                totalUnread += unread
                if record.Enabled </span><span class="cov8" title="1">{
                        if next, nextErr := computeNextRun(record.Days, record.TimeOfDay, record.Timezone, now); nextErr == nil </span><span class="cov8" title="1">{
                                record.NextRunAt = next.Format(time.RFC3339)
                        }</span>
                } else<span class="cov0" title="0"> {
                        record.NextRunAt = ""
                }</span>
                <span class="cov8" title="1">result = append(result, record)</span>
        }
        <span class="cov8" title="1">sort.SliceStable(result, func(i, j int) bool </span><span class="cov0" title="0">{
                return result[i].UpdatedAt &gt; result[j].UpdatedAt
        }</span>)
        <span class="cov8" title="1">writeJSONStatus(w, automationsListResponse{Automations: result, UnreadCount: totalUnread}, http.StatusOK)</span>
}

func (s *Server) createAutomation(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        req := automationUpsertRequest{}
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid request", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">name := strings.TrimSpace(req.Name)
        prompt := strings.TrimSpace(req.Prompt)
        if name == "" </span><span class="cov8" title="1">{
                http.Error(w, "name is required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if prompt == "" </span><span class="cov8" title="1">{
                http.Error(w, "prompt is required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">timeOfDay, err := normalizeTimeOfDay(req.TimeOfDay)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">enabled := true
        if req.Enabled != nil </span><span class="cov8" title="1">{
                enabled = *req.Enabled
        }</span>
        <span class="cov8" title="1">now := time.Now().UTC()
        schedule := automationSchedule{
                ID:        uuid.NewString(),
                Name:      name,
                Prompt:    prompt,
                Model:     strings.TrimSpace(req.Model),
                Days:      normalizeDays(req.Days),
                TimeOfDay: timeOfDay,
                Timezone:  normalizeTimezone(req.Timezone),
                Enabled:   enabled,
                CreatedAt: now.Format(time.RFC3339Nano),
                UpdatedAt: now.Format(time.RFC3339Nano),
        }
        if enabled </span><span class="cov8" title="1">{
                if next, nextErr := computeNextRun(schedule.Days, schedule.TimeOfDay, schedule.Timezone, now); nextErr == nil </span><span class="cov8" title="1">{
                        schedule.NextRunAt = next.Format(time.RFC3339Nano)
                }</span>
        }
        <span class="cov8" title="1">if err := s.store.CreateAutomation(r.Context(), toStoreAutomation(schedule)); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">writeJSONStatus(w, schedule, http.StatusCreated)</span>
}

func (s *Server) updateAutomation(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id := strings.TrimSpace(chi.URLParam(r, "id"))
        if id == "" </span><span class="cov0" title="0">{
                http.Error(w, "automation id is required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">req := automationUpsertRequest{}
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid request", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">current, err := s.store.GetAutomation(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if current == nil </span><span class="cov0" title="0">{
                http.Error(w, "automation not found", http.StatusNotFound)
                return
        }</span>
        <span class="cov8" title="1">updated := toScheduleRecord(*current)
        if value := strings.TrimSpace(req.Name); value != "" </span><span class="cov8" title="1">{
                updated.Name = value
        }</span>
        <span class="cov8" title="1">if value := strings.TrimSpace(req.Prompt); value != "" </span><span class="cov0" title="0">{
                updated.Prompt = value
        }</span>
        <span class="cov8" title="1">if value := strings.TrimSpace(req.Model); value != "" </span><span class="cov0" title="0">{
                updated.Model = value
        }</span>
        <span class="cov8" title="1">if len(req.Days) &gt; 0 </span><span class="cov0" title="0">{
                updated.Days = normalizeDays(req.Days)
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(req.TimeOfDay) != "" </span><span class="cov0" title="0">{
                timeOfDay, err := normalizeTimeOfDay(req.TimeOfDay)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">updated.TimeOfDay = timeOfDay</span>
        }
        <span class="cov8" title="1">if strings.TrimSpace(req.Timezone) != "" </span><span class="cov0" title="0">{
                updated.Timezone = normalizeTimezone(req.Timezone)
        }</span>
        <span class="cov8" title="1">if req.Enabled != nil </span><span class="cov8" title="1">{
                updated.Enabled = *req.Enabled
        }</span>
        <span class="cov8" title="1">updated.UpdatedAt = time.Now().UTC().Format(time.RFC3339Nano)
        if updated.Enabled </span><span class="cov0" title="0">{
                if next, err := computeNextRun(updated.Days, updated.TimeOfDay, updated.Timezone, time.Now().UTC()); err == nil </span><span class="cov0" title="0">{
                        updated.NextRunAt = next.Format(time.RFC3339Nano)
                }</span>
        } else<span class="cov8" title="1"> {
                updated.NextRunAt = ""
        }</span>
        <span class="cov8" title="1">if err := s.store.UpdateAutomation(r.Context(), toStoreAutomation(updated)); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">entries, err := s.store.ListAutomationInbox(r.Context(), id)
        if err == nil </span><span class="cov8" title="1">{
                updated.Unread, updated.LastStatus = summarizeInbox(entries)
        }</span>
        <span class="cov8" title="1">writeJSONStatus(w, updated, http.StatusOK)</span>
}

func (s *Server) deleteAutomation(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id := strings.TrimSpace(chi.URLParam(r, "id"))
        if id == "" </span><span class="cov0" title="0">{
                http.Error(w, "automation id is required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">current, err := s.store.GetAutomation(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if current == nil </span><span class="cov0" title="0">{
                http.Error(w, "automation not found", http.StatusNotFound)
                return
        }</span>
        <span class="cov8" title="1">if err := s.store.DeleteAutomation(r.Context(), id); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">writeJSONStatus(w, map[string]any{"deleted": true}, http.StatusOK)</span>
}

func (s *Server) getAutomationInbox(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        id := strings.TrimSpace(chi.URLParam(r, "id"))
        if id == "" </span><span class="cov0" title="0">{
                http.Error(w, "automation id is required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">automation, err := s.store.GetAutomation(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if automation == nil </span><span class="cov0" title="0">{
                http.Error(w, "automation not found", http.StatusNotFound)
                return
        }</span>
        <span class="cov8" title="1">entries, err := s.store.ListAutomationInbox(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">record := toScheduleRecord(*automation)
        record.Unread, record.LastStatus = summarizeInbox(entries)
        if record.Enabled </span><span class="cov0" title="0">{
                if next, nextErr := computeNextRun(record.Days, record.TimeOfDay, record.Timezone, time.Now().UTC()); nextErr == nil </span><span class="cov0" title="0">{
                        record.NextRunAt = next.Format(time.RFC3339)
                }</span>
        }
        <span class="cov8" title="1">mapped := make([]automationInboxEntry, 0, len(entries))
        for _, entry := range entries </span><span class="cov0" title="0">{
                mapped = append(mapped, toInboxRecord(entry))
        }</span>
        <span class="cov8" title="1">writeJSONStatus(w, automationDetailResponse{Automation: record, Inbox: mapped, UnreadCount: record.Unread}, http.StatusOK)</span>
}

func (s *Server) markAutomationInboxRead(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := strings.TrimSpace(chi.URLParam(r, "id"))
        entryID := strings.TrimSpace(chi.URLParam(r, "entryID"))
        if id == "" || entryID == "" </span><span class="cov0" title="0">{
                http.Error(w, "automation id and entry id are required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">if err := s.store.MarkAutomationInboxEntryRead(r.Context(), id, entryID); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">writeJSONStatus(w, map[string]any{"ok": true}, http.StatusOK)</span>
}

func (s *Server) markAutomationInboxReadAll(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := strings.TrimSpace(chi.URLParam(r, "id"))
        if id == "" </span><span class="cov0" title="0">{
                http.Error(w, "automation id is required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">if err := s.store.MarkAutomationInboxReadAll(r.Context(), id); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">writeJSONStatus(w, map[string]any{"ok": true}, http.StatusOK)</span>
}

func (s *Server) processDueAutomations(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        queued := s.queueDueAutomations("schedule")
        writeJSONStatus(w, automationProcessResponse{Queued: queued}, http.StatusOK)
}</span>

func (s *Server) runAutomationNow(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := strings.TrimSpace(chi.URLParam(r, "id"))
        if id == "" </span><span class="cov0" title="0">{
                http.Error(w, "automation id is required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">queued, reason := s.queueAutomationExecution(id, "manual")
        if !queued </span><span class="cov0" title="0">{
                writeJSONStatus(w, automationQueueResponse{Queued: false, Error: reason}, http.StatusConflict)
                return
        }</span>
        <span class="cov0" title="0">writeJSONStatus(w, automationQueueResponse{Queued: true}, http.StatusAccepted)</span>
}

func (s *Server) queueDueAutomations(trigger string) int <span class="cov0" title="0">{
        now := time.Now().UTC()
        items, err := s.store.ListAutomations(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">candidates := make([]string, 0)
        for _, schedule := range items </span><span class="cov0" title="0">{
                if !schedule.Enabled || schedule.InProgress </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">next, nextErr := computeNextRun(schedule.Days, schedule.TimeOfDay, schedule.Timezone, now.Add(-1*time.Second))
                if nextErr != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">schedule.NextRunAt = next.Format(time.RFC3339Nano)
                schedule.UpdatedAt = now.Format(time.RFC3339Nano)
                _ = s.store.UpdateAutomation(context.Background(), schedule)
                if !next.After(now) </span><span class="cov0" title="0">{
                        candidates = append(candidates, schedule.ID)
                }</span>
        }
        <span class="cov0" title="0">queued := 0
        for _, id := range candidates </span><span class="cov0" title="0">{
                ok, _ := s.queueAutomationExecution(id, trigger)
                if ok </span><span class="cov0" title="0">{
                        queued++
                }</span>
        }
        <span class="cov0" title="0">return queued</span>
}

func (s *Server) queueAutomationExecution(id string, trigger string) (bool, string) <span class="cov0" title="0">{
        s.automationMu.Lock()
        defer s.automationMu.Unlock()

        schedule, err := s.store.GetAutomation(context.Background(), id)
        if err != nil </span><span class="cov0" title="0">{
                return false, "failed to load automation"
        }</span>
        <span class="cov0" title="0">if schedule == nil </span><span class="cov0" title="0">{
                return false, "automation not found"
        }</span>
        <span class="cov0" title="0">if schedule.InProgress </span><span class="cov0" title="0">{
                return false, "automation is already running"
        }</span>
        <span class="cov0" title="0">if !schedule.Enabled </span><span class="cov0" title="0">{
                return false, "automation is disabled"
        }</span>

        <span class="cov0" title="0">now := time.Now().UTC().Format(time.RFC3339Nano)
        entry := store.AutomationInboxEntry{
                ID:           uuid.NewString(),
                AutomationID: id,
                Status:       "queued",
                Trigger:      trigger,
                Unread:       false,
                StartedAt:    now,
                CreatedAt:    now,
                UpdatedAt:    now,
                Diagnostics: map[string]any{
                        "sources": []any{},
                },
        }
        schedule.InProgress = true
        schedule.UpdatedAt = now
        if err := s.store.UpdateAutomation(context.Background(), *schedule); err != nil </span><span class="cov0" title="0">{
                return false, "failed to update automation state"
        }</span>
        <span class="cov0" title="0">if err := s.store.CreateAutomationInboxEntry(context.Background(), entry); err != nil </span><span class="cov0" title="0">{
                schedule.InProgress = false
                schedule.UpdatedAt = time.Now().UTC().Format(time.RFC3339Nano)
                _ = s.store.UpdateAutomation(context.Background(), *schedule)
                return false, "failed to queue automation"
        }</span>
        <span class="cov0" title="0">go s.executeAutomationJob(*schedule, entry.ID)
        return true, ""</span>
}

func (s *Server) executeAutomationJob(schedule store.Automation, entryID string) <span class="cov0" title="0">{
        s.automationMu.Lock()
        entries, _ := s.store.ListAutomationInbox(context.Background(), schedule.ID)
        entry := findInboxEntry(entries, entryID)
        if entry != nil </span><span class="cov0" title="0">{
                entry.Status = "running"
                entry.StartedAt = time.Now().UTC().Format(time.RFC3339Nano)
                entry.UpdatedAt = entry.StartedAt
                _ = s.store.UpdateAutomationInboxEntry(context.Background(), *entry)
        }</span>
        <span class="cov0" title="0">s.automationMu.Unlock()

        wait := true
        req := automationExecuteRequest{
                Prompt:            schedule.Prompt,
                ModelRoute:        strings.TrimSpace(schedule.Model),
                WaitForCompletion: &amp;wait,
                Metadata: map[string]any{
                        "automation_id":   schedule.ID,
                        "automation_name": schedule.Name,
                },
        }
        if strings.TrimSpace(schedule.Model) != "" </span><span class="cov0" title="0">{
                req.Metadata["llm_model"] = strings.TrimSpace(schedule.Model)
        }</span>

        <span class="cov0" title="0">response, err := s.invokeAutomationExecute(req)
        completedAt := time.Now().UTC()

        var (
                notifySchedule store.Automation
                notifyEntry    store.AutomationInboxEntry
                shouldNotify   bool
        )

        s.automationMu.Lock()
        current, loadErr := s.store.GetAutomation(context.Background(), schedule.ID)
        if loadErr != nil || current == nil </span><span class="cov0" title="0">{
                s.automationMu.Unlock()
                return
        }</span>
        <span class="cov0" title="0">entries, _ = s.store.ListAutomationInbox(context.Background(), schedule.ID)
        inboxEntry := findInboxEntry(entries, entryID)
        if inboxEntry != nil </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        inboxEntry.Status = "failed"
                        inboxEntry.Error = err.Error()
                        inboxEntry.FinalResponse = ""
                        inboxEntry.TimedOut = false
                        inboxEntry.Diagnostics = map[string]any{"sources": []any{}}
                }</span> else<span class="cov0" title="0"> {
                        inboxEntry.RunID = response.RunID
                        inboxEntry.Status = response.Status
                        inboxEntry.Phase = response.Phase
                        inboxEntry.CompletionReason = response.CompletionReason
                        inboxEntry.FinalResponse = response.FinalResponse
                        inboxEntry.TimedOut = response.TimedOut
                        inboxEntry.Diagnostics = encodeAutomationDiagnostics(response.Diagnostics)
                }</span>
                <span class="cov0" title="0">inboxEntry.CompletedAt = completedAt.Format(time.RFC3339Nano)
                inboxEntry.Unread = true
                inboxEntry.UpdatedAt = inboxEntry.CompletedAt
                _ = s.store.UpdateAutomationInboxEntry(context.Background(), *inboxEntry)
                notifyEntry = *inboxEntry
                shouldNotify = true</span>
        }

        <span class="cov0" title="0">current.InProgress = false
        current.LastRunAt = completedAt.Format(time.RFC3339Nano)
        current.UpdatedAt = completedAt.Format(time.RFC3339Nano)
        if current.Enabled </span><span class="cov0" title="0">{
                if next, nextErr := computeNextRun(current.Days, current.TimeOfDay, current.Timezone, completedAt); nextErr == nil </span><span class="cov0" title="0">{
                        current.NextRunAt = next.Format(time.RFC3339Nano)
                }</span>
        } else<span class="cov0" title="0"> {
                current.NextRunAt = ""
        }</span>
        <span class="cov0" title="0">_ = s.store.UpdateAutomation(context.Background(), *current)
        notifySchedule = *current
        s.automationMu.Unlock()

        if shouldNotify </span><span class="cov0" title="0">{
                if notifyErr := s.notifyDiscordAutomationCompletion(notifySchedule, notifyEntry); notifyErr != nil </span><span class="cov0" title="0">{
                        log.Printf("automation notification failed automation_id=%s entry_id=%s err=%v", notifySchedule.ID, notifyEntry.ID, notifyErr)
                }</span>
        }
}

func (s *Server) invokeAutomationExecute(req automationExecuteRequest) (automationExecuteResponse, error) <span class="cov0" title="0">{
        payload, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return automationExecuteResponse{}, err
        }</span>
        <span class="cov0" title="0">httpReq := httptest.NewRequest(http.MethodPost, "/automation/execute", bytes.NewReader(payload))
        httpReq.Header.Set("Content-Type", "application/json")
        recorder := httptest.NewRecorder()
        s.executeAutomationRun(recorder, httpReq)

        result := recorder.Result()
        defer result.Body.Close()
        if result.StatusCode &lt; 200 || result.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                raw := strings.TrimSpace(recorder.Body.String())
                if raw == "" </span><span class="cov0" title="0">{
                        raw = "automation execution failed"
                }</span>
                <span class="cov0" title="0">return automationExecuteResponse{}, fmt.Errorf("automation execute failed (%d): %s", result.StatusCode, raw)</span>
        }
        <span class="cov0" title="0">output := automationExecuteResponse{}
        if err := json.NewDecoder(result.Body).Decode(&amp;output); err != nil </span><span class="cov0" title="0">{
                return automationExecuteResponse{}, err
        }</span>
        <span class="cov0" title="0">return output, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        "encoding/base64"
        "encoding/json"
        "fmt"
        "net/http"
        "os"
        "strings"
        "time"

        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store"
)

type contextNodeResponse struct {
        ID          string `json:"id"`
        ParentID    string `json:"parent_id,omitempty"`
        Name        string `json:"name"`
        NodeType    string `json:"node_type"`
        ContentType string `json:"content_type,omitempty"`
        SizeBytes   int64  `json:"size_bytes,omitempty"`
        CreatedAt   string `json:"created_at"`
        UpdatedAt   string `json:"updated_at"`
}

type contextFileResponse struct {
        ID          string `json:"id"`
        ParentID    string `json:"parent_id,omitempty"`
        Name        string `json:"name"`
        NodeType    string `json:"node_type"`
        ContentBase string `json:"content_base64"`
        ContentType string `json:"content_type,omitempty"`
        SizeBytes   int64  `json:"size_bytes,omitempty"`
        CreatedAt   string `json:"created_at"`
        UpdatedAt   string `json:"updated_at"`
}

type contextFolderRequest struct {
        Name     string `json:"name"`
        ParentID string `json:"parent_id"`
}

type contextFileRequest struct {
        Name        string `json:"name"`
        ParentID    string `json:"parent_id"`
        ContentBase string `json:"content_base64"`
        ContentType string `json:"content_type"`
}

func (s *Server) listContextNodes(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        nodes, err := s.store.ListContextNodes(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">response := make([]contextNodeResponse, 0, len(nodes))
        for _, node := range nodes </span><span class="cov8" title="1">{
                response = append(response, contextNodeResponse{
                        ID:          node.ID,
                        ParentID:    node.ParentID,
                        Name:        node.Name,
                        NodeType:    node.NodeType,
                        ContentType: node.ContentType,
                        SizeBytes:   node.SizeBytes,
                        CreatedAt:   node.CreatedAt,
                        UpdatedAt:   node.UpdatedAt,
                })
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(map[string]any{"nodes": response})</span>
}

func (s *Server) createContextFolder(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req contextFolderRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "invalid request", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">name := strings.TrimSpace(req.Name)
        if err := validateContextName(name); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">now := time.Now().UTC().Format(time.RFC3339Nano)
        node := store.ContextNode{
                ID:        uuid.New().String(),
                ParentID:  strings.TrimSpace(req.ParentID),
                Name:      name,
                NodeType:  "folder",
                CreatedAt: now,
                UpdatedAt: now,
        }
        if err := s.store.CreateContextFolder(r.Context(), node); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(contextNodeResponse{
                ID:        node.ID,
                ParentID:  node.ParentID,
                Name:      node.Name,
                NodeType:  node.NodeType,
                CreatedAt: node.CreatedAt,
                UpdatedAt: node.UpdatedAt,
        })</span>
}

func (s *Server) uploadContextFile(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req contextFileRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "invalid request", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">name := strings.TrimSpace(req.Name)
        if err := validateContextName(name); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">content, err := base64.StdEncoding.DecodeString(req.ContentBase)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, "invalid file content", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">now := time.Now().UTC().Format(time.RFC3339Nano)
        node := store.ContextNode{
                ID:          uuid.New().String(),
                ParentID:    strings.TrimSpace(req.ParentID),
                Name:        name,
                NodeType:    "file",
                Content:     content,
                ContentType: strings.TrimSpace(req.ContentType),
                SizeBytes:   int64(len(content)),
                CreatedAt:   now,
                UpdatedAt:   now,
        }
        if err := s.store.CreateContextFile(r.Context(), node); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">s.indexContextFileMemory(r.Context(), node)
        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(contextNodeResponse{
                ID:          node.ID,
                ParentID:    node.ParentID,
                Name:        node.Name,
                NodeType:    node.NodeType,
                ContentType: node.ContentType,
                SizeBytes:   node.SizeBytes,
                CreatedAt:   node.CreatedAt,
                UpdatedAt:   node.UpdatedAt,
        })</span>
}

func (s *Server) getContextFile(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        nodeID := chi.URLParam(r, "id")
        node, err := s.store.GetContextFile(r.Context(), nodeID)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if node == nil </span><span class="cov8" title="1">{
                http.Error(w, "file not found", http.StatusNotFound)
                return
        }</span>
        <span class="cov8" title="1">if node.NodeType != "file" </span><span class="cov8" title="1">{
                http.Error(w, "node is not a file", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(contextFileResponse{
                ID:          node.ID,
                ParentID:    node.ParentID,
                Name:        node.Name,
                NodeType:    node.NodeType,
                ContentBase: base64.StdEncoding.EncodeToString(node.Content),
                ContentType: node.ContentType,
                SizeBytes:   node.SizeBytes,
                CreatedAt:   node.CreatedAt,
                UpdatedAt:   node.UpdatedAt,
        })</span>
}

func (s *Server) deleteContextNode(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        nodeID := chi.URLParam(r, "id")
        if err := s.store.DeleteContextNode(r.Context(), nodeID); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">w.WriteHeader(http.StatusNoContent)</span>
}

func validateContextName(name string) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("name is required")
        }</span>
        <span class="cov8" title="1">if strings.Contains(name, string(os.PathSeparator)) </span><span class="cov8" title="1">{
                return fmt.Errorf("name must not include path separators")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "sort"
        "strings"
        "time"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/llm"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/secrets"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store"
)

var newLLMProvider = llm.NewProvider
var encryptLLMSecret = secrets.Encrypt

type llmSettingsRequest struct {
        Mode          string `json:"mode"`
        Provider      string `json:"provider"`
        Model         string `json:"model"`
        BaseURL       string `json:"base_url"`
        APIKey        string `json:"api_key"`
        CodexAuthPath string `json:"codex_auth_path"`
        CodexHome     string `json:"codex_home"`
}

type llmModelsRequest struct {
        Provider string `json:"provider"`
        Model    string `json:"model"`
        BaseURL  string `json:"base_url"`
        APIKey   string `json:"api_key"`
}

type llmSettingsResponse struct {
        Configured    bool   `json:"configured"`
        Mode          string `json:"mode"`
        Provider      string `json:"provider"`
        Model         string `json:"model"`
        BaseURL       string `json:"base_url"`
        CodexAuthPath string `json:"codex_auth_path,omitempty"`
        CodexHome     string `json:"codex_home,omitempty"`
        HasAPIKey     bool   `json:"has_api_key"`
        APIKeyHint    string `json:"api_key_hint,omitempty"`
}

func (s *Server) getLLMSettings(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        settings, err := s.store.GetLLMSettings(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">response := llmSettingsResponse{
                Configured: false,
                Mode:       s.cfg.LLMMode,
                Provider:   s.cfg.LLMProvider,
                Model:      s.cfg.LLMModel,
                BaseURL:    s.cfg.LLMBaseURL,
        }
        if settings != nil </span><span class="cov8" title="1">{
                response.Configured = true
                response.Mode = settings.Mode
                response.Provider = settings.Provider
                response.Model = settings.Model
                response.BaseURL = settings.BaseURL
                response.CodexAuthPath = settings.CodexAuthPath
                response.CodexHome = settings.CodexHome
                response.HasAPIKey = settings.APIKeyEnc != ""
                if settings.APIKeyEnc != "" &amp;&amp; s.cfg.LLMSecretsKey != "" </span><span class="cov8" title="1">{
                        if key, err := secrets.ParseKey(s.cfg.LLMSecretsKey); err == nil </span><span class="cov8" title="1">{
                                if apiKey, err := secrets.Decrypt(key, settings.APIKeyEnc); err == nil </span><span class="cov8" title="1">{
                                        if len(apiKey) &gt;= 4 </span><span class="cov8" title="1">{
                                                response.APIKeyHint = apiKey[len(apiKey)-4:]
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(response)</span>
}

func (s *Server) updateLLMSettings(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req llmSettingsRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "invalid request", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">settings, err := s.store.GetLLMSettings(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">mode := firstNonEmpty(req.Mode, s.cfg.LLMMode)
        provider := firstNonEmpty(req.Provider, s.cfg.LLMProvider)
        model := firstNonEmpty(req.Model, s.cfg.LLMModel)
        baseURL := firstNonEmpty(req.BaseURL, s.cfg.LLMBaseURL)
        codexAuthPath := firstNonEmpty(req.CodexAuthPath, s.cfg.CodexAuthPath)
        codexHome := firstNonEmpty(req.CodexHome, s.cfg.CodexHome)
        if settings != nil </span><span class="cov8" title="1">{
                mode = firstNonEmpty(req.Mode, settings.Mode)
                provider = firstNonEmpty(req.Provider, settings.Provider)
                model = firstNonEmpty(req.Model, settings.Model)
                baseURL = firstNonEmpty(req.BaseURL, settings.BaseURL)
                codexAuthPath = firstNonEmpty(req.CodexAuthPath, settings.CodexAuthPath)
                codexHome = firstNonEmpty(req.CodexHome, settings.CodexHome)
        }</span>

        <span class="cov8" title="1">apiKeyEnc := ""
        if settings != nil </span><span class="cov8" title="1">{
                apiKeyEnc = settings.APIKeyEnc
        }</span>
        <span class="cov8" title="1">if req.APIKey != "" </span><span class="cov8" title="1">{
                key, err := secrets.ParseKey(s.cfg.LLMSecretsKey)
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">ciphertext, err := encryptLLMSecret(key, req.APIKey)
                if err != nil </span><span class="cov8" title="1">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">apiKeyEnc = ciphertext</span>
        }
        <span class="cov8" title="1">if providerNeedsKey(provider) &amp;&amp; apiKeyEnc == "" &amp;&amp; mode != "local" </span><span class="cov8" title="1">{
                http.Error(w, "API key required for provider", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">now := time.Now().UTC().Format(time.RFC3339Nano)
        createdAt := now
        if settings != nil &amp;&amp; settings.CreatedAt != "" </span><span class="cov8" title="1">{
                createdAt = settings.CreatedAt
        }</span>
        <span class="cov8" title="1">newSettings := store.LLMSettings{
                Mode:          mode,
                Provider:      provider,
                Model:         model,
                BaseURL:       baseURL,
                APIKeyEnc:     apiKeyEnc,
                CodexAuthPath: codexAuthPath,
                CodexHome:     codexHome,
                CreatedAt:     createdAt,
                UpdatedAt:     now,
        }
        if err := s.store.UpsertLLMSettings(r.Context(), newSettings); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">s.getLLMSettings(w, r)</span>
}

func (s *Server) testLLMSettings(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req llmSettingsRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "invalid request", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">providerConfig, err := s.buildLLMConfig(r.Context(), req)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">provider, err := newLLMProvider(providerConfig)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(r.Context(), 60*time.Second)
        defer cancel()
        _, err = provider.Generate(ctx, []llm.Message{{Role: "user", Content: "ping"}})
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(map[string]string{"status": "Connected"})</span>
}

func (s *Server) listLLMModels(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req llmModelsRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "invalid request", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">provider := req.Provider
        if provider == "" </span><span class="cov8" title="1">{
                provider = s.cfg.LLMProvider
                if settings, _ := s.store.GetLLMSettings(r.Context()); settings != nil &amp;&amp; settings.Provider != "" </span><span class="cov8" title="1">{
                        provider = settings.Provider
                        if req.BaseURL == "" </span><span class="cov8" title="1">{
                                req.BaseURL = settings.BaseURL
                        }</span>
                        <span class="cov8" title="1">if req.APIKey == "" &amp;&amp; settings.APIKeyEnc != "" &amp;&amp; s.cfg.LLMSecretsKey != "" </span><span class="cov8" title="1">{
                                if key, err := secrets.ParseKey(s.cfg.LLMSecretsKey); err == nil </span><span class="cov8" title="1">{
                                        if apiKey, err := secrets.Decrypt(key, settings.APIKeyEnc); err == nil </span><span class="cov8" title="1">{
                                                req.APIKey = apiKey
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">if req.Model == "" </span><span class="cov8" title="1">{
                                req.Model = settings.Model
                        }</span>
                }
        }

        <span class="cov8" title="1">models, err := fetchModels(provider, req)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(map[string]any{"models": models})</span>
}

func (s *Server) buildLLMConfig(ctx context.Context, req llmSettingsRequest) (llm.Config, error) <span class="cov8" title="1">{
        mode := firstNonEmpty(req.Mode, s.cfg.LLMMode)
        provider := firstNonEmpty(req.Provider, s.cfg.LLMProvider)
        model := firstNonEmpty(req.Model, s.cfg.LLMModel)
        baseURL := firstNonEmpty(req.BaseURL, s.cfg.LLMBaseURL)
        codexAuthPath := firstNonEmpty(req.CodexAuthPath, s.cfg.CodexAuthPath)
        codexHome := firstNonEmpty(req.CodexHome, s.cfg.CodexHome)

        var apiKey string
        if req.APIKey != "" </span><span class="cov8" title="1">{
                apiKey = req.APIKey
        }</span> else<span class="cov8" title="1"> if settings, err := s.store.GetLLMSettings(ctx); err == nil &amp;&amp; settings != nil </span><span class="cov8" title="1">{
                if providerNeedsKey(provider) &amp;&amp; settings.APIKeyEnc != "" </span><span class="cov8" title="1">{
                        key, err := secrets.ParseKey(s.cfg.LLMSecretsKey)
                        if err != nil </span><span class="cov8" title="1">{
                                return llm.Config{}, err
                        }</span>
                        <span class="cov8" title="1">decrypted, err := secrets.Decrypt(key, settings.APIKeyEnc)
                        if err != nil </span><span class="cov8" title="1">{
                                return llm.Config{}, err
                        }</span>
                        <span class="cov8" title="1">apiKey = decrypted</span>
                }
        }
        <span class="cov8" title="1">if providerNeedsKey(provider) &amp;&amp; apiKey == "" &amp;&amp; mode != "local" </span><span class="cov8" title="1">{
                return llm.Config{}, errors.New("API key required for provider")
        }</span>

        <span class="cov8" title="1">config := llm.Config{
                Mode:          mode,
                Provider:      provider,
                Model:         model,
                BaseURL:       baseURL,
                OpenAIAPIKey:  apiKey,
                CodexAuthPath: codexAuthPath,
                CodexHome:     codexHome,
        }
        switch provider </span>{
        case "openrouter":<span class="cov8" title="1">
                config.OpenRouterAPIKey = apiKey
                config.OpenAIAPIKey = ""</span>
        case "opencode-zen":<span class="cov0" title="0">
                config.OpenCodeAPIKey = apiKey
                config.OpenAIAPIKey = ""</span>
        }
        <span class="cov8" title="1">return config, nil</span>
}

func fetchModels(provider string, req llmModelsRequest) ([]string, error) <span class="cov8" title="1">{
        if provider == "opencode-zen" </span><span class="cov8" title="1">{
                models, err := fetchOpenCodeModels()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return models, nil</span>
        }
        <span class="cov8" title="1">if provider == "kimi-for-coding" </span><span class="cov0" title="0">{
                models := fetchKimiModels(req)
                return models, nil
        }</span>
        <span class="cov8" title="1">if provider == "moonshot-ai" </span><span class="cov0" title="0">{
                models := fetchMoonshotModels(req)
                return models, nil
        }</span>
        <span class="cov8" title="1">if provider == "codex" </span><span class="cov8" title="1">{
                models := []string{"gpt-5.2-codex", "gpt-5.1-codex"}
                return models, nil
        }</span>
        <span class="cov8" title="1">if providerNeedsKey(provider) &amp;&amp; req.APIKey == "" </span><span class="cov8" title="1">{
                return nil, errors.New("API key required to list models")
        }</span>
        <span class="cov8" title="1">baseURL := req.BaseURL
        if baseURL == "" </span><span class="cov8" title="1">{
                if provider == "openrouter" </span><span class="cov8" title="1">{
                        baseURL = "https://openrouter.ai/api/v1"
                }</span> else<span class="cov8" title="1"> {
                        baseURL = "https://api.openai.com/v1"
                }</span>
        }
        <span class="cov8" title="1">client := &amp;http.Client{Timeout: 30 * time.Second}
        url := strings.TrimRight(baseURL, "/") + "/models"
        request, err := http.NewRequestWithContext(context.Background(), http.MethodGet, url, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">request.Header.Set("Authorization", "Bearer "+req.APIKey)
        resp, err := client.Do(request)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode &gt;= 400 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("model list failed: %s", resp.Status)
        }</span>
        <span class="cov8" title="1">var payload struct {
                Data []struct {
                        ID string `json:"id"`
                } `json:"data"`
        }
        if err := json.NewDecoder(resp.Body).Decode(&amp;payload); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">models := make([]string, 0, len(payload.Data))
        for _, entry := range payload.Data </span><span class="cov8" title="1">{
                if entry.ID != "" </span><span class="cov8" title="1">{
                        models = append(models, entry.ID)
                }</span>
        }
        <span class="cov8" title="1">sort.Strings(models)
        return models, nil</span>
}

func providerNeedsKey(provider string) bool <span class="cov8" title="1">{
        switch provider </span>{
        case "openai", "openrouter", "opencode-zen", "kimi-for-coding", "moonshot-ai":<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func fetchKimiModels(req llmModelsRequest) []string <span class="cov0" title="0">{
        // Try to fetch from API if key provided
        if req.APIKey != "" </span><span class="cov0" title="0">{
                baseURL := req.BaseURL
                if baseURL == "" </span><span class="cov0" title="0">{
                        baseURL = "https://api.kimi.com/coding/v1"
                }</span>
                <span class="cov0" title="0">client := &amp;http.Client{Timeout: 30 * time.Second}
                url := strings.TrimRight(baseURL, "/") + "/models"
                request, err := http.NewRequestWithContext(context.Background(), http.MethodGet, url, nil)
                if err == nil </span><span class="cov0" title="0">{
                        request.Header.Set("Authorization", "Bearer "+req.APIKey)
                        resp, err := client.Do(request)
                        if err == nil &amp;&amp; resp.StatusCode &lt; 400 </span><span class="cov0" title="0">{
                                defer resp.Body.Close()
                                var payload struct {
                                        Data []struct {
                                                ID string `json:"id"`
                                        } `json:"data"`
                                }
                                if err := json.NewDecoder(resp.Body).Decode(&amp;payload); err == nil &amp;&amp; len(payload.Data) &gt; 0 </span><span class="cov0" title="0">{
                                        models := make([]string, 0, len(payload.Data))
                                        for _, entry := range payload.Data </span><span class="cov0" title="0">{
                                                if entry.ID != "" </span><span class="cov0" title="0">{
                                                        models = append(models, entry.ID)
                                                }</span>
                                        }
                                        <span class="cov0" title="0">if len(models) &gt; 0 </span><span class="cov0" title="0">{
                                                sort.Strings(models)
                                                return models
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> if resp != nil </span><span class="cov0" title="0">{
                                resp.Body.Close()
                        }</span>
                }
        }
        // Fallback to hardcoded list
        <span class="cov0" title="0">return []string{
                "kimi-k2",
                "kimi-k2-thinking",
                "kimi-k2.5",
                "kimi-k2.5-free",
        }</span>
}

func fetchMoonshotModels(req llmModelsRequest) []string <span class="cov0" title="0">{
        // Try to fetch from API if key provided
        if req.APIKey != "" </span><span class="cov0" title="0">{
                baseURL := req.BaseURL
                if baseURL == "" </span><span class="cov0" title="0">{
                        baseURL = "https://api.moonshot.ai/v1"
                }</span>
                <span class="cov0" title="0">client := &amp;http.Client{Timeout: 30 * time.Second}
                url := strings.TrimRight(baseURL, "/") + "/models"
                request, err := http.NewRequestWithContext(context.Background(), http.MethodGet, url, nil)
                if err == nil </span><span class="cov0" title="0">{
                        request.Header.Set("Authorization", "Bearer "+req.APIKey)
                        resp, err := client.Do(request)
                        if err == nil &amp;&amp; resp.StatusCode &lt; 400 </span><span class="cov0" title="0">{
                                defer resp.Body.Close()
                                var payload struct {
                                        Data []struct {
                                                ID string `json:"id"`
                                        } `json:"data"`
                                }
                                if err := json.NewDecoder(resp.Body).Decode(&amp;payload); err == nil &amp;&amp; len(payload.Data) &gt; 0 </span><span class="cov0" title="0">{
                                        models := make([]string, 0, len(payload.Data))
                                        for _, entry := range payload.Data </span><span class="cov0" title="0">{
                                                if entry.ID != "" </span><span class="cov0" title="0">{
                                                        models = append(models, entry.ID)
                                                }</span>
                                        }
                                        <span class="cov0" title="0">if len(models) &gt; 0 </span><span class="cov0" title="0">{
                                                sort.Strings(models)
                                                return models
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> if resp != nil </span><span class="cov0" title="0">{
                                resp.Body.Close()
                        }</span>
                }
        }
        // Fallback to popular Moonshot models
        <span class="cov0" title="0">return []string{
                "moonshot-v1-8k",
                "moonshot-v1-32k",
                "moonshot-v1-128k",
                "moonshot-v1-8k-vision",
                "moonshot-v1-32k-vision",
                "moonshot-v1-128k-vision",
        }</span>
}

func fetchOpenCodeModels() ([]string, error) <span class="cov8" title="1">{
        // Comprehensive fallback list of OpenCode models (sorted alphabetically)
        // Based on actual models available from OpenCode screenshots
        fallbackModels := []string{
                "big-pickle",
                "claude-3-5-haiku",
                "claude-haiku-4-5",
                "claude-opus-4-1",
                "claude-opus-4-5",
                "claude-sonnet-4",
                "claude-sonnet-4-5",
                "gemini-3-flash",
                "gemini-3-pro",
                "glm-4.6",
                "glm-4.7",
                "glm-4.7-free",
                "gpt-5",
                "gpt-5-codex",
                "gpt-5-nano",
                "gpt-5.1",
                "gpt-5.1-codex",
                "gpt-5.1-codex-max",
                "gpt-5.1-codex-mini",
                "gpt-5.2",
                "gpt-5.2-codex",
                "grok-code",
                "kimi-k2",
                "kimi-k2-thinking",
                "kimi-k2.5",
                "kimi-k2.5-free",
                "minimax-m2.1",
                "minimax-m2.1-free",
                "qwen3-coder",
                "trinity-large-preview-free",
        }

        client := &amp;http.Client{Timeout: 30 * time.Second}

        // Try endpoints in order of preference
        endpoints := []string{
                "https://api.opencode.ai/v1/models",
                "https://models.dev/api/models",
                "https://models.dev/api/models.json",
        }

        for _, endpoint := range endpoints </span><span class="cov8" title="1">{
                resp, err := client.Get(endpoint)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        resp.Body.Close()
                        continue</span>
                }

                // Try parsing as flat array of model IDs first
                <span class="cov8" title="1">var flatPayload []string
                if err := json.NewDecoder(resp.Body).Decode(&amp;flatPayload); err == nil &amp;&amp; len(flatPayload) &gt; 0 </span><span class="cov0" title="0">{
                        resp.Body.Close()
                        models := dedupeAndSortModels(flatPayload)
                        if len(models) &gt; 0 </span><span class="cov0" title="0">{
                                return models, nil
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Try OpenAI-compatible format with "data" array
                <span class="cov8" title="1">resp.Body.Close()
                resp, err = client.Get(endpoint)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">var openAIFormat struct {
                        Data []struct {
                                ID string `json:"id"`
                        } `json:"data"`
                }
                if err := json.NewDecoder(resp.Body).Decode(&amp;openAIFormat); err == nil &amp;&amp; len(openAIFormat.Data) &gt; 0 </span><span class="cov0" title="0">{
                        resp.Body.Close()
                        models := make([]string, 0, len(openAIFormat.Data))
                        seen := make(map[string]struct{})
                        for _, m := range openAIFormat.Data </span><span class="cov0" title="0">{
                                if m.ID != "" </span><span class="cov0" title="0">{
                                        if _, exists := seen[m.ID]; !exists </span><span class="cov0" title="0">{
                                                seen[m.ID] = struct{}{}
                                                models = append(models, m.ID)
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">sort.Strings(models)
                        if len(models) &gt; 0 </span><span class="cov0" title="0">{
                                return models, nil
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Try object array format with "id" field
                <span class="cov8" title="1">resp.Body.Close()
                resp, err = client.Get(endpoint)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">var objPayload []struct {
                        ID string `json:"id"`
                }
                if err := json.NewDecoder(resp.Body).Decode(&amp;objPayload); err == nil &amp;&amp; len(objPayload) &gt; 0 </span><span class="cov0" title="0">{
                        resp.Body.Close()
                        models := make([]string, 0, len(objPayload))
                        seen := make(map[string]struct{})
                        for _, m := range objPayload </span><span class="cov0" title="0">{
                                if m.ID != "" </span><span class="cov0" title="0">{
                                        if _, exists := seen[m.ID]; !exists </span><span class="cov0" title="0">{
                                                seen[m.ID] = struct{}{}
                                                models = append(models, m.ID)
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">sort.Strings(models)
                        if len(models) &gt; 0 </span><span class="cov0" title="0">{
                                return models, nil
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="1">resp.Body.Close()</span>
        }

        // All endpoints failed, return fallback
        <span class="cov8" title="1">return fallbackModels, nil</span>
}

func dedupeAndSortModels(models []string) []string <span class="cov0" title="0">{
        seen := make(map[string]struct{})
        result := make([]string, 0, len(models))
        for _, m := range models </span><span class="cov0" title="0">{
                if m != "" </span><span class="cov0" title="0">{
                        if _, exists := seen[m]; !exists </span><span class="cov0" title="0">{
                                seen[m] = struct{}{}
                                result = append(result, m)
                        }</span>
                }
        }
        <span class="cov0" title="0">sort.Strings(result)
        return result</span>
}

func firstNonEmpty(value string, fallback string) string <span class="cov8" title="1">{
        if strings.TrimSpace(value) != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return fallback</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "encoding/json"
        "net/http"
        "time"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store"
)

type memorySettingsRequest struct {
        Enabled bool `json:"enabled"`
}

type memorySettingsResponse struct {
        Enabled   bool   `json:"enabled"`
        CreatedAt string `json:"created_at"`
        UpdatedAt string `json:"updated_at"`
}

func (s *Server) getMemorySettings(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        settings, err := s.store.GetMemorySettings(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">response := memorySettingsResponse{Enabled: false}
        if settings != nil </span><span class="cov8" title="1">{
                response.Enabled = settings.Enabled
                response.CreatedAt = settings.CreatedAt
                response.UpdatedAt = settings.UpdatedAt
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(response)</span>
}

func (s *Server) updateMemorySettings(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req memorySettingsRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "invalid request", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">current, err := s.store.GetMemorySettings(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">now := time.Now().UTC().Format(time.RFC3339Nano)
        createdAt := now
        if current != nil &amp;&amp; current.CreatedAt != "" </span><span class="cov8" title="1">{
                createdAt = current.CreatedAt
        }</span>
        <span class="cov8" title="1">settings := store.MemorySettings{
                Enabled:   req.Enabled,
                CreatedAt: createdAt,
                UpdatedAt: now,
        }
        if err := s.store.UpsertMemorySettings(r.Context(), settings); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">get := memorySettingsResponse{
                Enabled:   settings.Enabled,
                CreatedAt: settings.CreatedAt,
                UpdatedAt: settings.UpdatedAt,
        }
        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(get)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "strconv"
        "strings"
        "time"
        "unicode/utf8"

        "github.com/google/uuid"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store"
)

func (s *Server) indexMessageMemory(ctx context.Context, msg store.Message) <span class="cov8" title="1">{
        if !s.memoryEnabled(ctx) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if msg.Role != "user" &amp;&amp; msg.Role != "assistant" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">content := strings.TrimSpace(msg.Content)
        if content == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if len([]rune(content)) &lt; s.cfg.MemoryMinContentChars </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">chunks := chunkContent(content, s.cfg.MemoryChunkChars, s.cfg.MemoryChunkOverlap, s.cfg.MemoryMaxChunks)
        if len(chunks) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">for index, chunk := range chunks </span><span class="cov8" title="1">{
                normalized := normalizeContent(chunk)
                fingerprint := memoryFingerprint("chat_message", msg.Role, normalized, strconv.Itoa(index))
                metadata := map[string]any{
                        "source":      "chat_message",
                        "run_id":      msg.RunID,
                        "message_id":  msg.ID,
                        "role":        msg.Role,
                        "sequence":    msg.Sequence,
                        "created_at":  msg.CreatedAt,
                        "chunk_index": index,
                        "chunk_total": len(chunks),
                        "fingerprint": fingerprint,
                }
                entry := store.MemoryEntry{
                        ID:        uuid.New().String(),
                        Content:   chunk,
                        Metadata:  metadata,
                        CreatedAt: msg.CreatedAt,
                        UpdatedAt: msg.CreatedAt,
                        Embedding: readFloat32Slice(msg.Metadata, "embedding"),
                }
                if entry.CreatedAt == "" </span><span class="cov0" title="0">{
                        entry.CreatedAt = nowUTC()
                        entry.UpdatedAt = entry.CreatedAt
                }</span>
                <span class="cov8" title="1">if _, err := s.store.UpsertMemoryEntry(ctx, entry); err != nil </span><span class="cov0" title="0">{
                        s.recordMemoryIndexError(ctx, msg.RunID, "chat_message", err)
                        return
                }</span>
        }
}

func (s *Server) indexContextFileMemory(ctx context.Context, node store.ContextNode) <span class="cov8" title="1">{
        if !s.memoryEnabled(ctx) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if node.NodeType != "file" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if s.cfg.MemoryMaxContentBytes &gt; 0 &amp;&amp; int64(len(node.Content)) &gt; int64(s.cfg.MemoryMaxContentBytes) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !utf8.Valid(node.Content) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !isTextContentType(node.ContentType) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">content := strings.TrimSpace(string(node.Content))
        if content == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if len([]rune(content)) &lt; s.cfg.MemoryMinContentChars </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">path := s.contextPathForNode(ctx, node)
        chunks := chunkContent(content, s.cfg.MemoryChunkChars, s.cfg.MemoryChunkOverlap, s.cfg.MemoryMaxChunks)
        if len(chunks) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">for index, chunk := range chunks </span><span class="cov8" title="1">{
                normalized := normalizeContent(chunk)
                fingerprint := memoryFingerprint("context_file", path, normalized, strconv.Itoa(index))
                metadata := map[string]any{
                        "source":       "context_file",
                        "context_id":   node.ID,
                        "context_path": path,
                        "content_type": node.ContentType,
                        "size_bytes":   node.SizeBytes,
                        "created_at":   node.CreatedAt,
                        "updated_at":   node.UpdatedAt,
                        "chunk_index":  index,
                        "chunk_total":  len(chunks),
                        "fingerprint":  fingerprint,
                }
                entry := store.MemoryEntry{
                        ID:        uuid.New().String(),
                        Content:   chunk,
                        Metadata:  metadata,
                        CreatedAt: node.CreatedAt,
                        UpdatedAt: node.UpdatedAt,
                }
                if entry.CreatedAt == "" </span><span class="cov0" title="0">{
                        entry.CreatedAt = nowUTC()
                        entry.UpdatedAt = entry.CreatedAt
                }</span>
                <span class="cov8" title="1">if _, err := s.store.UpsertMemoryEntry(ctx, entry); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
}

func (s *Server) memoryEnabled(ctx context.Context) bool <span class="cov8" title="1">{
        settings, err := s.store.GetMemorySettings(ctx)
        if err != nil || settings == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return settings.Enabled</span>
}

func (s *Server) recordMemoryIndexError(ctx context.Context, runID string, source string, err error) <span class="cov0" title="0">{
        if runID == "" || s.broker == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">seq, _ := s.store.NextSeq(ctx, runID)
        event := store.RunEvent{
                RunID:     runID,
                Seq:       seq,
                Type:      "memory_index_failed",
                Timestamp: nowUTC(),
                Source:    "control_plane",
                TraceID:   uuid.New().String(),
                Payload:   map[string]any{"source": source, "error": err.Error()},
        }
        _ = s.store.AppendEvent(ctx, event)
        s.broker.Publish(toEvent(event))</span>
}

func (s *Server) contextPathForNode(ctx context.Context, node store.ContextNode) string <span class="cov8" title="1">{
        parts := []string{node.Name}
        if node.ParentID != "" </span><span class="cov0" title="0">{
                nodes, err := s.store.ListContextNodes(ctx)
                if err == nil </span><span class="cov0" title="0">{
                        lookup := map[string]store.ContextNode{}
                        for _, item := range nodes </span><span class="cov0" title="0">{
                                lookup[item.ID] = item
                        }</span>
                        <span class="cov0" title="0">current := node.ParentID
                        visited := map[string]bool{}
                        for current != "" </span><span class="cov0" title="0">{
                                if visited[current] </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">visited[current] = true
                                parent, ok := lookup[current]
                                if !ok </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">parts = append([]string{parent.Name}, parts...)
                                current = parent.ParentID</span>
                        }
                }
        }
        <span class="cov8" title="1">return "/context/" + strings.Join(parts, "/")</span>
}

func chunkContent(content string, maxChars int, overlap int, maxChunks int) []string <span class="cov8" title="1">{
        if maxChars &lt;= 0 </span><span class="cov0" title="0">{
                return []string{content}
        }</span>
        <span class="cov8" title="1">runes := []rune(content)
        if len(runes) &lt;= maxChars </span><span class="cov8" title="1">{
                return []string{content}
        }</span>
        <span class="cov0" title="0">step := maxChars - overlap
        if step &lt;= 0 </span><span class="cov0" title="0">{
                step = maxChars
        }</span>
        <span class="cov0" title="0">chunks := []string{}
        for start := 0; start &lt; len(runes); start += step </span><span class="cov0" title="0">{
                end := start + maxChars
                if end &gt; len(runes) </span><span class="cov0" title="0">{
                        end = len(runes)
                }</span>
                <span class="cov0" title="0">chunks = append(chunks, string(runes[start:end]))
                if maxChunks &gt; 0 &amp;&amp; len(chunks) &gt;= maxChunks </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return chunks</span>
}

func normalizeContent(content string) string <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(content)
        if trimmed == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return strings.Join(strings.Fields(trimmed), " ")</span>
}

func memoryFingerprint(parts ...string) string <span class="cov8" title="1">{
        hasher := sha256.New()
        for index, part := range parts </span><span class="cov8" title="1">{
                if index &gt; 0 </span><span class="cov8" title="1">{
                        _, _ = hasher.Write([]byte("|"))
                }</span>
                <span class="cov8" title="1">_, _ = hasher.Write([]byte(part))</span>
        }
        <span class="cov8" title="1">return hex.EncodeToString(hasher.Sum(nil))</span>
}

func readFloat32Slice(metadata map[string]any, key string) []float32 <span class="cov8" title="1">{
        if metadata == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">value, ok := metadata[key]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">slice, ok := value.([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">results := make([]float32, 0, len(slice))
        for _, item := range slice </span><span class="cov0" title="0">{
                switch v := item.(type) </span>{
                case float32:<span class="cov0" title="0">
                        results = append(results, v)</span>
                case float64:<span class="cov0" title="0">
                        results = append(results, float32(v))</span>
                case int:<span class="cov0" title="0">
                        results = append(results, float32(v))</span>
                case int64:<span class="cov0" title="0">
                        results = append(results, float32(v))</span>
                case json.Number:<span class="cov0" title="0">
                        if parsed, err := v.Float64(); err == nil </span><span class="cov0" title="0">{
                                results = append(results, float32(parsed))
                        }</span>
                }
        }
        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return results</span>
}

func isTextContentType(contentType string) bool <span class="cov8" title="1">{
        trimmed := strings.ToLower(strings.TrimSpace(contentType))
        if trimmed == "" </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(trimmed, "text/") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">switch trimmed </span>{
        case "application/json", "application/xml", "application/yaml", "application/x-yaml", "application/toml", "application/markdown":<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func nowUTC() string <span class="cov0" title="0">{
        return time.Now().UTC().Format(time.RFC3339Nano)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package api

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store"
)

type discordWebhookPayload struct {
        Content string                `json:"content,omitempty"`
        Embeds  []discordWebhookEmbed `json:"embeds,omitempty"`
}

type discordWebhookEmbed struct {
        Title       string              `json:"title,omitempty"`
        Description string              `json:"description,omitempty"`
        Color       int                 `json:"color,omitempty"`
        Timestamp   string              `json:"timestamp,omitempty"`
        Fields      []discordEmbedField `json:"fields,omitempty"`
}

type discordEmbedField struct {
        Name   string `json:"name"`
        Value  string `json:"value"`
        Inline bool   `json:"inline,omitempty"`
}

func (s *Server) notifyDiscordAutomationCompletion(schedule store.Automation, entry store.AutomationInboxEntry) error <span class="cov8" title="1">{
        webhookURL := strings.TrimSpace(s.cfg.DiscordWebhookURL)
        if webhookURL == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">status := normalizeAutomationStatus(entry.Status)
        title := fmt.Sprintf("Gavryn automation %s", status)
        if strings.TrimSpace(schedule.Name) != "" </span><span class="cov8" title="1">{
                title = fmt.Sprintf("Gavryn automation %s: %s", status, strings.TrimSpace(schedule.Name))
        }</span>

        <span class="cov8" title="1">description := strings.TrimSpace(entry.FinalResponse)
        if description == "" </span><span class="cov0" title="0">{
                description = strings.TrimSpace(entry.Error)
        }</span>
        <span class="cov8" title="1">if description == "" </span><span class="cov0" title="0">{
                description = "Automation run completed."
        }</span>
        <span class="cov8" title="1">description = truncateForDiscord(description, 900)

        fields := []discordEmbedField{
                {Name: "Status", Value: status, Inline: true},
                {Name: "Trigger", Value: fallbackString(entry.Trigger, "schedule"), Inline: true},
        }
        if runID := strings.TrimSpace(entry.RunID); runID != "" </span><span class="cov8" title="1">{
                fields = append(fields, discordEmbedField{Name: "Run ID", Value: runID, Inline: false})
        }</span>
        <span class="cov8" title="1">if reason := strings.TrimSpace(entry.CompletionReason); reason != "" </span><span class="cov8" title="1">{
                fields = append(fields, discordEmbedField{Name: "Completion Reason", Value: truncateForDiscord(reason, 240), Inline: false})
        }</span>

        <span class="cov8" title="1">payload := discordWebhookPayload{
                Embeds: []discordWebhookEmbed{
                        {
                                Title:       title,
                                Description: description,
                                Color:       discordStatusColor(status),
                                Timestamp:   time.Now().UTC().Format(time.RFC3339),
                                Fields:      fields,
                        },
                },
        }

        raw, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequest(http.MethodPost, webhookURL, bytes.NewReader(raw))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(io.LimitReader(resp.Body, 512))
                return fmt.Errorf("discord webhook rejected request: status=%d body=%s", resp.StatusCode, strings.TrimSpace(string(body)))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func normalizeAutomationStatus(status string) string <span class="cov8" title="1">{
        switch strings.TrimSpace(strings.ToLower(status)) </span>{
        case "completed", "partial", "failed", "cancelled":<span class="cov8" title="1">
                return strings.TrimSpace(strings.ToLower(status))</span>
        default:<span class="cov0" title="0">
                return "completed"</span>
        }
}

func discordStatusColor(status string) int <span class="cov8" title="1">{
        switch normalizeAutomationStatus(status) </span>{
        case "failed":<span class="cov8" title="1">
                return 15158332</span>
        case "cancelled":<span class="cov0" title="0">
                return 10181046</span>
        case "partial":<span class="cov0" title="0">
                return 16776960</span>
        default:<span class="cov0" title="0">
                return 5763719</span>
        }
}

func truncateForDiscord(value string, limit int) string <span class="cov8" title="1">{
        text := strings.TrimSpace(value)
        if text == "" || limit &lt;= 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">if len(text) &lt;= limit </span><span class="cov8" title="1">{
                return text
        }</span>
        <span class="cov8" title="1">if limit &lt;= 3 </span><span class="cov0" title="0">{
                return text[:limit]
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(text[:limit-3]) + "..."</span>
}

func fallbackString(value string, fallback string) string <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(value)
        if trimmed == "" </span><span class="cov0" title="0">{
                return fallback
        }</span>
        <span class="cov8" title="1">return trimmed</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package api

import (
        "encoding/json"
        "net/http"
        "strings"
        "time"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/personality"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store"
)

type personalitySettingsRequest struct {
        Content string `json:"content"`
}

type personalitySettingsResponse struct {
        Content   string `json:"content"`
        Source    string `json:"source"`
        CreatedAt string `json:"created_at,omitempty"`
        UpdatedAt string `json:"updated_at,omitempty"`
}

func (s *Server) getPersonalitySettings(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        settings, err := s.store.GetPersonalitySettings(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">response := personalitySettingsResponse{}
        if settings != nil &amp;&amp; strings.TrimSpace(settings.Content) != "" </span><span class="cov0" title="0">{
                response.Content = settings.Content
                response.Source = "stored"
                response.CreatedAt = settings.CreatedAt
                response.UpdatedAt = settings.UpdatedAt
        }</span> else<span class="cov8" title="1"> if content, err := personality.ReadFromDisk(); err == nil &amp;&amp; strings.TrimSpace(content) != "" </span><span class="cov0" title="0">{
                response.Content = content
                response.Source = "file"
        }</span> else<span class="cov8" title="1"> {
                response.Content = personality.Default
                response.Source = "default"
        }</span>
        <span class="cov8" title="1">if response.Source == "" </span><span class="cov0" title="0">{
                response.Source = "default"
                response.Content = personality.Default
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(response)</span>
}

func (s *Server) updatePersonalitySettings(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req personalitySettingsRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid request", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">current, err := s.store.GetPersonalitySettings(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">now := time.Now().UTC().Format(time.RFC3339Nano)
        createdAt := now
        if current != nil &amp;&amp; current.CreatedAt != "" </span><span class="cov0" title="0">{
                createdAt = current.CreatedAt
        }</span>
        <span class="cov8" title="1">settings := store.PersonalitySettings{
                Content:   req.Content,
                CreatedAt: createdAt,
                UpdatedAt: now,
        }
        if err := s.store.UpsertPersonalitySettings(r.Context(), settings); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">response := personalitySettingsResponse{
                Content:   settings.Content,
                Source:    "stored",
                CreatedAt: settings.CreatedAt,
                UpdatedAt: settings.UpdatedAt,
        }
        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(response)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package api

import (
        "context"
        "encoding/json"
        "net/http"
        "strings"
        "time"

        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store"
)

type runSummaryResponse struct {
        ID               string   `json:"id"`
        Status           string   `json:"status"`
        Phase            string   `json:"phase"`
        CompletionReason string   `json:"completion_reason,omitempty"`
        ResumedFrom      string   `json:"resumed_from,omitempty"`
        CheckpointSeq    int64    `json:"checkpoint_seq"`
        PolicyProfile    string   `json:"policy_profile,omitempty"`
        ModelRoute       string   `json:"model_route,omitempty"`
        Tags             []string `json:"tags,omitempty"`
        Title            string   `json:"title"`
        CreatedAt        string   `json:"created_at"`
        UpdatedAt        string   `json:"updated_at"`
        MessageCount     int64    `json:"message_count"`
}

type listRunsResponse struct {
        Runs []runSummaryResponse `json:"runs"`
}

type runStepResponse struct {
        ID          string         `json:"id"`
        Kind        string         `json:"kind"`
        Name        string         `json:"name"`
        Status      string         `json:"status"`
        Source      string         `json:"source"`
        Seq         int64          `json:"seq"`
        StartedAt   string         `json:"started_at,omitempty"`
        CompletedAt string         `json:"completed_at,omitempty"`
        Error       string         `json:"error,omitempty"`
        Diagnostics map[string]any `json:"diagnostics,omitempty"`
}

type listRunStepsResponse struct {
        Steps []runStepResponse `json:"steps"`
}

func (s *Server) listRuns(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        runs, err := s.store.ListRuns(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">response := listRunsResponse{Runs: make([]runSummaryResponse, 0, len(runs))}
        for _, run := range runs </span><span class="cov0" title="0">{
                response.Runs = append(response.Runs, runSummaryResponse{
                        ID:               run.ID,
                        Status:           run.Status,
                        Phase:            run.Phase,
                        CompletionReason: run.CompletionReason,
                        ResumedFrom:      run.ResumedFrom,
                        CheckpointSeq:    run.CheckpointSeq,
                        PolicyProfile:    run.PolicyProfile,
                        ModelRoute:       run.ModelRoute,
                        Tags:             run.Tags,
                        Title:            run.Title,
                        CreatedAt:        run.CreatedAt,
                        UpdatedAt:        run.UpdatedAt,
                        MessageCount:     run.MessageCount,
                })
        }</span>
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(response)</span>
}

func (s *Server) getRun(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        runID := chi.URLParam(r, "id")
        if runID == "" </span><span class="cov0" title="0">{
                http.Error(w, "run id required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">runs, err := s.store.ListRuns(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">for _, run := range runs </span><span class="cov8" title="1">{
                if run.ID != runID </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
                _ = json.NewEncoder(w).Encode(runSummaryResponse{
                        ID:               run.ID,
                        Status:           run.Status,
                        Phase:            run.Phase,
                        CompletionReason: run.CompletionReason,
                        ResumedFrom:      run.ResumedFrom,
                        CheckpointSeq:    run.CheckpointSeq,
                        PolicyProfile:    run.PolicyProfile,
                        ModelRoute:       run.ModelRoute,
                        Tags:             run.Tags,
                        Title:            run.Title,
                        CreatedAt:        run.CreatedAt,
                        UpdatedAt:        run.UpdatedAt,
                        MessageCount:     run.MessageCount,
                })
                return</span>
        }
        <span class="cov8" title="1">http.Error(w, "run not found", http.StatusNotFound)</span>
}

func (s *Server) listRunSteps(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        runID := chi.URLParam(r, "id")
        if runID == "" </span><span class="cov0" title="0">{
                http.Error(w, "run id required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">steps, err := s.store.ListRunSteps(r.Context(), runID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">response := make([]runStepResponse, 0, len(steps))
        for _, step := range steps </span><span class="cov8" title="1">{
                response = append(response, runStepResponse{
                        ID:          step.ID,
                        Kind:        step.Kind,
                        Name:        step.Name,
                        Status:      step.Status,
                        Source:      step.Source,
                        Seq:         step.Seq,
                        StartedAt:   step.StartedAt,
                        CompletedAt: step.CompletedAt,
                        Error:       step.Error,
                        Diagnostics: step.Diagnostics,
                })
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(listRunStepsResponse{Steps: response})</span>
}

func (s *Server) deleteRun(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        runID := chi.URLParam(r, "id")
        if runID == "" </span><span class="cov0" title="0">{
                http.Error(w, "run id required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">cleanupCtx, cleanupCancel := context.WithTimeout(r.Context(), 10*time.Second)
        _, _ = s.stopAllWorkspaceProcesses(cleanupCtx, runID)
        cleanupCancel()
        if s.workflows != nil </span><span class="cov0" title="0">{
                _ = s.workflows.CancelRun(r.Context(), runID)
        }</span>
        <span class="cov8" title="1">if err := s.store.DeleteRun(r.Context(), runID); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">w.WriteHeader(http.StatusNoContent)</span>
}

type resumeRunRequest struct {
        Message string `json:"message"`
}

func (s *Server) resumeRun(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        runID := chi.URLParam(r, "id")
        if runID == "" </span><span class="cov0" title="0">{
                http.Error(w, "run id required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if !s.ensureLLMConfigured(w, r.Context()) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">runs, err := s.store.ListRuns(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">var summary *runSummaryResponse
        for _, run := range runs </span><span class="cov8" title="1">{
                if run.ID != runID </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">summary = &amp;runSummaryResponse{
                        ID:               run.ID,
                        Status:           run.Status,
                        Phase:            run.Phase,
                        CompletionReason: run.CompletionReason,
                        ResumedFrom:      run.ResumedFrom,
                        CheckpointSeq:    run.CheckpointSeq,
                        PolicyProfile:    run.PolicyProfile,
                        ModelRoute:       run.ModelRoute,
                        Tags:             run.Tags,
                        Title:            run.Title,
                        CreatedAt:        run.CreatedAt,
                        UpdatedAt:        run.UpdatedAt,
                        MessageCount:     run.MessageCount,
                }
                break</span>
        }
        <span class="cov8" title="1">if summary == nil </span><span class="cov8" title="1">{
                http.Error(w, "run not found", http.StatusNotFound)
                return
        }</span>
        <span class="cov8" title="1">if strings.EqualFold(summary.Status, "running") </span><span class="cov8" title="1">{
                http.Error(w, "run is already running", http.StatusConflict)
                return
        }</span>

        <span class="cov8" title="1">req := resumeRunRequest{}
        if r.Body != nil </span><span class="cov8" title="1">{
                _ = json.NewDecoder(r.Body).Decode(&amp;req)
        }</span>
        <span class="cov8" title="1">messageContent := strings.TrimSpace(req.Message)
        if messageContent == "" </span><span class="cov8" title="1">{
                messageContent = "Continue from the latest checkpoint and complete the task."
        }</span>
        <span class="cov8" title="1">now := time.Now().UTC().Format(time.RFC3339Nano)
        message := store.Message{
                ID:        uuid.New().String(),
                RunID:     runID,
                Role:      "user",
                Content:   messageContent,
                Sequence:  time.Now().UnixNano(),
                CreatedAt: now,
                Metadata: map[string]any{
                        "resume": true,
                },
        }
        if err := s.store.AddMessage(r.Context(), message); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">s.indexMessageMemory(r.Context(), message)

        if s.workflows != nil </span><span class="cov8" title="1">{
                if err := s.workflows.ResumeRun(r.Context(), runID, messageContent); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadGateway)
                        return
                }</span>
        }

        <span class="cov8" title="1">seq, _ := s.store.NextSeq(r.Context(), runID)
        event := store.RunEvent{
                RunID:     runID,
                Seq:       seq,
                Type:      "run.resumed",
                Timestamp: now,
                Source:    "control_plane",
                TraceID:   uuid.New().String(),
                Payload: map[string]any{
                        "message_id": message.ID,
                        "status":     "running",
                        "phase":      "planning",
                },
        }
        _ = s.store.AppendEvent(r.Context(), event)
        _ = s.upsertArtifactsFromEvent(r.Context(), event)
        s.broker.Publish(toEvent(event))

        w.WriteHeader(http.StatusAccepted)
        _ = json.NewEncoder(w).Encode(map[string]string{
                "run_id": runID,
                "status": "running",
        })</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package api

import (
        "context"
        "net/http"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
        "time"

        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/events"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store"
)

type listArtifactsResponse struct {
        Artifacts  []artifactResponse `json:"artifacts"`
        Page       int                `json:"page"`
        PageSize   int                `json:"page_size"`
        Total      int                `json:"total"`
        TotalPages int                `json:"total_pages"`
}

type artifactResponse struct {
        ID             string         `json:"id"`
        RunID          string         `json:"run_id"`
        Type           string         `json:"type"`
        Category       string         `json:"category,omitempty"`
        URI            string         `json:"uri"`
        ContentType    string         `json:"content_type"`
        SizeBytes      int64          `json:"size_bytes"`
        Checksum       string         `json:"checksum,omitempty"`
        Labels         []string       `json:"labels,omitempty"`
        RetentionClass string         `json:"retention_class,omitempty"`
        CreatedAt      string         `json:"created_at"`
        Metadata       map[string]any `json:"metadata"`
}

func (s *Server) listArtifacts(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        runID := chi.URLParam(r, "id")
        artifacts, err := s.store.ListArtifacts(r.Context(), runID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">queryText := strings.ToLower(strings.TrimSpace(r.URL.Query().Get("query")))
        categoryFilter := strings.TrimSpace(r.URL.Query().Get("category"))
        contentTypeFilter := strings.TrimSpace(r.URL.Query().Get("content_type"))
        labelFilter := splitCSV(r.URL.Query().Get("label"))
        page := parsePositiveInt(r.URL.Query().Get("page"), 1)
        pageSize := parsePositiveInt(r.URL.Query().Get("page_size"), 50)
        if pageSize &gt; 200 </span><span class="cov0" title="0">{
                pageSize = 200
        }</span>

        <span class="cov8" title="1">filtered := make([]store.Artifact, 0, len(artifacts))
        for _, artifact := range artifacts </span><span class="cov8" title="1">{
                if categoryFilter != "" &amp;&amp; !strings.EqualFold(strings.TrimSpace(artifact.Category), categoryFilter) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if contentTypeFilter != "" &amp;&amp; !strings.EqualFold(strings.TrimSpace(artifact.ContentType), contentTypeFilter) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if len(labelFilter) &gt; 0 &amp;&amp; !containsAnyLabel(artifact.Labels, labelFilter) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if queryText != "" &amp;&amp; !artifactMatchesQuery(artifact, queryText) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">filtered = append(filtered, artifact)</span>
        }

        <span class="cov8" title="1">sort.Slice(filtered, func(i, j int) bool </span><span class="cov8" title="1">{
                left := parseTime(filtered[i].CreatedAt)
                right := parseTime(filtered[j].CreatedAt)
                return left.After(right)
        }</span>)

        <span class="cov8" title="1">total := len(filtered)
        start := (page - 1) * pageSize
        if start &gt; total </span><span class="cov0" title="0">{
                start = total
        }</span>
        <span class="cov8" title="1">end := start + pageSize
        if end &gt; total </span><span class="cov8" title="1">{
                end = total
        }</span>

        <span class="cov8" title="1">paged := filtered[start:end]
        response := listArtifactsResponse{
                Artifacts:  make([]artifactResponse, 0, len(paged)),
                Page:       page,
                PageSize:   pageSize,
                Total:      total,
                TotalPages: totalPages(total, pageSize),
        }
        for _, artifact := range paged </span><span class="cov8" title="1">{
                response.Artifacts = append(response.Artifacts, artifactResponse{
                        ID:             artifact.ID,
                        RunID:          artifact.RunID,
                        Type:           artifact.Type,
                        Category:       artifact.Category,
                        URI:            artifact.URI,
                        ContentType:    artifact.ContentType,
                        SizeBytes:      artifact.SizeBytes,
                        Checksum:       artifact.Checksum,
                        Labels:         append([]string{}, artifact.Labels...),
                        RetentionClass: artifact.RetentionClass,
                        CreatedAt:      artifact.CreatedAt,
                        Metadata:       artifact.Metadata,
                })
        }</span>
        <span class="cov8" title="1">writeJSON(w, response)</span>
}

func artifactMatchesQuery(artifact store.Artifact, queryText string) bool <span class="cov8" title="1">{
        if strings.Contains(strings.ToLower(artifact.URI), queryText) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov0" title="0">if strings.Contains(strings.ToLower(artifact.Type), queryText) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if strings.Contains(strings.ToLower(artifact.Category), queryText) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if strings.Contains(strings.ToLower(artifact.ContentType), queryText) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if strings.Contains(strings.ToLower(artifact.SearchableText), queryText) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">for _, label := range artifact.Labels </span><span class="cov0" title="0">{
                if strings.Contains(strings.ToLower(label), queryText) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func splitCSV(raw string) []string <span class="cov8" title="1">{
        raw = strings.TrimSpace(raw)
        if raw == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">parts := strings.Split(raw, ",")
        results := make([]string, 0, len(parts))
        for _, part := range parts </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(part)
                if trimmed == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">results = append(results, strings.ToLower(trimmed))</span>
        }
        <span class="cov8" title="1">return results</span>
}

func containsAnyLabel(labels []string, filters []string) bool <span class="cov8" title="1">{
        if len(labels) == 0 || len(filters) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for _, label := range labels </span><span class="cov8" title="1">{
                lower := strings.ToLower(strings.TrimSpace(label))
                for _, filter := range filters </span><span class="cov8" title="1">{
                        if lower == filter </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func parsePositiveInt(raw string, fallback int) int <span class="cov8" title="1">{
        value := strings.TrimSpace(raw)
        if value == "" </span><span class="cov8" title="1">{
                return fallback
        }</span>
        <span class="cov8" title="1">parsed, err := strconv.Atoi(value)
        if err != nil || parsed &lt;= 0 </span><span class="cov0" title="0">{
                return fallback
        }</span>
        <span class="cov8" title="1">return parsed</span>
}

func totalPages(total int, pageSize int) int <span class="cov8" title="1">{
        if total &lt;= 0 || pageSize &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return (total + pageSize - 1) / pageSize</span>
}

func parseTime(value string) time.Time <span class="cov8" title="1">{
        value = strings.TrimSpace(value)
        if value == "" </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>
        <span class="cov8" title="1">parsed, err := time.Parse(time.RFC3339Nano, value)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>
        <span class="cov8" title="1">return parsed.UTC()</span>
}

func (s *Server) upsertArtifactsFromEvent(ctx context.Context, event store.RunEvent) error <span class="cov8" title="1">{
        artifacts := extractArtifactsFromEvent(event)
        for _, artifact := range artifacts </span><span class="cov8" title="1">{
                if err := s.store.UpsertArtifact(ctx, artifact); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func extractArtifactsFromEvent(event store.RunEvent) []store.Artifact <span class="cov8" title="1">{
        if event.Payload == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">eventType := events.NormalizeType(event.Type)
        createdAt := event.Timestamp
        if createdAt == "" </span><span class="cov0" title="0">{
                createdAt = time.Now().UTC().Format(time.RFC3339Nano)
        }</span>
        <span class="cov8" title="1">results := []store.Artifact{}
        if eventType == "browser.snapshot" </span><span class="cov0" title="0">{
                if artifact := artifactFromPayload(event.RunID, createdAt, event.Payload); artifact != nil </span><span class="cov0" title="0">{
                        results = append(results, *artifact)
                }</span>
                <span class="cov0" title="0">return results</span>
        }
        <span class="cov8" title="1">if eventType == "document.created" </span><span class="cov0" title="0">{
                status := readString(event.Payload, "status")
                uri := readString(event.Payload, "uri")
                if status == "completed" &amp;&amp; uri != "" </span><span class="cov0" title="0">{
                        artifact := store.Artifact{
                                ID:          uuid.New().String(),
                                RunID:       event.RunID,
                                Type:        "file",
                                URI:         uri,
                                ContentType: contentTypeFromURI(uri),
                                CreatedAt:   createdAt,
                                Metadata:    map[string]any{},
                        }
                        if filename := readString(event.Payload, "filename"); filename != "" </span><span class="cov0" title="0">{
                                artifact.Metadata["filename"] = filename
                        }</span>
                        <span class="cov0" title="0">results = append(results, artifact)</span>
                }
                <span class="cov0" title="0">return results</span>
        }
        <span class="cov8" title="1">if eventType != "tool.completed" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">artifactsRaw, ok := event.Payload["artifacts"]
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">items, ok := artifactsRaw.([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">for _, item := range items </span><span class="cov8" title="1">{
                payload, ok := item.(map[string]any)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if artifact := artifactFromPayload(event.RunID, createdAt, payload); artifact != nil </span><span class="cov8" title="1">{
                        results = append(results, *artifact)
                }</span>
        }
        <span class="cov8" title="1">return results</span>
}

func artifactFromPayload(runID string, createdAt string, payload map[string]any) *store.Artifact <span class="cov8" title="1">{
        uri := readString(payload, "uri")
        if uri == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">artifactID := readString(payload, "artifact_id", "artifactId", "id")
        if artifactID == "" </span><span class="cov0" title="0">{
                artifactID = uuid.New().String()
        }</span>
        <span class="cov8" title="1">artifactType := readString(payload, "type")
        if artifactType == "" </span><span class="cov0" title="0">{
                artifactType = "file"
        }</span>
        <span class="cov8" title="1">metadata := map[string]any{}
        if rawMetadata, ok := payload["metadata"]; ok </span><span class="cov0" title="0">{
                if parsed, ok := rawMetadata.(map[string]any); ok </span><span class="cov0" title="0">{
                        metadata = parsed
                }</span>
        }
        <span class="cov8" title="1">return &amp;store.Artifact{
                ID:          artifactID,
                RunID:       runID,
                Type:        artifactType,
                URI:         uri,
                ContentType: readString(payload, "content_type", "contentType"),
                SizeBytes:   readInt64(payload, "size_bytes", "sizeBytes"),
                CreatedAt:   createdAt,
                Metadata:    metadata,
        }</span>
}

func readString(payload map[string]any, keys ...string) string <span class="cov8" title="1">{
        for _, key := range keys </span><span class="cov8" title="1">{
                if value, ok := payload[key]; ok </span><span class="cov8" title="1">{
                        if text, ok := value.(string); ok </span><span class="cov8" title="1">{
                                return strings.TrimSpace(text)
                        }</span>
                }
        }
        <span class="cov8" title="1">return ""</span>
}

func readInt64(payload map[string]any, keys ...string) int64 <span class="cov8" title="1">{
        for _, key := range keys </span><span class="cov8" title="1">{
                if value, ok := payload[key]; ok </span><span class="cov8" title="1">{
                        switch typed := value.(type) </span>{
                        case float64:<span class="cov8" title="1">
                                return int64(typed)</span>
                        case int64:<span class="cov0" title="0">
                                return typed</span>
                        case int:<span class="cov0" title="0">
                                return int64(typed)</span>
                        }
                }
        }
        <span class="cov0" title="0">return 0</span>
}

func contentTypeFromURI(uri string) string <span class="cov0" title="0">{
        ext := strings.ToLower(filepath.Ext(uri))
        switch ext </span>{
        case ".pdf":<span class="cov0" title="0">
                return "application/pdf"</span>
        case ".docx":<span class="cov0" title="0">
                return "application/vnd.openxmlformats-officedocument.wordprocessingml.document"</span>
        case ".pptx":<span class="cov0" title="0">
                return "application/vnd.openxmlformats-officedocument.presentationml.presentation"</span>
        case ".csv":<span class="cov0" title="0">
                return "text/csv"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package api

import (
        "context"
        "strings"
        "time"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/events"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store"
)

func (s *Server) upsertProcessesFromEvent(ctx context.Context, event store.RunEvent) error <span class="cov8" title="1">{
        processes := extractProcessesFromEvent(event)
        for _, process := range processes </span><span class="cov8" title="1">{
                if err := s.store.UpsertRunProcess(ctx, process); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func extractProcessesFromEvent(event store.RunEvent) []store.RunProcess <span class="cov8" title="1">{
        if event.Payload == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if events.NormalizeType(event.Type) != "tool.completed" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">toolName := strings.TrimSpace(readString(event.Payload, "tool_name"))
        if toolName == "" || !strings.HasPrefix(toolName, "process.") </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">outputRaw, ok := event.Payload["output"]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">outputMap, ok := outputRaw.(map[string]any)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if toolName == "process.list" </span><span class="cov0" title="0">{
                processesRaw, ok := outputMap["processes"].([]any)
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">results := make([]store.RunProcess, 0, len(processesRaw))
                for _, item := range processesRaw </span><span class="cov0" title="0">{
                        itemMap, ok := item.(map[string]any)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">process := processFromOutput(event.RunID, itemMap, event.Timestamp, toolName)
                        if process.ProcessID == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">results = append(results, process)</span>
                }
                <span class="cov0" title="0">return results</span>
        }

        <span class="cov8" title="1">process := processFromOutput(event.RunID, outputMap, event.Timestamp, toolName)
        if process.ProcessID == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return []store.RunProcess{process}</span>
}

func processFromOutput(runID string, output map[string]any, eventTimestamp string, toolName string) store.RunProcess <span class="cov8" title="1">{
        processID := strings.TrimSpace(readString(output, "process_id"))
        if processID == "" </span><span class="cov0" title="0">{
                return store.RunProcess{}
        }</span>
        <span class="cov8" title="1">process := store.RunProcess{
                RunID:       runID,
                ProcessID:   processID,
                Command:     strings.TrimSpace(readString(output, "command")),
                Cwd:         strings.TrimSpace(readString(output, "cwd")),
                Status:      strings.TrimSpace(readString(output, "status")),
                PID:         int(readInt64(output, "pid")),
                StartedAt:   strings.TrimSpace(readString(output, "started_at")),
                EndedAt:     strings.TrimSpace(readString(output, "ended_at")),
                Signal:      strings.TrimSpace(readString(output, "signal")),
                PreviewURLs: readStringArray(output, "preview_urls"),
                Args:        readStringArray(output, "args"),
                Metadata: map[string]any{
                        "tool_name": toolName,
                },
        }
        if process.StartedAt == "" </span><span class="cov0" title="0">{
                process.StartedAt = eventTimestampOrNow(eventTimestamp)
        }</span>
        <span class="cov8" title="1">if status := strings.ToLower(process.Status); status == "exited" || status == "stopped" || status == "failed" </span><span class="cov0" title="0">{
                if process.EndedAt == "" </span><span class="cov0" title="0">{
                        process.EndedAt = eventTimestampOrNow(eventTimestamp)
                }</span>
        }
        <span class="cov8" title="1">if exitCode, ok := readOptionalInt(output, "exit_code"); ok </span><span class="cov0" title="0">{
                process.ExitCode = &amp;exitCode
        }</span>
        <span class="cov8" title="1">if process.Status == "" </span><span class="cov0" title="0">{
                process.Status = "running"
        }</span>
        <span class="cov8" title="1">return process</span>
}

func readOptionalInt(payload map[string]any, key string) (int, bool) <span class="cov8" title="1">{
        if payload == nil </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        <span class="cov8" title="1">value, ok := payload[key]
        if !ok || value == nil </span><span class="cov8" title="1">{
                return 0, false
        }</span>
        <span class="cov0" title="0">switch typed := value.(type) </span>{
        case float64:<span class="cov0" title="0">
                return int(typed), true</span>
        case int:<span class="cov0" title="0">
                return typed, true</span>
        case int64:<span class="cov0" title="0">
                return int(typed), true</span>
        default:<span class="cov0" title="0">
                return 0, false</span>
        }
}

func readStringArray(payload map[string]any, key string) []string <span class="cov8" title="1">{
        if payload == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">raw, ok := payload[key]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">items, ok := raw.([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">values := make([]string, 0, len(items))
        for _, item := range items </span><span class="cov8" title="1">{
                text, ok := item.(string)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">trimmed := strings.TrimSpace(text)
                if trimmed == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">values = append(values, trimmed)</span>
        }
        <span class="cov8" title="1">return values</span>
}

func eventTimestampOrNow(value string) string <span class="cov0" title="0">{
        value = strings.TrimSpace(value)
        if value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return time.Now().UTC().Format(time.RFC3339Nano)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package api

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "strconv"
        "strings"

        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store"
)

type toolRunnerResponse struct {
        Status    string           `json:"status"`
        Output    map[string]any   `json:"output"`
        Artifacts []map[string]any `json:"artifacts"`
        Error     string           `json:"error,omitempty"`
}

type writeWorkspaceRequest struct {
        Path     string `json:"path"`
        Content  string `json:"content"`
        Encoding string `json:"encoding"`
}

type execWorkspaceRequest struct {
        Command   string            `json:"command"`
        Args      []string          `json:"args"`
        Cwd       string            `json:"cwd"`
        TimeoutMs int               `json:"timeout_ms"`
        Env       map[string]string `json:"env"`
}

type processStartRequest struct {
        Command string            `json:"command"`
        Args    []string          `json:"args"`
        Cwd     string            `json:"cwd"`
        Env     map[string]string `json:"env"`
}

type workspaceFileNode struct {
        Name     string              `json:"name"`
        Path     string              `json:"path"`
        Type     string              `json:"type"`
        Children []workspaceFileNode `json:"children,omitempty"`
}

type workspaceListEntry struct {
        Name string
        Path string
        Type string
}

type workspaceTreeState struct {
        nodes int
}

const (
        maxWorkspaceTreeDepth = 6
        maxWorkspaceTreeNodes = 2000
)

func (s *Server) listWorkspace(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        runID := chi.URLParam(r, "id")
        pathValue := r.URL.Query().Get("path")
        if pathValue == "" </span><span class="cov8" title="1">{
                pathValue = "."
        }</span>
        <span class="cov8" title="1">result, err := s.executeToolRunner(r.Context(), runID, "editor.list", map[string]any{"path": pathValue}, 0)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadGateway)
                return
        }</span>
        <span class="cov8" title="1">writeJSON(w, result)</span>
}

func (s *Server) listWorkspaceTree(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        runID := chi.URLParam(r, "id")
        root := strings.TrimSpace(r.URL.Query().Get("path"))
        if root == "" </span><span class="cov8" title="1">{
                root = "."
        }</span>
        <span class="cov8" title="1">state := &amp;workspaceTreeState{}
        files, err := s.buildWorkspaceTree(r.Context(), runID, root, 0, state)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadGateway)
                return
        }</span>
        <span class="cov8" title="1">writeJSON(w, map[string]any{"files": files})</span>
}

func (s *Server) readWorkspaceFile(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        runID := chi.URLParam(r, "id")
        pathValue := r.URL.Query().Get("path")
        if pathValue == "" </span><span class="cov0" title="0">{
                http.Error(w, "path required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">encoding := r.URL.Query().Get("encoding")
        input := map[string]any{"path": pathValue}
        if encoding != "" </span><span class="cov0" title="0">{
                input["encoding"] = encoding
        }</span>
        <span class="cov8" title="1">result, err := s.executeToolRunner(r.Context(), runID, "editor.read", input, 0)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadGateway)
                return
        }</span>
        <span class="cov8" title="1">writeJSON(w, result)</span>
}

func (s *Server) writeWorkspaceFile(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        runID := chi.URLParam(r, "id")
        var req writeWorkspaceRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid request", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(req.Path) == "" </span><span class="cov0" title="0">{
                http.Error(w, "path required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">input := map[string]any{"path": req.Path, "content": req.Content}
        if req.Encoding != "" </span><span class="cov0" title="0">{
                input["encoding"] = req.Encoding
        }</span>
        <span class="cov8" title="1">result, err := s.executeToolRunner(r.Context(), runID, "editor.write", input, 0)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadGateway)
                return
        }</span>
        <span class="cov8" title="1">writeJSON(w, result)</span>
}

func (s *Server) deleteWorkspaceFile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        runID := chi.URLParam(r, "id")
        pathValue := r.URL.Query().Get("path")
        if pathValue == "" </span><span class="cov0" title="0">{
                http.Error(w, "path required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">recursive := false
        if value := r.URL.Query().Get("recursive"); value != "" </span><span class="cov0" title="0">{
                parsed, err := strconv.ParseBool(value)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "recursive must be boolean", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">recursive = parsed</span>
        }
        <span class="cov0" title="0">input := map[string]any{"path": pathValue, "recursive": recursive}
        result, err := s.executeToolRunner(r.Context(), runID, "editor.delete", input, 0)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadGateway)
                return
        }</span>
        <span class="cov0" title="0">writeJSON(w, result)</span>
}

func (s *Server) statWorkspaceFile(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        runID := chi.URLParam(r, "id")
        pathValue := r.URL.Query().Get("path")
        if pathValue == "" </span><span class="cov0" title="0">{
                http.Error(w, "path required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">result, err := s.executeToolRunner(r.Context(), runID, "editor.stat", map[string]any{"path": pathValue}, 0)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadGateway)
                return
        }</span>
        <span class="cov0" title="0">writeJSON(w, result)</span>
}

func (s *Server) execWorkspaceProcess(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        runID := chi.URLParam(r, "id")
        var req execWorkspaceRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid request", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(req.Command) == "" </span><span class="cov0" title="0">{
                http.Error(w, "command required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">command := strings.TrimSpace(req.Command)
        args := req.Args
        if len(args) == 0 &amp;&amp; strings.Contains(command, " ") </span><span class="cov0" title="0">{
                fields := strings.Fields(command)
                if len(fields) &gt; 0 </span><span class="cov0" title="0">{
                        command = fields[0]
                        if len(fields) &gt; 1 </span><span class="cov0" title="0">{
                                args = fields[1:]
                        }</span>
                }
        }
        <span class="cov8" title="1">input := map[string]any{"command": command, "args": args}
        if req.Cwd != "" </span><span class="cov0" title="0">{
                input["cwd"] = req.Cwd
        }</span>
        <span class="cov8" title="1">if req.Env != nil </span><span class="cov0" title="0">{
                input["env"] = req.Env
        }</span>
        <span class="cov8" title="1">result, err := s.executeToolRunner(r.Context(), runID, "process.exec", input, req.TimeoutMs)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadGateway)
                return
        }</span>
        <span class="cov8" title="1">writeJSON(w, result)</span>
}

func (s *Server) listWorkspaceProcesses(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        runID := chi.URLParam(r, "id")
        result, err := s.executeToolRunner(r.Context(), runID, "process.list", map[string]any{}, 0)
        if err != nil </span><span class="cov8" title="1">{
                processes, storeErr := s.store.ListRunProcesses(r.Context(), runID)
                if storeErr != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadGateway)
                        return
                }</span>
                <span class="cov8" title="1">serialized := make([]map[string]any, 0, len(processes))
                for _, process := range processes </span><span class="cov8" title="1">{
                        serialized = append(serialized, runProcessToOutput(process, false, 0))
                }</span>
                <span class="cov8" title="1">writeJSON(w, &amp;toolRunnerResponse{
                        Status: "completed",
                        Output: map[string]any{"processes": serialized},
                })
                return</span>
        }
        <span class="cov0" title="0">writeJSON(w, result)</span>
}

func (s *Server) startWorkspaceProcess(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        runID := chi.URLParam(r, "id")
        var req processStartRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "invalid request", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(req.Command) == "" </span><span class="cov0" title="0">{
                http.Error(w, "command required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">input := map[string]any{
                "command": req.Command,
                "args":    req.Args,
        }
        if strings.TrimSpace(req.Cwd) != "" </span><span class="cov0" title="0">{
                input["cwd"] = req.Cwd
        }</span>
        <span class="cov8" title="1">if req.Env != nil </span><span class="cov0" title="0">{
                input["env"] = req.Env
        }</span>
        <span class="cov8" title="1">result, err := s.executeToolRunner(r.Context(), runID, "process.start", input, 0)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadGateway)
                return
        }</span>
        <span class="cov8" title="1">writeJSON(w, result)</span>
}

func (s *Server) getWorkspaceProcess(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        runID := chi.URLParam(r, "id")
        processID := chi.URLParam(r, "pid")
        if strings.TrimSpace(processID) == "" </span><span class="cov0" title="0">{
                http.Error(w, "process id required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">result, err := s.executeToolRunner(r.Context(), runID, "process.status", map[string]any{"process_id": processID}, 0)
        if err != nil </span><span class="cov8" title="1">{
                process, storeErr := s.store.GetRunProcess(r.Context(), runID, processID)
                if storeErr != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadGateway)
                        return
                }</span>
                <span class="cov8" title="1">if process == nil </span><span class="cov0" title="0">{
                        http.Error(w, "process not found", http.StatusNotFound)
                        return
                }</span>
                <span class="cov8" title="1">writeJSON(w, &amp;toolRunnerResponse{
                        Status: "completed",
                        Output: runProcessToOutput(*process, false, 0),
                })
                return</span>
        }
        <span class="cov8" title="1">writeJSON(w, result)</span>
}

func (s *Server) getWorkspaceProcessLogs(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        runID := chi.URLParam(r, "id")
        processID := chi.URLParam(r, "pid")
        if strings.TrimSpace(processID) == "" </span><span class="cov0" title="0">{
                http.Error(w, "process id required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">tail := 200
        if raw := strings.TrimSpace(r.URL.Query().Get("tail")); raw != "" </span><span class="cov8" title="1">{
                parsed, err := strconv.Atoi(raw)
                if err != nil || parsed &lt;= 0 </span><span class="cov0" title="0">{
                        http.Error(w, "tail must be a positive integer", http.StatusBadRequest)
                        return
                }</span>
                <span class="cov8" title="1">tail = parsed</span>
        }
        <span class="cov8" title="1">result, err := s.executeToolRunner(r.Context(), runID, "process.logs", map[string]any{"process_id": processID, "tail": tail}, 0)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadGateway)
                return
        }</span>
        <span class="cov8" title="1">writeJSON(w, result)</span>
}

func (s *Server) stopWorkspaceProcess(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        runID := chi.URLParam(r, "id")
        processID := chi.URLParam(r, "pid")
        if strings.TrimSpace(processID) == "" </span><span class="cov0" title="0">{
                http.Error(w, "process id required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">result, err := s.executeToolRunner(r.Context(), runID, "process.stop", map[string]any{"process_id": processID}, 0)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadGateway)
                return
        }</span>
        <span class="cov8" title="1">writeJSON(w, result)</span>
}

func (s *Server) stopAllWorkspaceProcesses(ctx context.Context, runID string) (int, error) <span class="cov8" title="1">{
        baseURL := strings.TrimRight(s.cfg.ToolRunnerURL, "/")
        if baseURL == "" </span><span class="cov8" title="1">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">payload, _ := json.Marshal(map[string]any{"force": true})
        req, err := http.NewRequestWithContext(ctx, http.MethodPost, baseURL+"/runs/"+runID+"/processes/cleanup", bytes.NewReader(payload))
        if err == nil </span><span class="cov0" title="0">{
                req.Header.Set("Content-Type", "application/json")
                resp, callErr := s.httpClient.Do(req)
                if callErr == nil </span><span class="cov0" title="0">{
                        defer resp.Body.Close()
                        if resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 300 </span><span class="cov0" title="0">{
                                var toolResp toolRunnerResponse
                                if decodeErr := json.NewDecoder(resp.Body).Decode(&amp;toolResp); decodeErr == nil &amp;&amp; toolResp.Output != nil </span><span class="cov0" title="0">{
                                        if stopped, ok := readOptionalInt(toolResp.Output, "stopped"); ok </span><span class="cov0" title="0">{
                                                return stopped, nil
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">processes := make([]store.RunProcess, 0)
        result, err := s.executeToolRunner(ctx, runID, "process.list", map[string]any{}, 0)
        if err != nil || result == nil || result.Output == nil </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">if raw, ok := result.Output["processes"].([]any); ok </span><span class="cov0" title="0">{
                for _, item := range raw </span><span class="cov0" title="0">{
                        processMap, ok := item.(map[string]any)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">processID, _ := processMap["process_id"].(string)
                        status, _ := processMap["status"].(string)
                        if strings.TrimSpace(processID) == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">processes = append(processes, store.RunProcess{
                                RunID:     runID,
                                ProcessID: strings.TrimSpace(processID),
                                Status:    strings.TrimSpace(status),
                        })</span>
                }
        }

        <span class="cov0" title="0">stoppedCount := 0
        var firstErr error
        for _, process := range processes </span><span class="cov0" title="0">{
                if !isRunnableProcessState(process.Status) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">_, stopErr := s.executeToolRunner(ctx, runID, "process.stop", map[string]any{
                        "process_id": process.ProcessID,
                        "force":      true,
                }, 0)
                if stopErr != nil </span><span class="cov0" title="0">{
                        if strings.Contains(strings.ToLower(stopErr.Error()), "process not found") </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if firstErr == nil </span><span class="cov0" title="0">{
                                firstErr = stopErr
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">stoppedCount++</span>
        }
        <span class="cov0" title="0">return stoppedCount, firstErr</span>
}

func isRunnableProcessState(status string) bool <span class="cov0" title="0">{
        switch strings.ToLower(strings.TrimSpace(status)) </span>{
        case "", "running", "starting":<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func (s *Server) executeToolRunner(ctx context.Context, runID string, toolName string, input map[string]any, timeoutMs int) (*toolRunnerResponse, error) <span class="cov8" title="1">{
        baseURL := strings.TrimRight(s.cfg.ToolRunnerURL, "/")
        if baseURL == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tool runner url not configured")
        }</span>
        <span class="cov8" title="1">invocationID := uuid.New().String()
        payload := map[string]any{
                "contract_version": "tool_contract_v2",
                "run_id":           runID,
                "invocation_id":    invocationID,
                "idempotency_key":  invocationID,
                "tool_name":        toolName,
                "input":            input,
                "policy_context": map[string]any{
                        "profile": "default",
                },
        }
        if timeoutMs &gt; 0 </span><span class="cov0" title="0">{
                payload["timeout_ms"] = timeoutMs
        }</span>
        <span class="cov8" title="1">body, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodPost, baseURL+"/tools/execute", bytes.NewReader(body))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                responseBody, _ := io.ReadAll(resp.Body)
                message := strings.TrimSpace(string(responseBody))
                if message == "" </span><span class="cov0" title="0">{
                        message = fmt.Sprintf("tool runner returned status %d", resp.StatusCode)
                }</span>
                <span class="cov0" title="0">return nil, errors.New(message)</span>
        }
        <span class="cov8" title="1">var result toolRunnerResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;result, nil</span>
}

func (s *Server) buildWorkspaceTree(ctx context.Context, runID string, pathValue string, depth int, state *workspaceTreeState) ([]workspaceFileNode, error) <span class="cov8" title="1">{
        if depth &gt; maxWorkspaceTreeDepth </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">if state != nil &amp;&amp; state.nodes &gt;= maxWorkspaceTreeNodes </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">input := map[string]any{"path": pathValue}
        result, err := s.executeToolRunner(ctx, runID, "editor.list", input, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">entries, err := parseWorkspaceEntries(result.Output)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">files := make([]workspaceFileNode, 0, len(entries))
        for _, entry := range entries </span><span class="cov8" title="1">{
                if state != nil &amp;&amp; state.nodes &gt;= maxWorkspaceTreeNodes </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">node := workspaceFileNode{Name: entry.Name, Path: entry.Path, Type: entry.Type}
                if entry.Type == "directory" </span><span class="cov0" title="0">{
                        children, err := s.buildWorkspaceTree(ctx, runID, entry.Path, depth+1, state)
                        if err == nil &amp;&amp; len(children) &gt; 0 </span><span class="cov0" title="0">{
                                node.Children = children
                        }</span>
                }
                <span class="cov8" title="1">files = append(files, node)
                if state != nil </span><span class="cov8" title="1">{
                        state.nodes++
                }</span>
        }
        <span class="cov8" title="1">return files, nil</span>
}

func parseWorkspaceEntries(output map[string]any) ([]workspaceListEntry, error) <span class="cov8" title="1">{
        entriesValue, ok := output["entries"]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list output missing entries")
        }</span>
        <span class="cov8" title="1">entriesSlice, ok := entriesValue.([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list output entries invalid")
        }</span>
        <span class="cov8" title="1">entries := make([]workspaceListEntry, 0, len(entriesSlice))
        for _, item := range entriesSlice </span><span class="cov8" title="1">{
                entryMap, ok := item.(map[string]any)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">name, _ := entryMap["name"].(string)
                pathValue, _ := entryMap["path"].(string)
                entryType, _ := entryMap["type"].(string)
                if name == "" || pathValue == "" || entryType == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">entries = append(entries, workspaceListEntry{Name: name, Path: pathValue, Type: entryType})</span>
        }
        <span class="cov8" title="1">return entries, nil</span>
}

func writeJSON(w http.ResponseWriter, value any) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(value)
}</span>

func runProcessToOutput(process store.RunProcess, includeLogs bool, tail int) map[string]any <span class="cov8" title="1">{
        output := map[string]any{
                "process_id":   process.ProcessID,
                "run_id":       process.RunID,
                "command":      process.Command,
                "args":         process.Args,
                "cwd":          process.Cwd,
                "status":       process.Status,
                "pid":          process.PID,
                "started_at":   process.StartedAt,
                "ended_at":     process.EndedAt,
                "signal":       process.Signal,
                "preview_urls": process.PreviewURLs,
        }
        if process.ExitCode != nil </span><span class="cov0" title="0">{
                output["exit_code"] = *process.ExitCode
        }</span> else<span class="cov8" title="1"> {
                output["exit_code"] = nil
        }</span>
        <span class="cov8" title="1">if includeLogs </span><span class="cov0" title="0">{
                output["logs"] = []any{}
                output["logs_tail"] = tail
        }</span>
        <span class="cov8" title="1">return output</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package api

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
        "github.com/google/uuid"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/config"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/events"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store"
)

type Server struct {
        store        store.Store
        broker       Broker
        workflows    WorkflowService
        cfg          config.Config
        httpClient   *http.Client
        automationMu sync.Mutex
}

type Broker interface {
        Publish(event events.RunEvent)
        Subscribe(ctx context.Context, runID string) &lt;-chan events.RunEvent
}

type WorkflowService interface {
        StartRun(ctx context.Context, runID string) error
        SignalMessage(ctx context.Context, runID string, message string) error
        ResumeRun(ctx context.Context, runID string, message string) error
        CancelRun(ctx context.Context, runID string) error
}

func NewServer(store store.Store, broker Broker, workflows WorkflowService, cfg config.Config) *Server <span class="cov8" title="1">{
        return &amp;Server{
                store:      store,
                broker:     broker,
                workflows:  workflows,
                cfg:        cfg,
                httpClient: &amp;http.Client{Timeout: 30 * time.Second},
        }
}</span>

func (s *Server) Router() http.Handler <span class="cov8" title="1">{
        r := chi.NewRouter()
        r.Use(quietRequestLogger)
        r.Use(middleware.Recoverer)
        r.Use(corsMiddleware)

        r.Post("/runs", s.createRun)
        r.Get("/runs", s.listRuns)
        r.Get("/runs/{id}", s.getRun)
        r.Delete("/runs/{id}", s.deleteRun)
        r.Post("/runs/{id}/messages", s.addMessage)
        r.Post("/runs/{id}/resume", s.resumeRun)
        r.Post("/runs/{id}/cancel", s.cancelRun)
        r.Post("/runs/{id}/events", s.ingestEvent)
        r.Get("/runs/{id}/events", s.streamEvents)
        r.Post("/automation/execute", s.executeAutomationRun)
        r.Get("/automations", s.listAutomations)
        r.Post("/automations", s.createAutomation)
        r.Put("/automations/{id}", s.updateAutomation)
        r.Delete("/automations/{id}", s.deleteAutomation)
        r.Get("/automations/{id}/inbox", s.getAutomationInbox)
        r.Post("/automations/{id}/inbox/{entryID}/read", s.markAutomationInboxRead)
        r.Post("/automations/{id}/inbox/read-all", s.markAutomationInboxReadAll)
        r.Post("/automations/process-due", s.processDueAutomations)
        r.Post("/automations/{id}/run", s.runAutomationNow)
        r.Get("/runs/{id}/steps", s.listRunSteps)
        r.Get("/runs/{id}/workspace", s.listWorkspace)
        r.Get("/runs/{id}/workspace/tree", s.listWorkspaceTree)
        r.Get("/runs/{id}/workspace/file", s.readWorkspaceFile)
        r.Put("/runs/{id}/workspace/file", s.writeWorkspaceFile)
        r.Delete("/runs/{id}/workspace/file", s.deleteWorkspaceFile)
        r.Get("/runs/{id}/workspace/stat", s.statWorkspaceFile)
        r.Post("/runs/{id}/processes/exec", s.execWorkspaceProcess)
        r.Get("/runs/{id}/processes", s.listWorkspaceProcesses)
        r.Post("/runs/{id}/processes/start", s.startWorkspaceProcess)
        r.Get("/runs/{id}/processes/{pid}", s.getWorkspaceProcess)
        r.Get("/runs/{id}/processes/{pid}/logs", s.getWorkspaceProcessLogs)
        r.Post("/runs/{id}/processes/{pid}/stop", s.stopWorkspaceProcess)
        r.Get("/runs/{id}/artifacts", s.listArtifacts)
        r.Get("/settings/llm", s.getLLMSettings)
        r.Post("/settings/llm", s.updateLLMSettings)
        r.Post("/settings/llm/test", s.testLLMSettings)
        r.Post("/settings/llm/models", s.listLLMModels)
        r.Get("/settings/memory", s.getMemorySettings)
        r.Post("/settings/memory", s.updateMemorySettings)
        r.Get("/settings/personality", s.getPersonalitySettings)
        r.Post("/settings/personality", s.updatePersonalitySettings)
        r.Get("/skills", s.listSkills)
        r.Post("/skills", s.createSkill)
        r.Put("/skills/{id}", s.updateSkill)
        r.Delete("/skills/{id}", s.deleteSkill)
        r.Get("/skills/{id}/files", s.listSkillFiles)
        r.Post("/skills/{id}/files", s.upsertSkillFiles)
        r.Delete("/skills/{id}/files", s.deleteSkillFiles)
        r.Get("/context", s.listContextNodes)
        r.Post("/context/folders", s.createContextFolder)
        r.Post("/context/files", s.uploadContextFile)
        r.Get("/context/files/{id}", s.getContextFile)
        r.Delete("/context/{id}", s.deleteContextNode)
        r.Get("/health", s.health)
        r.Get("/ready", s.ready)

        return r
}</span>

func quietRequestLogger(next http.Handler) http.Handler <span class="cov8" title="1">{
        logged := middleware.Logger(next)
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                if shouldSuppressRequestLog(r.Method, r.URL.Path) </span><span class="cov8" title="1">{
                        next.ServeHTTP(w, r)
                        return
                }</span>
                <span class="cov8" title="1">logged.ServeHTTP(w, r)</span>
        })
}

func shouldSuppressRequestLog(method string, path string) bool <span class="cov8" title="1">{
        cleanPath := strings.TrimSpace(path)
        if method == http.MethodPost &amp;&amp; strings.HasSuffix(cleanPath, "/events") </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if method == http.MethodGet &amp;&amp; strings.HasSuffix(cleanPath, "/events") </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if method == http.MethodGet &amp;&amp; (cleanPath == "/runs" || strings.HasPrefix(cleanPath, "/settings/")) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if method == http.MethodOptions &amp;&amp; (strings.HasSuffix(cleanPath, "/messages") || strings.HasPrefix(cleanPath, "/settings/")) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (s *Server) health(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(map[string]string{"status": "ok"})
}</span>

type subsystemStatus struct {
        Status string `json:"status"`
        Error  string `json:"error,omitempty"`
}

type readinessResponse struct {
        Status     string                     `json:"status"`
        Subsystems map[string]subsystemStatus `json:"subsystems"`
}

func (s *Server) ready(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)
        defer cancel()

        subsystems := map[string]subsystemStatus{}
        overall := http.StatusOK

        if _, err := s.store.ListRuns(ctx); err != nil </span><span class="cov8" title="1">{
                subsystems["store"] = subsystemStatus{Status: "error", Error: err.Error()}
                overall = http.StatusServiceUnavailable
        }</span> else<span class="cov8" title="1"> {
                subsystems["store"] = subsystemStatus{Status: "ok"}
        }</span>

        <span class="cov8" title="1">toolRunnerURL := strings.TrimSpace(s.cfg.ToolRunnerURL)
        if toolRunnerURL == "" </span><span class="cov8" title="1">{
                subsystems["tool_runner"] = subsystemStatus{Status: "skipped"}
        }</span> else<span class="cov8" title="1"> {
                baseURL := strings.TrimRight(toolRunnerURL, "/")
                resp, err := s.probeHTTP(ctx, baseURL+"/ready")
                if err == nil &amp;&amp; resp != nil &amp;&amp; resp.StatusCode == http.StatusNotFound </span><span class="cov8" title="1">{
                        resp, err = s.probeHTTP(ctx, baseURL+"/health")
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        subsystems["tool_runner"] = subsystemStatus{Status: "error", Error: err.Error()}
                        overall = http.StatusServiceUnavailable
                }</span> else<span class="cov8" title="1"> if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                        subsystems["tool_runner"] = subsystemStatus{Status: "error", Error: fmt.Sprintf("health status %d", resp.StatusCode)}
                        overall = http.StatusServiceUnavailable
                }</span> else<span class="cov8" title="1"> {
                        subsystems["tool_runner"] = subsystemStatus{Status: "ok"}
                }</span>
        }

        <span class="cov8" title="1">status := "ok"
        if overall != http.StatusOK </span><span class="cov8" title="1">{
                status = "degraded"
        }</span>
        <span class="cov8" title="1">writeJSONStatus(w, readinessResponse{Status: status, Subsystems: subsystems}, overall)</span>
}

func writeJSONStatus(w http.ResponseWriter, value any, statusCode int) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        _ = json.NewEncoder(w).Encode(value)
}</span>

func (s *Server) probeHTTP(ctx context.Context, url string) (*http.Response, error) <span class="cov8" title="1">{
        req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return resp, resp.Body.Close()</span>
}

type createRunRequest struct {
        Goal          string         `json:"goal"`
        PolicyProfile string         `json:"policy_profile"`
        ModelRoute    string         `json:"model_route"`
        Tags          []string       `json:"tags"`
        Metadata      map[string]any `json:"metadata"`
}

func (s *Server) createRun(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if !s.ensureLLMConfigured(w, r.Context()) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">req := createRunRequest{}
        if r.Body != nil </span><span class="cov8" title="1">{
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                        http.Error(w, "invalid request", http.StatusBadRequest)
                        return
                }</span>
        }
        <span class="cov8" title="1">id := uuid.New().String()
        now := time.Now().UTC().Format(time.RFC3339Nano)

        policyProfile := strings.TrimSpace(req.PolicyProfile)
        if policyProfile == "" </span><span class="cov8" title="1">{
                policyProfile = "default"
        }</span>
        <span class="cov8" title="1">run := store.Run{
                ID:            id,
                Status:        "running",
                Phase:         "planning",
                PolicyProfile: policyProfile,
                ModelRoute:    strings.TrimSpace(req.ModelRoute),
                Tags:          req.Tags,
                CreatedAt:     now,
                UpdatedAt:     now,
        }
        if err := s.store.CreateRun(r.Context(), run); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">if s.workflows != nil </span><span class="cov8" title="1">{
                _ = s.workflows.StartRun(r.Context(), id)
        }</span>

        <span class="cov8" title="1">seq, _ := s.store.NextSeq(r.Context(), id)
        event := store.RunEvent{
                RunID:     id,
                Seq:       seq,
                Type:      "run.started",
                Timestamp: now,
                Source:    "control_plane",
                TraceID:   uuid.New().String(),
                Payload: map[string]any{
                        "status":         "running",
                        "phase":          "planning",
                        "policy_profile": policyProfile,
                        "model_route":    run.ModelRoute,
                        "tags":           run.Tags,
                },
        }
        _ = s.store.AppendEvent(r.Context(), event)
        _ = s.upsertArtifactsFromEvent(r.Context(), event)
        _ = s.upsertProcessesFromEvent(r.Context(), event)
        s.broker.Publish(toEvent(event))

        goal := strings.TrimSpace(req.Goal)
        if goal != "" </span><span class="cov0" title="0">{
                msg := store.Message{
                        ID:        uuid.New().String(),
                        RunID:     id,
                        Role:      "user",
                        Content:   goal,
                        Sequence:  time.Now().UnixNano(),
                        CreatedAt: now,
                        Metadata:  req.Metadata,
                }
                if err := s.store.AddMessage(r.Context(), msg); err == nil </span><span class="cov0" title="0">{
                        s.indexMessageMemory(r.Context(), msg)
                        if s.workflows != nil </span><span class="cov0" title="0">{
                                _ = s.workflows.SignalMessage(r.Context(), id, goal)
                        }</span>
                        <span class="cov0" title="0">seq, _ = s.store.NextSeq(r.Context(), id)
                        messageEvent := store.RunEvent{
                                RunID:     id,
                                Seq:       seq,
                                Type:      "message.added",
                                Timestamp: now,
                                Source:    "control_plane",
                                TraceID:   uuid.New().String(),
                                Payload: map[string]any{
                                        "message_id": msg.ID,
                                        "role":       msg.Role,
                                        "content":    msg.Content,
                                },
                        }
                        _ = s.store.AppendEvent(r.Context(), messageEvent)
                        s.broker.Publish(toEvent(messageEvent))</span>
                }
        }

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(map[string]any{
                "run_id":         id,
                "status":         "running",
                "phase":          "planning",
                "policy_profile": policyProfile,
        })</span>
}

type addMessageRequest struct {
        Role     string         `json:"role"`
        Content  string         `json:"content"`
        Metadata map[string]any `json:"metadata"`
}

func (s *Server) addMessage(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        runID := chi.URLParam(r, "id")
        var req addMessageRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "invalid request", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if req.Role == "" </span><span class="cov8" title="1">{
                req.Role = "user"
        }</span>
        <span class="cov8" title="1">if req.Role == "user" </span><span class="cov8" title="1">{
                if !s.ensureLLMConfigured(w, r.Context()) </span><span class="cov8" title="1">{
                        return
                }</span>
        }

        <span class="cov8" title="1">msg := store.Message{
                ID:        uuid.New().String(),
                RunID:     runID,
                Role:      req.Role,
                Content:   req.Content,
                Sequence:  time.Now().UnixNano(),
                CreatedAt: time.Now().UTC().Format(time.RFC3339Nano),
                Metadata:  req.Metadata,
        }
        if err := s.store.AddMessage(r.Context(), msg); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">s.indexMessageMemory(r.Context(), msg)

        if s.workflows != nil &amp;&amp; req.Role == "user" </span><span class="cov8" title="1">{
                _ = s.workflows.SignalMessage(r.Context(), runID, req.Content)
        }</span>

        <span class="cov8" title="1">seq, _ := s.store.NextSeq(r.Context(), runID)
        event := store.RunEvent{
                RunID:     runID,
                Seq:       seq,
                Type:      "message.added",
                Timestamp: time.Now().UTC().Format(time.RFC3339Nano),
                Source:    "control_plane",
                TraceID:   uuid.New().String(),
                Payload:   map[string]any{"message_id": msg.ID, "role": msg.Role, "content": msg.Content},
        }
        _ = s.store.AppendEvent(r.Context(), event)
        _ = s.upsertArtifactsFromEvent(r.Context(), event)
        _ = s.upsertProcessesFromEvent(r.Context(), event)
        s.broker.Publish(toEvent(event))

        w.WriteHeader(http.StatusAccepted)</span>
}

func (s *Server) cancelRun(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        runID := chi.URLParam(r, "id")
        cleanupCtx, cleanupCancel := context.WithTimeout(r.Context(), 10*time.Second)
        stoppedCount, cleanupErr := s.stopAllWorkspaceProcesses(cleanupCtx, runID)
        cleanupCancel()
        if s.workflows != nil </span><span class="cov8" title="1">{
                _ = s.workflows.CancelRun(r.Context(), runID)
        }</span>
        <span class="cov8" title="1">if stoppedCount &gt; 0 || cleanupErr != nil </span><span class="cov0" title="0">{
                seq, _ := s.store.NextSeq(r.Context(), runID)
                cleanupPayload := map[string]any{
                        "stopped_processes": stoppedCount,
                        "phase":             "cleanup",
                }
                if cleanupErr != nil </span><span class="cov0" title="0">{
                        cleanupPayload["error"] = cleanupErr.Error()
                }</span>
                <span class="cov0" title="0">cleanupEvent := store.RunEvent{
                        RunID:     runID,
                        Seq:       seq,
                        Type:      "run.cleanup.processes",
                        Timestamp: time.Now().UTC().Format(time.RFC3339Nano),
                        Source:    "control_plane",
                        TraceID:   uuid.New().String(),
                        Payload:   cleanupPayload,
                }
                _ = s.store.AppendEvent(r.Context(), cleanupEvent)
                _ = s.upsertArtifactsFromEvent(r.Context(), cleanupEvent)
                _ = s.upsertProcessesFromEvent(r.Context(), cleanupEvent)
                s.broker.Publish(toEvent(cleanupEvent))</span>
        }
        <span class="cov8" title="1">seq, _ := s.store.NextSeq(r.Context(), runID)
        event := store.RunEvent{
                RunID:     runID,
                Seq:       seq,
                Type:      "run.cancelled",
                Timestamp: time.Now().UTC().Format(time.RFC3339Nano),
                Source:    "control_plane",
                TraceID:   uuid.New().String(),
                Payload:   map[string]any{"reason": "user_requested"},
        }
        _ = s.store.AppendEvent(r.Context(), event)
        _ = s.upsertArtifactsFromEvent(r.Context(), event)
        _ = s.upsertProcessesFromEvent(r.Context(), event)
        s.broker.Publish(toEvent(event))
        w.WriteHeader(http.StatusAccepted)</span>
}

type ingestEventRequest struct {
        Type      string         `json:"type"`
        Source    string         `json:"source"`
        Timestamp string         `json:"timestamp"`
        TraceID   string         `json:"trace_id"`
        Payload   map[string]any `json:"payload"`
}

func (s *Server) ingestEvent(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        runID := chi.URLParam(r, "id")
        var req ingestEventRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "invalid request", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if req.Type == "" </span><span class="cov8" title="1">{
                http.Error(w, "event type required", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if strings.Contains(req.Type, "_") </span><span class="cov0" title="0">{
                http.Error(w, "event type must use dot notation", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">timestamp := req.Timestamp
        if timestamp == "" </span><span class="cov8" title="1">{
                timestamp = time.Now().UTC().Format(time.RFC3339Nano)
        }</span>

        <span class="cov8" title="1">seq, _ := s.store.NextSeq(r.Context(), runID)
        event := store.RunEvent{
                RunID:     runID,
                Seq:       seq,
                Type:      events.NormalizeType(req.Type),
                Timestamp: timestamp,
                Source:    req.Source,
                TraceID:   strings.TrimSpace(req.TraceID),
                Payload:   req.Payload,
        }
        if event.TraceID == "" </span><span class="cov8" title="1">{
                event.TraceID = uuid.New().String()
        }</span>
        <span class="cov8" title="1">if isTransientPayload(req.Payload) </span><span class="cov8" title="1">{
                s.broker.Publish(toEvent(event))
                w.WriteHeader(http.StatusAccepted)
                return
        }</span>
        <span class="cov8" title="1">_ = s.store.AppendEvent(r.Context(), event)
        _ = s.upsertArtifactsFromEvent(r.Context(), event)
        _ = s.upsertProcessesFromEvent(r.Context(), event)
        s.broker.Publish(toEvent(event))

        w.WriteHeader(http.StatusAccepted)</span>
}

func isTransientPayload(payload map[string]any) bool <span class="cov8" title="1">{
        if payload == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if value, ok := payload["transient"]; ok </span><span class="cov8" title="1">{
                if flag, ok := value.(bool); ok </span><span class="cov8" title="1">{
                        return flag
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (s *Server) streamEvents(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        runID := chi.URLParam(r, "id")
        w.Header().Set("Content-Type", "text/event-stream")
        w.Header().Set("Cache-Control", "no-cache")
        w.Header().Set("Connection", "keep-alive")

        flusher, ok := w.(http.Flusher)
        if !ok </span><span class="cov8" title="1">{
                http.Error(w, "streaming unsupported", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">ctx := r.Context()
        afterSeq := parseAfterSeq(runID, r)
        stored, err := s.store.ListEvents(ctx, runID, afterSeq)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">for _, event := range stored </span><span class="cov8" title="1">{
                sendSSE(w, toEvent(event))
                flusher.Flush()
        }</span>

        <span class="cov8" title="1">eventsChan := s.broker.Subscribe(ctx, runID)
        heartbeat := time.NewTicker(15 * time.Second)
        defer heartbeat.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case event, ok := &lt;-eventsChan:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov8" title="1">sendSSE(w, event)
                        flusher.Flush()</span>
                case &lt;-heartbeat.C:<span class="cov0" title="0">
                        fmt.Fprint(w, ": keep-alive\n\n")
                        flusher.Flush()</span>
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                }
        }
}

func sendSSE(w http.ResponseWriter, event events.RunEvent) <span class="cov8" title="1">{
        payload, _ := json.Marshal(event)
        fmt.Fprintf(w, "id: %s:%d\n", event.RunID, event.Seq)
        fmt.Fprint(w, "event: run_event\n")
        fmt.Fprintf(w, "data: %s\n\n", payload)
}</span>

func toEvent(event store.RunEvent) events.RunEvent <span class="cov8" title="1">{
        return events.RunEvent{
                RunID:   event.RunID,
                Seq:     event.Seq,
                Type:    events.NormalizeType(event.Type),
                Ts:      event.Timestamp,
                Source:  event.Source,
                TraceID: event.TraceID,
                Payload: event.Payload,
        }
}</span>

func parseAfterSeq(runID string, r *http.Request) int64 <span class="cov8" title="1">{
        afterParam := strings.TrimSpace(r.URL.Query().Get("after_seq"))
        if afterParam != "" </span><span class="cov8" title="1">{
                if parsed, err := strconv.ParseInt(afterParam, 10, 64); err == nil </span><span class="cov8" title="1">{
                        return parsed
                }</span>
        }
        <span class="cov8" title="1">lastEventID := r.Header.Get("Last-Event-ID")
        if lastEventID == "" </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">parts := strings.Split(lastEventID, ":")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if parts[0] != runID </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">seq, err := strconv.ParseInt(parts[1], 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return seq</span>
}

func (s *Server) ensureLLMConfigured(w http.ResponseWriter, ctx context.Context) bool <span class="cov8" title="1">{
        settings, err := s.store.GetLLMSettings(ctx)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return false
        }</span>
        <span class="cov8" title="1">if settings == nil </span><span class="cov8" title="1">{
                http.Error(w, "LLM setup required", http.StatusPreconditionFailed)
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func corsMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Last-Event-ID")
                if r.Method == http.MethodOptions </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusNoContent)
                        return
                }</span>
                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}

func (s *Server) Start(ctx context.Context, addr string) error <span class="cov8" title="1">{
        server := &amp;http.Server{
                Addr:    addr,
                Handler: s.Router(),
        }
        go func() </span><span class="cov8" title="1">{
                &lt;-ctx.Done()
                _ = server.Shutdown(context.Background())
        }</span>()
        <span class="cov8" title="1">return server.ListenAndServe()</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package api

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "net/http"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/skills"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store"
)

var skillNamePattern = regexp.MustCompile(`^[A-Za-z0-9._-]+$`)

type skillRequest struct {
        Name        string             `json:"name"`
        Description string             `json:"description"`
        Files       []skillFilePayload `json:"files"`
}

type skillFilePayload struct {
        Path        string `json:"path"`
        ContentBase string `json:"content_base64"`
        ContentType string `json:"content_type"`
}

type skillFilesUpdate struct {
        Files       []skillFilePayload `json:"files"`
        DeletePaths []string           `json:"delete_paths"`
}

type skillResponse struct {
        ID          string `json:"id"`
        Name        string `json:"name"`
        Description string `json:"description"`
        CreatedAt   string `json:"created_at"`
        UpdatedAt   string `json:"updated_at"`
}

type skillFileResponse struct {
        Path        string `json:"path"`
        ContentBase string `json:"content_base64"`
        ContentType string `json:"content_type"`
        SizeBytes   int64  `json:"size_bytes"`
        UpdatedAt   string `json:"updated_at"`
}

func (s *Server) listSkills(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        skillsList, err := s.store.ListSkills(r.Context())
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">response := make([]skillResponse, 0, len(skillsList))
        for _, skill := range skillsList </span><span class="cov8" title="1">{
                response = append(response, skillResponse{
                        ID:          skill.ID,
                        Name:        skill.Name,
                        Description: skill.Description,
                        CreatedAt:   skill.CreatedAt,
                        UpdatedAt:   skill.UpdatedAt,
                })
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(map[string]any{"skills": response})</span>
}

func (s *Server) createSkill(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req skillRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "invalid request", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">name := strings.TrimSpace(req.Name)
        if err := validateSkillName(name); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">files := ensureSkillMarkdown(req.Files)
        fileEntries, err := decodeSkillFiles(files)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">now := time.Now().UTC().Format(time.RFC3339Nano)
        skill := store.Skill{
                ID:          uuid.New().String(),
                Name:        name,
                Description: strings.TrimSpace(req.Description),
                CreatedAt:   now,
                UpdatedAt:   now,
        }
        if err := s.store.CreateSkill(r.Context(), skill); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if err := upsertSkillFiles(r.Context(), s.store, skill.ID, fileEntries, now); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if err := materializeSkillFiles(r.Context(), s.store, skill.ID, skill.Name, ""); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(skillResponse{
                ID:          skill.ID,
                Name:        skill.Name,
                Description: skill.Description,
                CreatedAt:   skill.CreatedAt,
                UpdatedAt:   skill.UpdatedAt,
        })</span>
}

func (s *Server) updateSkill(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        skillID := chi.URLParam(r, "id")
        existing, err := s.store.GetSkill(r.Context(), skillID)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if existing == nil </span><span class="cov8" title="1">{
                http.Error(w, "skill not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">var req skillRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "invalid request", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">name := strings.TrimSpace(req.Name)
        if name == "" </span><span class="cov8" title="1">{
                name = existing.Name
        }</span>
        <span class="cov8" title="1">if err := validateSkillName(name); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">now := time.Now().UTC().Format(time.RFC3339Nano)
        updated := store.Skill{
                ID:          existing.ID,
                Name:        name,
                Description: firstNonEmpty(strings.TrimSpace(req.Description), existing.Description),
                CreatedAt:   existing.CreatedAt,
                UpdatedAt:   now,
        }
        if err := s.store.UpdateSkill(r.Context(), updated); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if err := materializeSkillFiles(r.Context(), s.store, updated.ID, updated.Name, existing.Name); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(skillResponse{
                ID:          updated.ID,
                Name:        updated.Name,
                Description: updated.Description,
                CreatedAt:   updated.CreatedAt,
                UpdatedAt:   updated.UpdatedAt,
        })</span>
}

func (s *Server) deleteSkill(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        skillID := chi.URLParam(r, "id")
        existing, err := s.store.GetSkill(r.Context(), skillID)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if existing == nil </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusNoContent)
                return
        }</span>
        <span class="cov8" title="1">if err := s.store.DeleteSkill(r.Context(), skillID); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if root, err := skills.RootDir(); err == nil </span><span class="cov8" title="1">{
                _ = os.RemoveAll(filepath.Join(root, existing.Name))
        }</span>
        <span class="cov8" title="1">w.WriteHeader(http.StatusNoContent)</span>
}

func (s *Server) listSkillFiles(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        skillID := chi.URLParam(r, "id")
        files, err := s.store.ListSkillFiles(r.Context(), skillID)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">response := make([]skillFileResponse, 0, len(files))
        for _, file := range files </span><span class="cov8" title="1">{
                response = append(response, skillFileResponse{
                        Path:        file.Path,
                        ContentBase: base64.StdEncoding.EncodeToString(file.Content),
                        ContentType: file.ContentType,
                        SizeBytes:   file.SizeBytes,
                        UpdatedAt:   file.UpdatedAt,
                })
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        _ = json.NewEncoder(w).Encode(map[string]any{"files": response})</span>
}

func (s *Server) upsertSkillFiles(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        skillID := chi.URLParam(r, "id")
        skill, err := s.store.GetSkill(r.Context(), skillID)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if skill == nil </span><span class="cov8" title="1">{
                http.Error(w, "skill not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">var req skillFilesUpdate
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "invalid request", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">files := ensureSkillMarkdown(req.Files)
        fileEntries, err := decodeSkillFiles(files)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">now := time.Now().UTC().Format(time.RFC3339Nano)
        if err := upsertSkillFiles(r.Context(), s.store, skill.ID, fileEntries, now); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">for _, path := range req.DeletePaths </span><span class="cov8" title="1">{
                if err := s.store.DeleteSkillFile(r.Context(), skill.ID, path); err != nil </span><span class="cov8" title="1">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
        }
        <span class="cov8" title="1">if err := materializeSkillFiles(r.Context(), s.store, skill.ID, skill.Name, ""); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusNoContent)</span>
}

func (s *Server) deleteSkillFiles(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        skillID := chi.URLParam(r, "id")
        skill, err := s.store.GetSkill(r.Context(), skillID)
        if err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">if skill == nil </span><span class="cov8" title="1">{
                http.Error(w, "skill not found", http.StatusNotFound)
                return
        }</span>
        <span class="cov8" title="1">var req skillFilesUpdate
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                http.Error(w, "invalid request", http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">for _, path := range req.DeletePaths </span><span class="cov8" title="1">{
                if err := s.store.DeleteSkillFile(r.Context(), skill.ID, path); err != nil </span><span class="cov8" title="1">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
        }
        <span class="cov8" title="1">if err := materializeSkillFiles(r.Context(), s.store, skill.ID, skill.Name, ""); err != nil </span><span class="cov8" title="1">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.WriteHeader(http.StatusNoContent)</span>
}

func validateSkillName(name string) error <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("name is required")
        }</span>
        <span class="cov8" title="1">if strings.Contains(name, string(os.PathSeparator)) </span><span class="cov8" title="1">{
                return fmt.Errorf("name must not include path separators")
        }</span>
        <span class="cov8" title="1">if !skillNamePattern.MatchString(name) </span><span class="cov8" title="1">{
                return fmt.Errorf("name must use letters, numbers, dots, underscores, or hyphens")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func ensureSkillMarkdown(files []skillFilePayload) []skillFilePayload <span class="cov8" title="1">{
        for _, file := range files </span><span class="cov8" title="1">{
                if strings.EqualFold(filepath.Base(file.Path), "SKILL.md") </span><span class="cov8" title="1">{
                        return files
                }</span>
        }
        <span class="cov8" title="1">return append(files, skillFilePayload{Path: "SKILL.md", ContentBase: base64.StdEncoding.EncodeToString([]byte("")), ContentType: "text/markdown"})</span>
}

func decodeSkillFiles(files []skillFilePayload) ([]store.SkillFile, error) <span class="cov8" title="1">{
        entries := make([]store.SkillFile, 0, len(files))
        for _, file := range files </span><span class="cov8" title="1">{
                path := strings.TrimSpace(file.Path)
                if path == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("file path required")
                }</span>
                <span class="cov8" title="1">if strings.HasPrefix(path, "/") || strings.Contains(path, "..") </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid file path")
                }</span>
                <span class="cov8" title="1">decoded, err := base64.StdEncoding.DecodeString(file.ContentBase)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid file content for %s", path)
                }</span>
                <span class="cov8" title="1">contentType := strings.TrimSpace(file.ContentType)
                if contentType == "" &amp;&amp; strings.EqualFold(filepath.Base(path), "SKILL.md") </span><span class="cov8" title="1">{
                        contentType = "text/markdown"
                }</span>
                <span class="cov8" title="1">entries = append(entries, store.SkillFile{
                        ID:          uuid.New().String(),
                        Path:        path,
                        Content:     decoded,
                        ContentType: contentType,
                        SizeBytes:   int64(len(decoded)),
                })</span>
        }
        <span class="cov8" title="1">return entries, nil</span>
}

func upsertSkillFiles(ctx context.Context, store store.Store, skillID string, files []store.SkillFile, now string) error <span class="cov8" title="1">{
        for _, file := range files </span><span class="cov8" title="1">{
                file.SkillID = skillID
                file.CreatedAt = now
                file.UpdatedAt = now
                if err := store.UpsertSkillFile(ctx, file); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func materializeSkillFiles(ctx context.Context, store store.Store, skillID string, skillName string, oldName string) error <span class="cov8" title="1">{
        root, err := skills.RootDir()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">files, err := store.ListSkillFiles(ctx, skillID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := skills.MaterializeSkill(root, skillName, files); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if oldName != "" &amp;&amp; oldName != skillName </span><span class="cov8" title="1">{
                _ = os.RemoveAll(filepath.Join(root, oldName))
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
)

type Config struct {
        ControlPlanePort      string
        ControlPlaneURL       string
        ToolRunnerURL         string
        PostgresURL           string
        TemporalAddress       string
        TemporalTaskQueue     string
        LLMMode               string
        LLMProvider           string
        LLMModel              string
        LLMBaseURL            string
        LLMFallbackProvider   string
        LLMFallbackModel      string
        LLMFallbackBaseURL    string
        OpenAIAPIKey          string
        OpenRouterAPIKey      string
        OpenCodeAPIKey        string
        DiscordWebhookURL     string
        CodexAuthPath         string
        CodexHome             string
        LLMSecretsKey         string
        MemoryMaxResults      int
        MemoryMaxEntryChars   int
        MemoryChunkChars      int
        MemoryChunkOverlap    int
        MemoryMaxChunks       int
        MemoryMinContentChars int
        MemoryMaxContentBytes int
}

func Load() Config <span class="cov8" title="1">{
        controlPlanePort := getEnv("CONTROL_PLANE_PORT", "8080")
        postgresURL := getEnv("POSTGRES_URL", "")
        if postgresURL == "" </span><span class="cov8" title="1">{
                postgresURL = buildPostgresURL()
        }</span>
        <span class="cov8" title="1">return Config{
                ControlPlanePort:      controlPlanePort,
                ControlPlaneURL:       getEnv("CONTROL_PLANE_URL", "http://localhost:"+controlPlanePort),
                ToolRunnerURL:         getEnv("TOOL_RUNNER_URL", "http://localhost:8081"),
                PostgresURL:           postgresURL,
                TemporalAddress:       getEnv("TEMPORAL_ADDRESS", "localhost:7233"),
                TemporalTaskQueue:     getEnv("TEMPORAL_TASK_QUEUE", "gavryn-runs"),
                LLMMode:               getEnv("LLM_MODE", "remote"),
                LLMProvider:           getEnv("LLM_PROVIDER", "codex"),
                LLMModel:              getEnv("LLM_MODEL", "gpt-5.2-codex"),
                LLMBaseURL:            getEnv("LLM_BASE_URL", ""),
                LLMFallbackProvider:   getEnv("LLM_FALLBACK_PROVIDER", ""),
                LLMFallbackModel:      getEnv("LLM_FALLBACK_MODEL", ""),
                LLMFallbackBaseURL:    getEnv("LLM_FALLBACK_BASE_URL", ""),
                OpenAIAPIKey:          getEnv("OPENAI_API_KEY", ""),
                OpenRouterAPIKey:      getEnv("OPENROUTER_API_KEY", ""),
                OpenCodeAPIKey:        getEnv("OPENCODE_API_KEY", ""),
                DiscordWebhookURL:     getEnv("DISCORD_WEBHOOK_URL", ""),
                CodexAuthPath:         getEnv("CODEX_AUTH_PATH", ""),
                CodexHome:             getEnv("CODEX_HOME", ""),
                LLMSecretsKey:         getEnv("LLM_SECRETS_KEY", ""),
                MemoryMaxResults:      getEnvInt("MEMORY_MAX_RESULTS", 5),
                MemoryMaxEntryChars:   getEnvInt("MEMORY_MAX_ENTRY_CHARS", 400),
                MemoryChunkChars:      getEnvInt("MEMORY_CHUNK_CHARS", 1200),
                MemoryChunkOverlap:    getEnvInt("MEMORY_CHUNK_OVERLAP", 200),
                MemoryMaxChunks:       getEnvInt("MEMORY_MAX_CHUNKS", 6),
                MemoryMinContentChars: getEnvInt("MEMORY_MIN_CONTENT_CHARS", 12),
                MemoryMaxContentBytes: getEnvInt("MEMORY_MAX_CONTENT_BYTES", 20000),
        }</span>
}

func getEnv(key, fallback string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return fallback</span>
}

func getEnvInt(key string, fallback int) int <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                parsed, err := strconv.Atoi(value)
                if err == nil </span><span class="cov8" title="1">{
                        return parsed
                }</span>
        }
        <span class="cov8" title="1">return fallback</span>
}

func buildPostgresURL() string <span class="cov8" title="1">{
        user := getEnv("POSTGRES_USER", "gavryn")
        password := getEnv("POSTGRES_PASSWORD", "gavryn")
        host := getEnv("POSTGRES_HOST", "localhost")
        port := getEnv("POSTGRES_PORT", "5432")
        database := getEnv("POSTGRES_DB", "gavryn")
        return fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable", user, password, host, port, database)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package events

import (
        "context"
        "strings"
        "sync"
)

type RunEvent struct {
        RunID   string         `json:"run_id"`
        Seq     int64          `json:"seq"`
        Type    string         `json:"type"`
        Ts      string         `json:"ts"`
        Source  string         `json:"source"`
        TraceID string         `json:"trace_id,omitempty"`
        Payload map[string]any `json:"payload"`
}

type Broker struct {
        mu          sync.RWMutex
        subscribers map[string]map[chan RunEvent]struct{}
}

func NormalizeType(eventType string) string <span class="cov0" title="0">{
        return strings.TrimSpace(strings.ToLower(eventType))
}</span>

func NewBroker() *Broker <span class="cov8" title="1">{
        return &amp;Broker{
                subscribers: map[string]map[chan RunEvent]struct{}{},
        }
}</span>

func (b *Broker) Subscribe(ctx context.Context, runID string) &lt;-chan RunEvent <span class="cov8" title="1">{
        ch := make(chan RunEvent, 16)

        b.mu.Lock()
        if b.subscribers[runID] == nil </span><span class="cov8" title="1">{
                b.subscribers[runID] = map[chan RunEvent]struct{}{}
        }</span>
        <span class="cov8" title="1">b.subscribers[runID][ch] = struct{}{}
        b.mu.Unlock()

        go func() </span><span class="cov8" title="1">{
                &lt;-ctx.Done()
                b.mu.Lock()
                if b.subscribers[runID] != nil </span><span class="cov8" title="1">{
                        delete(b.subscribers[runID], ch)
                        if len(b.subscribers[runID]) == 0 </span><span class="cov8" title="1">{
                                delete(b.subscribers, runID)
                        }</span>
                }
                <span class="cov8" title="1">b.mu.Unlock()
                close(ch)</span>
        }()

        <span class="cov8" title="1">return ch</span>
}

func (b *Broker) Publish(event RunEvent) <span class="cov8" title="1">{
        b.mu.RLock()
        subscribers := b.subscribers[event.RunID]
        chans := make([]chan RunEvent, 0, len(subscribers))
        for ch := range subscribers </span><span class="cov8" title="1">{
                chans = append(chans, ch)
        }</span>
        <span class="cov8" title="1">b.mu.RUnlock()

        for _, ch := range chans </span><span class="cov8" title="1">{
                select </span>{
                case ch &lt;- event:<span class="cov8" title="1"></span>
                default:<span class="cov8" title="1"></span>
                }
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package llm

import (
        "bytes"
        "context"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/google/uuid"
)

const (
        defaultCodexBaseURL = "https://chatgpt.com/backend-api/codex"
        codexTokenURL       = "https://auth.openai.com/oauth/token"
        codexClientID       = "app_EMoamEEZ73f0CkXaXp7hrann"
)

type codexProvider struct {
        model      string
        baseURL    string
        authPath   string
        sessionID  string
        client     *http.Client
        cachedAuth *codexAuth
        tokenURL   string // Configurable for testing
}

type codexAuth struct {
        AccessToken  string
        RefreshToken string
        AccountID    string
        IDToken      string
}

type codexAuthFile struct {
        Tokens struct {
                AccessToken  string `json:"access_token"`
                RefreshToken string `json:"refresh_token"`
                AccountID    string `json:"account_id"`
                IDToken      string `json:"id_token"`
        } `json:"tokens"`
}

type codexRefreshResponse struct {
        AccessToken  string `json:"access_token"`
        RefreshToken string `json:"refresh_token"`
        IDToken      string `json:"id_token"`
}

func NewCodexProvider(cfg Config) (Provider, error) <span class="cov8" title="1">{
        model := cfg.Model
        if model == "" </span><span class="cov8" title="1">{
                model = "gpt-5.2-codex"
        }</span>
        <span class="cov8" title="1">baseURL := cfg.BaseURL
        if baseURL == "" </span><span class="cov8" title="1">{
                baseURL = defaultCodexBaseURL
        }</span>
        <span class="cov8" title="1">return &amp;codexProvider{
                model:     model,
                baseURL:   strings.TrimRight(baseURL, "/"),
                authPath:  resolveCodexAuthPath(cfg),
                sessionID: uuid.NewString(),
                client:    &amp;http.Client{Timeout: 35 * time.Second},
                tokenURL:  codexTokenURL,
        }, nil</span>
}

func resolveCodexAuthPath(cfg Config) string <span class="cov8" title="1">{
        if cfg.CodexAuthPath != "" </span><span class="cov8" title="1">{
                return expandHome(cfg.CodexAuthPath)
        }</span>
        <span class="cov8" title="1">codexHome := cfg.CodexHome
        if codexHome == "" </span><span class="cov8" title="1">{
                codexHome = "~/.codex"
        }</span>
        <span class="cov8" title="1">return filepath.Join(expandHome(codexHome), "auth.json")</span>
}

func expandHome(path string) string <span class="cov8" title="1">{
        if strings.HasPrefix(path, "~") </span><span class="cov8" title="1">{
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return path
                }</span>
                <span class="cov8" title="1">return filepath.Join(home, strings.TrimPrefix(path, "~"))</span>
        }
        <span class="cov8" title="1">return path</span>
}

func (p *codexProvider) Generate(ctx context.Context, messages []Message) (string, error) <span class="cov8" title="1">{
        auth, err := p.loadAuth()
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">text, err := p.request(ctx, auth, messages)
        if err == nil </span><span class="cov8" title="1">{
                return text, nil
        }</span>
        <span class="cov8" title="1">if !isUnauthorized(err) || auth.RefreshToken == "" </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">refreshed, refreshErr := p.refreshTokens(ctx, auth.RefreshToken)
        if refreshErr != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">if refreshed.AccessToken != "" </span><span class="cov8" title="1">{
                auth.AccessToken = refreshed.AccessToken
        }</span>
        <span class="cov8" title="1">if refreshed.RefreshToken != "" </span><span class="cov8" title="1">{
                auth.RefreshToken = refreshed.RefreshToken
        }</span>
        <span class="cov8" title="1">if refreshed.IDToken != "" </span><span class="cov8" title="1">{
                auth.IDToken = refreshed.IDToken
                if auth.AccountID == "" </span><span class="cov0" title="0">{
                        auth.AccountID = extractAccountIDFromJWT(auth.IDToken)
                }</span>
        }
        <span class="cov8" title="1">_ = p.persistAuth(auth)
        return p.request(ctx, auth, messages)</span>
}

func (p *codexProvider) request(ctx context.Context, auth *codexAuth, messages []Message) (string, error) <span class="cov8" title="1">{
        inputs, instructions := formatCodexInput(messages)
        payload := map[string]any{
                "model":        p.model,
                "input":        inputs,
                "instructions": instructions,
                "store":        false,
                "stream":       false,
        }
        body, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodPost, p.baseURL+"/responses", bytes.NewReader(body))
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">req.Header.Set("Authorization", "Bearer "+auth.AccessToken)
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("originator", "gavryn")
        req.Header.Set("session_id", p.sessionID)
        req.Header.Set("User-Agent", "gavryn")
        if auth.AccountID != "" </span><span class="cov8" title="1">{
                req.Header.Set("ChatGPT-Account-Id", auth.AccountID)
        }</span>

        <span class="cov8" title="1">resp, err := p.client.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode == http.StatusUnauthorized </span><span class="cov8" title="1">{
                return "", errUnauthorized
        }</span>
        <span class="cov8" title="1">if resp.StatusCode &gt;= 400 </span><span class="cov8" title="1">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                return "", fmt.Errorf("codex request failed: %s %s", resp.Status, string(bodyBytes))
        }</span>

        <span class="cov8" title="1">var payloadResp map[string]any
        if err := json.NewDecoder(resp.Body).Decode(&amp;payloadResp); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">text := extractCodexOutput(payloadResp)
        if strings.TrimSpace(text) == "" </span><span class="cov8" title="1">{
                return "", errors.New("codex response was empty")
        }</span>
        <span class="cov8" title="1">return text, nil</span>
}

func (p *codexProvider) loadAuth() (*codexAuth, error) <span class="cov8" title="1">{
        if p.cachedAuth != nil </span><span class="cov8" title="1">{
                return p.cachedAuth, nil
        }</span>
        <span class="cov8" title="1">data, err := os.ReadFile(p.authPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("codex auth.json not found at %s; run `codex login`", p.authPath)
        }</span>
        <span class="cov8" title="1">var authFile codexAuthFile
        if err := json.Unmarshal(data, &amp;authFile); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if authFile.Tokens.AccessToken == "" </span><span class="cov8" title="1">{
                return nil, errors.New("codex auth.json missing access_token; run `codex login`")
        }</span>
        <span class="cov8" title="1">auth := &amp;codexAuth{
                AccessToken:  authFile.Tokens.AccessToken,
                RefreshToken: authFile.Tokens.RefreshToken,
                AccountID:    authFile.Tokens.AccountID,
                IDToken:      authFile.Tokens.IDToken,
        }
        if auth.AccountID == "" &amp;&amp; auth.IDToken != "" </span><span class="cov8" title="1">{
                auth.AccountID = extractAccountIDFromJWT(auth.IDToken)
        }</span>
        <span class="cov8" title="1">p.cachedAuth = auth
        return auth, nil</span>
}

func (p *codexProvider) persistAuth(auth *codexAuth) error <span class="cov8" title="1">{
        authFile := codexAuthFile{}
        authFile.Tokens.AccessToken = auth.AccessToken
        authFile.Tokens.RefreshToken = auth.RefreshToken
        authFile.Tokens.AccountID = auth.AccountID
        authFile.Tokens.IDToken = auth.IDToken
        data, err := json.MarshalIndent(authFile, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return os.WriteFile(p.authPath, data, 0o600)</span>
}

func (p *codexProvider) refreshTokens(ctx context.Context, refreshToken string) (*codexRefreshResponse, error) <span class="cov8" title="1">{
        values := url.Values{}
        values.Set("grant_type", "refresh_token")
        values.Set("refresh_token", refreshToken)
        values.Set("client_id", codexClientID)
        tokenURL := p.tokenURL
        if tokenURL == "" </span><span class="cov8" title="1">{
                tokenURL = codexTokenURL
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodPost, tokenURL, strings.NewReader(values.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
        resp, err := p.client.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode &gt;= 400 </span><span class="cov8" title="1">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("codex token refresh failed: %s %s", resp.Status, string(bodyBytes))
        }</span>
        <span class="cov8" title="1">var refreshed codexRefreshResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;refreshed); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;refreshed, nil</span>
}

func formatCodexInput(messages []Message) ([]map[string]any, string) <span class="cov8" title="1">{
        inputs := []map[string]any{}
        instructions := ""
        for _, msg := range messages </span><span class="cov8" title="1">{
                role := msg.Role
                content := msg.Content
                if role == "" || content == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if role == "system" &amp;&amp; instructions == "" </span><span class="cov8" title="1">{
                        instructions = content
                        continue</span>
                }
                <span class="cov8" title="1">if role == "assistant" </span><span class="cov8" title="1">{
                        inputs = append(inputs, map[string]any{
                                "type":    "message",
                                "role":    "assistant",
                                "content": []map[string]any{{"type": "output_text", "text": content}},
                        })
                        continue</span>
                }
                <span class="cov8" title="1">inputs = append(inputs, map[string]any{
                        "role":    role,
                        "content": []map[string]any{{"type": "input_text", "text": content}},
                })</span>
        }
        <span class="cov8" title="1">return inputs, instructions</span>
}

func extractCodexOutput(payload map[string]any) string <span class="cov8" title="1">{
        if outputText, ok := payload["output_text"].(string); ok &amp;&amp; outputText != "" </span><span class="cov8" title="1">{
                return outputText
        }</span>
        <span class="cov8" title="1">output, ok := payload["output"].([]any)
        if !ok </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">parts := []string{}
        for _, item := range output </span><span class="cov8" title="1">{
                itemMap, ok := item.(map[string]any)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if itemMap["type"] != "message" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">content, ok := itemMap["content"].([]any)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">for _, part := range content </span><span class="cov8" title="1">{
                        partMap, ok := part.(map[string]any)
                        if !ok </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">partType, _ := partMap["type"].(string)
                        if partType != "output_text" &amp;&amp; partType != "text" </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">text, _ := partMap["text"].(string)
                        if text != "" </span><span class="cov8" title="1">{
                                parts = append(parts, text)
                        }</span>
                }
        }
        <span class="cov8" title="1">return strings.Join(parts, "")</span>
}

func extractAccountIDFromJWT(token string) string <span class="cov8" title="1">{
        if token == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">parts := strings.Split(token, ".")
        if len(parts) &lt; 2 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">decoded, err := base64.RawURLEncoding.DecodeString(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">var claims map[string]any
        if err := json.Unmarshal(decoded, &amp;claims); err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if authClaims, ok := claims["https://api.openai.com/auth"].(map[string]any); ok </span><span class="cov8" title="1">{
                if account, ok := authClaims["chatgpt_account_id"].(string); ok </span><span class="cov8" title="1">{
                        return account
                }</span>
        }
        <span class="cov8" title="1">if account, ok := claims["chatgpt_account_id"].(string); ok </span><span class="cov8" title="1">{
                return account
        }</span>
        <span class="cov8" title="1">return ""</span>
}

var errUnauthorized = errors.New("unauthorized")

func isUnauthorized(err error) bool <span class="cov8" title="1">{
        return errors.Is(err, errUnauthorized)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package llm

import "fmt"

type ErrUnsupportedProvider struct {
        Provider string
}

func (e ErrUnsupportedProvider) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("unsupported LLM provider: %s", e.Provider)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package llm

import (
        "context"
)

type Message struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

type Provider interface {
        Generate(ctx context.Context, messages []Message) (string, error)
}

type Config struct {
        Mode             string
        Provider         string
        Model            string
        BaseURL          string
        FallbackProvider string
        FallbackModel    string
        FallbackBaseURL  string
        OpenAIAPIKey     string
        OpenRouterAPIKey string
        OpenCodeAPIKey   string
        CodexAuthPath    string
        CodexHome        string
}

func NewProvider(cfg Config) (Provider, error) <span class="cov8" title="1">{
        if cfg.Mode == "local" </span><span class="cov8" title="1">{
                return LocalProvider{}, nil
        }</span>

        <span class="cov8" title="1">switch cfg.Provider </span>{
        case "codex":<span class="cov8" title="1">
                return NewCodexProvider(cfg)</span>
        case "openai":<span class="cov8" title="1">
                return NewOpenAIProvider(OpenAIConfig{
                        APIKey:  cfg.OpenAIAPIKey,
                        Model:   cfg.Model,
                        BaseURL: cfg.BaseURL,
                }), nil</span>
        case "opencode-zen":<span class="cov8" title="1">
                return NewOpenCodeProvider(OpenCodeConfig{
                        APIKey:  cfg.OpenCodeAPIKey,
                        Model:   cfg.Model,
                        BaseURL: cfg.BaseURL,
                }), nil</span>
        case "openrouter":<span class="cov8" title="1">
                return NewOpenAIProvider(OpenAIConfig{
                        APIKey:  cfg.OpenRouterAPIKey,
                        Model:   cfg.Model,
                        BaseURL: defaultIfEmpty(cfg.BaseURL, "https://openrouter.ai/api/v1"),
                }), nil</span>
        case "kimi-for-coding":<span class="cov0" title="0">
                return NewOpenAIProvider(OpenAIConfig{
                        APIKey:  cfg.OpenAIAPIKey,
                        Model:   cfg.Model,
                        BaseURL: defaultIfEmpty(cfg.BaseURL, "https://api.kimi.com/coding/v1"),
                }), nil</span>
        case "moonshot-ai":<span class="cov0" title="0">
                return NewOpenAIProvider(OpenAIConfig{
                        APIKey:  cfg.OpenAIAPIKey,
                        Model:   cfg.Model,
                        BaseURL: defaultIfEmpty(cfg.BaseURL, "https://api.moonshot.ai/v1"),
                }), nil</span>
        default:<span class="cov8" title="1">
                return nil, ErrUnsupportedProvider{Provider: cfg.Provider}</span>
        }
}

func defaultIfEmpty(value string, fallback string) string <span class="cov8" title="1">{
        if value == "" </span><span class="cov8" title="1">{
                return fallback
        }</span>
        <span class="cov8" title="1">return value</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package llm

import (
        "context"
        "errors"
)

type LocalProvider struct{}

func (LocalProvider) Generate(ctx context.Context, messages []Message) (string, error) <span class="cov8" title="1">{
        return "", errors.New("local LLM mode is not implemented")
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package llm

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strings"
        "time"
)

type OpenAIConfig struct {
        APIKey  string
        Model   string
        BaseURL string
}

type OpenAIProvider struct {
        apiKey  string
        model   string
        baseURL string
        client  *http.Client
}

func NewOpenAIProvider(cfg OpenAIConfig) *OpenAIProvider <span class="cov8" title="1">{
        baseURL := cfg.BaseURL
        if baseURL == "" </span><span class="cov8" title="1">{
                baseURL = "https://api.openai.com/v1"
        }</span>
        <span class="cov8" title="1">return &amp;OpenAIProvider{
                apiKey:  cfg.APIKey,
                model:   cfg.Model,
                baseURL: strings.TrimRight(baseURL, "/"),
                client:  &amp;http.Client{Timeout: 35 * time.Second},
        }</span>
}

func (p *OpenAIProvider) Generate(ctx context.Context, messages []Message) (string, error) <span class="cov8" title="1">{
        if p.apiKey == "" </span><span class="cov8" title="1">{
                return "", errors.New("missing API key for remote provider")
        }</span>
        <span class="cov8" title="1">if p.model == "" </span><span class="cov8" title="1">{
                return "", errors.New("missing model for remote provider")
        }</span>
        <span class="cov8" title="1">payload := map[string]any{
                "model":    p.model,
                "messages": messages,
        }
        body, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodPost, p.baseURL+"/chat/completions", bytes.NewReader(body))
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">req.Header.Set("Authorization", "Bearer "+p.apiKey)
        req.Header.Set("Content-Type", "application/json")

        resp, err := p.client.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode &gt;= 400 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("LLM request failed: %s", resp.Status)
        }</span>

        <span class="cov8" title="1">var parsed struct {
                Choices []struct {
                        Message struct {
                                Content string `json:"content"`
                        } `json:"message"`
                } `json:"choices"`
        }
        if err := json.NewDecoder(resp.Body).Decode(&amp;parsed); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">if len(parsed.Choices) == 0 </span><span class="cov8" title="1">{
                return "", errors.New("LLM response had no choices")
        }</span>
        <span class="cov8" title="1">content := strings.TrimSpace(parsed.Choices[0].Message.Content)
        if content == "" </span><span class="cov8" title="1">{
                return "", errors.New("LLM response was empty")
        }</span>
        <span class="cov8" title="1">return content, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package llm

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "strings"
        "time"
)

const (
        defaultOpenCodeBaseURL = "https://opencode.ai/zen/v1"
        defaultOpenCodeTimeout = 35 * time.Second
)

type OpenCodeConfig struct {
        APIKey  string
        Model   string
        BaseURL string
}

type OpenCodeProvider struct {
        apiKey  string
        model   string
        baseURL string
        client  *http.Client
}

func NewOpenCodeProvider(cfg OpenCodeConfig) *OpenCodeProvider <span class="cov8" title="1">{
        return &amp;OpenCodeProvider{
                apiKey:  cfg.APIKey,
                model:   cfg.Model,
                baseURL: normalizeOpenCodeBaseURL(cfg.BaseURL),
                client:  &amp;http.Client{Timeout: defaultOpenCodeTimeout},
        }
}</span>

func (p *OpenCodeProvider) Generate(ctx context.Context, messages []Message) (string, error) <span class="cov0" title="0">{
        if p.apiKey == "" </span><span class="cov0" title="0">{
                return "", errors.New("missing API key for remote provider")
        }</span>
        <span class="cov0" title="0">if p.model == "" </span><span class="cov0" title="0">{
                return "", errors.New("missing model for remote provider")
        }</span>

        <span class="cov0" title="0">model := normalizeOpenCodeModel(p.model)
        endpoint := p.baseURL + "/chat/completions"
        debugEnabled := openCodeDebugEnabled()
        if debugEnabled </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] OpenCode: model=%q, endpoint=%q, baseURL=%q\n", model, endpoint, p.baseURL)
        }</span>

        // OpenCode Zen uses a unified chat completions endpoint for all models
        // The model parameter routes to the correct backend
        <span class="cov0" title="0">payload := map[string]any{
                "model":    model,
                "messages": messages,
        }

        body, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if debugEnabled </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] OpenCode request: %s\n", string(body))
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, http.MethodPost, endpoint, bytes.NewReader(body))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+p.apiKey)
        req.Header.Set("Content-Type", "application/json")

        resp, err := p.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("opencode request timed out after %s while awaiting response headers", p.client.Timeout)
                }</span>
                <span class="cov0" title="0">return "", err</span>
        }
        <span class="cov0" title="0">defer resp.Body.Close()

        bodyBytes, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("opencode request failed: %s %s", resp.Status, strings.TrimSpace(string(bodyBytes)))
        }</span>

        <span class="cov0" title="0">content, err := parseOpenCodeChatResponse(bodyBytes)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">content = strings.TrimSpace(content)
        if content == "" </span><span class="cov0" title="0">{
                return "", errors.New("LLM response was empty")
        }</span>

        <span class="cov0" title="0">return content, nil</span>
}

func normalizeOpenCodeBaseURL(baseURL string) string <span class="cov8" title="1">{
        trimmed := strings.TrimRight(baseURL, "/")
        if trimmed == "" </span><span class="cov0" title="0">{
                return defaultOpenCodeBaseURL
        }</span>
        // Normalize old/incorrect URLs to the correct one
        <span class="cov8" title="1">if trimmed == "https://api.opencode.ai/v1" </span><span class="cov0" title="0">{
                return defaultOpenCodeBaseURL
        }</span>
        <span class="cov8" title="1">return trimmed</span>
}

func normalizeOpenCodeModel(model string) string <span class="cov0" title="0">{
        // Strip the opencode/ prefix if present
        if strings.HasPrefix(model, "opencode/") </span><span class="cov0" title="0">{
                return strings.TrimPrefix(model, "opencode/")
        }</span>
        <span class="cov0" title="0">return model</span>
}

func parseOpenCodeChatResponse(body []byte) (string, error) <span class="cov0" title="0">{
        var payload map[string]any
        if err := json.Unmarshal(body, &amp;payload); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Try OpenAI-style choices format
        <span class="cov0" title="0">if choices, ok := payload["choices"].([]any); ok &amp;&amp; len(choices) &gt; 0 </span><span class="cov0" title="0">{
                choice, ok := choices[0].(map[string]any)
                if ok </span><span class="cov0" title="0">{
                        if message, ok := choice["message"].(map[string]any); ok </span><span class="cov0" title="0">{
                                if content, ok := message["content"].(string); ok &amp;&amp; content != "" </span><span class="cov0" title="0">{
                                        return content, nil
                                }</span>
                        }
                        <span class="cov0" title="0">if content, ok := choice["text"].(string); ok &amp;&amp; content != "" </span><span class="cov0" title="0">{
                                return content, nil
                        }</span>
                }
        }

        // Try direct content field
        <span class="cov0" title="0">if content, ok := payload["content"].(string); ok &amp;&amp; content != "" </span><span class="cov0" title="0">{
                return content, nil
        }</span>

        // Try output_text field
        <span class="cov0" title="0">if outputText, ok := payload["output_text"].(string); ok &amp;&amp; outputText != "" </span><span class="cov0" title="0">{
                return outputText, nil
        }</span>

        // Try text field
        <span class="cov0" title="0">if text, ok := payload["text"].(string); ok &amp;&amp; text != "" </span><span class="cov0" title="0">{
                return text, nil
        }</span>

        <span class="cov0" title="0">return "", errors.New("LLM response had no content")</span>
}

func openCodeDebugEnabled() bool <span class="cov0" title="0">{
        value := strings.ToLower(strings.TrimSpace(os.Getenv("OPENCODE_DEBUG")))
        return value == "1" || value == "true" || value == "yes"
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package personality

import (
        "os"
        "path/filepath"
        "strings"
)

const (
        FileName = "PERSONALITY.md"
        Default  = "You are Gavryn, the local-first control plane assistant.\n\nBehavior guidelines:\n- Speak as Gavryn. Never identify as OpenCode or other system identities.\n- Use the current date/time provided by the system prompt as authoritative.\n- Use available tools when needed; if web-enabled tools are available, use them for current information instead of claiming you cannot browse.\n- Be concise, precise, and action-oriented.\n- For complex tasks, propose a short plan, then execute.\n- Use Markdown with clear headings and bullet points.\n- Ask clarifying questions when requirements are ambiguous.\n- Respect project conventions and avoid unnecessary refactors."
)

func ReadFromDisk() (string, error) <span class="cov0" title="0">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">path, err := findInParents(cwd, FileName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(data)), nil</span>
}

func findInParents(startDir string, filename string) (string, error) <span class="cov0" title="0">{
        dir := startDir
        for </span><span class="cov0" title="0">{
                candidate := filepath.Join(dir, filename)
                if _, err := os.Stat(candidate); err == nil </span><span class="cov0" title="0">{
                        return candidate, nil
                }</span>
                <span class="cov0" title="0">parent := filepath.Dir(dir)
                if parent == dir </span><span class="cov0" title="0">{
                        return "", os.ErrNotExist
                }</span>
                <span class="cov0" title="0">dir = parent</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package secrets

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/base64"
        "errors"
        "io"
)

var newGCM = cipher.NewGCM

func ParseKey(raw string) ([]byte, error) <span class="cov8" title="1">{
        if raw == "" </span><span class="cov8" title="1">{
                return nil, errors.New("LLM_SECRETS_KEY is required")
        }</span>
        <span class="cov8" title="1">if len(raw) == 32 </span><span class="cov8" title="1">{
                return []byte(raw), nil
        }</span>
        <span class="cov8" title="1">decoded, err := base64.StdEncoding.DecodeString(raw)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("LLM_SECRETS_KEY must be 32 bytes or base64-encoded 32 bytes")
        }</span>
        <span class="cov8" title="1">if len(decoded) != 32 </span><span class="cov8" title="1">{
                return nil, errors.New("LLM_SECRETS_KEY must be 32 bytes or base64-encoded 32 bytes")
        }</span>
        <span class="cov8" title="1">return decoded, nil</span>
}

func Encrypt(key []byte, plaintext string) (string, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">gcm, err := newGCM(block)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">nonce := make([]byte, gcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">ciphertext := gcm.Seal(nil, nonce, []byte(plaintext), nil)
        combined := append(nonce, ciphertext...)
        return base64.StdEncoding.EncodeToString(combined), nil</span>
}

func Decrypt(key []byte, encoded string) (string, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">gcm, err := newGCM(block)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">data, err := base64.StdEncoding.DecodeString(encoded)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">if len(data) &lt; gcm.NonceSize() </span><span class="cov8" title="1">{
                return "", errors.New("invalid encrypted secret")
        }</span>
        <span class="cov8" title="1">nonce := data[:gcm.NonceSize()]
        ciphertext := data[gcm.NonceSize():]
        plain, err := gcm.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(plain), nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package skills

import (
        "context"
        "embed"
        "fmt"
        "strings"
        "time"

        "github.com/google/uuid"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store"
)

//go:embed builtin/*/SKILL.md
var builtinSkillFiles embed.FS

type BuiltinSpec struct {
        Name         string
        Description  string
        MarkdownPath string
}

var builtinSpecs = []BuiltinSpec{
        {
                Name:         "gavryn-tool-contracts",
                Description:  "Canonical browser/editor/process tool schemas with valid field names.",
                MarkdownPath: "builtin/gavryn-tool-contracts/SKILL.md",
        },
        {
                Name:         "gavryn-dev-recipes",
                Description:  "Project scaffolding and dev server/preview command recipes for Gavryn.",
                MarkdownPath: "builtin/gavryn-dev-recipes/SKILL.md",
        },
        {
                Name:         "gavryn-browser-research",
                Description:  "Reliable browser research workflow using supported browser tools.",
                MarkdownPath: "builtin/gavryn-browser-research/SKILL.md",
        },
}

func BuiltinSkills() []BuiltinSpec <span class="cov8" title="1">{
        copyOf := make([]BuiltinSpec, len(builtinSpecs))
        copy(copyOf, builtinSpecs)
        return copyOf
}</span>

func EnsureBuiltins(ctx context.Context, st store.Store) error <span class="cov8" title="1">{
        existing, err := st.ListSkills(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">existingNames := make(map[string]struct{}, len(existing))
        for _, skill := range existing </span><span class="cov8" title="1">{
                existingNames[strings.ToLower(strings.TrimSpace(skill.Name))] = struct{}{}
        }</span>

        <span class="cov8" title="1">rootDir, rootErr := RootDir()
        now := time.Now().UTC().Format(time.RFC3339Nano)
        for _, spec := range builtinSpecs </span><span class="cov8" title="1">{
                if _, ok := existingNames[strings.ToLower(spec.Name)]; ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">content, err := builtinSkillFiles.ReadFile(spec.MarkdownPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("read builtin %s: %w", spec.Name, err)
                }</span>

                <span class="cov8" title="1">skillID := uuid.NewString()
                skill := store.Skill{
                        ID:          skillID,
                        Name:        spec.Name,
                        Description: spec.Description,
                        CreatedAt:   now,
                        UpdatedAt:   now,
                }
                if err := st.CreateSkill(ctx, skill); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">file := store.SkillFile{
                        ID:          uuid.NewString(),
                        SkillID:     skillID,
                        Path:        "SKILL.md",
                        Content:     content,
                        ContentType: "text/markdown",
                        SizeBytes:   int64(len(content)),
                        CreatedAt:   now,
                        UpdatedAt:   now,
                }
                if err := st.UpsertSkillFile(ctx, file); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if rootErr == nil </span><span class="cov8" title="1">{
                        if err := MaterializeSkill(rootDir, spec.Name, []store.SkillFile{file}); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package skills

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store"
)

func RootDir() (string, error) <span class="cov8" title="1">{
        configDir, err := os.UserConfigDir()
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return filepath.Join(configDir, "opencode", "skills"), nil</span>
}

func MaterializeSkill(rootDir string, skillName string, files []store.SkillFile) error <span class="cov8" title="1">{
        if rootDir == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("skills root directory required")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(skillName) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("skill name required")
        }</span>
        <span class="cov8" title="1">skillDir := filepath.Join(rootDir, skillName)
        if err := os.RemoveAll(skillDir); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := os.MkdirAll(skillDir, 0o755); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                relPath, err := cleanRelativePath(file.Path)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid skill file path %q: %w", file.Path, err)
                }</span>
                <span class="cov8" title="1">destination := filepath.Join(skillDir, relPath)
                if err := os.MkdirAll(filepath.Dir(destination), 0o755); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := os.WriteFile(destination, file.Content, 0o644); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func cleanRelativePath(value string) (string, error) <span class="cov8" title="1">{
        if value == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("path is empty")
        }</span>
        <span class="cov8" title="1">cleaned := filepath.Clean(value)
        if cleaned == "." </span><span class="cov8" title="1">{
                return "", fmt.Errorf("path is invalid")
        }</span>
        <span class="cov8" title="1">if filepath.IsAbs(cleaned) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("absolute paths not allowed")
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(cleaned, "..") </span><span class="cov8" title="1">{
                return "", fmt.Errorf("path traversal not allowed")
        }</span>
        <span class="cov8" title="1">return cleaned, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package memory

import (
        "context"
        "fmt"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store"
)

type MemoryStore struct {
        mu          sync.RWMutex
        runs        map[string]store.Run
        events      map[string][]store.RunEvent
        runSteps    map[string]map[string]store.RunStep
        processes   map[string]map[string]store.RunProcess
        messages    map[string][]store.Message
        seq         map[string]int64
        settings    *store.LLMSettings
        skills      map[string]store.Skill
        files       map[string]map[string]store.SkillFile
        context     map[string]store.ContextNode
        memory      *store.MemorySettings
        personality *store.PersonalitySettings
        entries     []store.MemoryEntry
        entryIndex  map[string]store.MemoryEntry
        artifacts   map[string]map[string]store.Artifact
        automations map[string]store.Automation
        inbox       map[string][]store.AutomationInboxEntry
}

func New() *MemoryStore <span class="cov8" title="1">{
        return &amp;MemoryStore{
                runs:        map[string]store.Run{},
                events:      map[string][]store.RunEvent{},
                runSteps:    map[string]map[string]store.RunStep{},
                processes:   map[string]map[string]store.RunProcess{},
                messages:    map[string][]store.Message{},
                seq:         map[string]int64{},
                skills:      map[string]store.Skill{},
                files:       map[string]map[string]store.SkillFile{},
                context:     map[string]store.ContextNode{},
                entryIndex:  map[string]store.MemoryEntry{},
                artifacts:   map[string]map[string]store.Artifact{},
                automations: map[string]store.Automation{},
                inbox:       map[string][]store.AutomationInboxEntry{},
        }
}</span>

func (m *MemoryStore) CreateRun(ctx context.Context, run store.Run) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        if strings.TrimSpace(run.Phase) == "" </span><span class="cov8" title="1">{
                run.Phase = "planning"
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(run.PolicyProfile) == "" </span><span class="cov8" title="1">{
                run.PolicyProfile = "default"
        }</span>
        <span class="cov8" title="1">m.runs[run.ID] = run
        return nil</span>
}

func (m *MemoryStore) DeleteRun(ctx context.Context, runID string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        delete(m.runs, runID)
        delete(m.events, runID)
        delete(m.runSteps, runID)
        delete(m.processes, runID)
        delete(m.messages, runID)
        delete(m.seq, runID)
        delete(m.artifacts, runID)
        return nil
}</span>

func (m *MemoryStore) ListAutomations(ctx context.Context) ([]store.Automation, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        results := make([]store.Automation, 0, len(m.automations))
        for _, automation := range m.automations </span><span class="cov0" title="0">{
                cloned := automation
                cloned.Days = append([]string{}, automation.Days...)
                results = append(results, cloned)
        }</span>
        <span class="cov0" title="0">sort.Slice(results, func(i, j int) bool </span><span class="cov0" title="0">{
                return parseTime(results[i].UpdatedAt).After(parseTime(results[j].UpdatedAt))
        }</span>)
        <span class="cov0" title="0">return results, nil</span>
}

func (m *MemoryStore) GetAutomation(ctx context.Context, automationID string) (*store.Automation, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        automation, ok := m.automations[automationID]
        if !ok </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">cloned := automation
        cloned.Days = append([]string{}, automation.Days...)
        return &amp;cloned, nil</span>
}

func (m *MemoryStore) CreateAutomation(ctx context.Context, automation store.Automation) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        cloned := automation
        cloned.Days = append([]string{}, automation.Days...)
        m.automations[automation.ID] = cloned
        if _, ok := m.inbox[automation.ID]; !ok </span><span class="cov0" title="0">{
                m.inbox[automation.ID] = []store.AutomationInboxEntry{}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *MemoryStore) UpdateAutomation(ctx context.Context, automation store.Automation) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        if _, ok := m.automations[automation.ID]; !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">cloned := automation
        cloned.Days = append([]string{}, automation.Days...)
        m.automations[automation.ID] = cloned
        return nil</span>
}

func (m *MemoryStore) DeleteAutomation(ctx context.Context, automationID string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        delete(m.automations, automationID)
        delete(m.inbox, automationID)
        return nil
}</span>

func (m *MemoryStore) ListAutomationInbox(ctx context.Context, automationID string) ([]store.AutomationInboxEntry, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        entries := m.inbox[automationID]
        if entries == nil </span><span class="cov0" title="0">{
                return []store.AutomationInboxEntry{}, nil
        }</span>
        <span class="cov0" title="0">cloned := make([]store.AutomationInboxEntry, 0, len(entries))
        for _, entry := range entries </span><span class="cov0" title="0">{
                copy := entry
                copy.Diagnostics = cloneMap(entry.Diagnostics)
                cloned = append(cloned, copy)
        }</span>
        <span class="cov0" title="0">sort.Slice(cloned, func(i, j int) bool </span><span class="cov0" title="0">{
                return parseTime(cloned[i].StartedAt).After(parseTime(cloned[j].StartedAt))
        }</span>)
        <span class="cov0" title="0">return cloned, nil</span>
}

func (m *MemoryStore) CreateAutomationInboxEntry(ctx context.Context, entry store.AutomationInboxEntry) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        copy := entry
        copy.Diagnostics = cloneMap(entry.Diagnostics)
        m.inbox[entry.AutomationID] = append([]store.AutomationInboxEntry{copy}, m.inbox[entry.AutomationID]...)
        return nil
}</span>

func (m *MemoryStore) UpdateAutomationInboxEntry(ctx context.Context, entry store.AutomationInboxEntry) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        entries := m.inbox[entry.AutomationID]
        for idx := range entries </span><span class="cov0" title="0">{
                if entries[idx].ID != entry.ID </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">copy := entry
                copy.Diagnostics = cloneMap(entry.Diagnostics)
                entries[idx] = copy
                m.inbox[entry.AutomationID] = entries
                return nil</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (m *MemoryStore) MarkAutomationInboxEntryRead(ctx context.Context, automationID string, entryID string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        entries := m.inbox[automationID]
        for idx := range entries </span><span class="cov0" title="0">{
                if entries[idx].ID == entryID </span><span class="cov0" title="0">{
                        entries[idx].Unread = false
                }</span>
        }
        <span class="cov0" title="0">m.inbox[automationID] = entries
        return nil</span>
}

func (m *MemoryStore) MarkAutomationInboxReadAll(ctx context.Context, automationID string) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        entries := m.inbox[automationID]
        for idx := range entries </span><span class="cov0" title="0">{
                entries[idx].Unread = false
        }</span>
        <span class="cov0" title="0">m.inbox[automationID] = entries
        return nil</span>
}

func (m *MemoryStore) ListRuns(ctx context.Context) ([]store.RunSummary, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        results := make([]store.RunSummary, 0, len(m.runs))
        for _, run := range m.runs </span><span class="cov8" title="1">{
                summary := store.RunSummary{
                        ID:               run.ID,
                        Status:           run.Status,
                        Phase:            run.Phase,
                        CompletionReason: run.CompletionReason,
                        ResumedFrom:      run.ResumedFrom,
                        CheckpointSeq:    run.CheckpointSeq,
                        PolicyProfile:    run.PolicyProfile,
                        ModelRoute:       run.ModelRoute,
                        Tags:             append([]string{}, run.Tags...),
                        CreatedAt:        run.CreatedAt,
                        UpdatedAt:        run.UpdatedAt,
                }
                if events := m.events[run.ID]; len(events) &gt; 0 </span><span class="cov8" title="1">{
                        for i := len(events) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                                if events[i].Type != "run.title.updated" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">if title := readString(events[i].Payload, "title"); title != "" </span><span class="cov8" title="1">{
                                        summary.Title = title
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">if messages := m.messages[run.ID]; len(messages) &gt; 0 </span><span class="cov8" title="1">{
                        summary.MessageCount = int64(len(messages))
                        if strings.TrimSpace(summary.Title) == "" </span><span class="cov0" title="0">{
                                for _, msg := range messages </span><span class="cov0" title="0">{
                                        if msg.Role == "user" </span><span class="cov0" title="0">{
                                                summary.Title = msg.Content
                                                break</span>
                                        }
                                }
                        }
                }
                <span class="cov8" title="1">if events := m.events[run.ID]; len(events) &gt; 0 </span><span class="cov8" title="1">{
                        last := events[len(events)-1]
                        if last.Timestamp != "" </span><span class="cov0" title="0">{
                                summary.UpdatedAt = last.Timestamp
                        }</span>
                        <span class="cov8" title="1">if status := statusFromEvent(last.Type); status != "" </span><span class="cov0" title="0">{
                                summary.Status = status
                        }</span>
                }
                <span class="cov8" title="1">results = append(results, summary)</span>
        }
        <span class="cov8" title="1">sort.Slice(results, func(i, j int) bool </span><span class="cov0" title="0">{
                left := parseTime(results[i].UpdatedAt)
                right := parseTime(results[j].UpdatedAt)
                return left.After(right)
        }</span>)
        <span class="cov8" title="1">return results, nil</span>
}

func (m *MemoryStore) AddMessage(ctx context.Context, msg store.Message) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.messages[msg.RunID] = append(m.messages[msg.RunID], msg)
        return nil
}</span>

func (m *MemoryStore) ListMessages(ctx context.Context, runID string) ([]store.Message, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        messages := m.messages[runID]
        return append([]store.Message{}, messages...), nil
}</span>

func (m *MemoryStore) GetLLMSettings(ctx context.Context) (*store.LLMSettings, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        if m.settings == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">copy := *m.settings
        return &amp;copy, nil</span>
}

func (m *MemoryStore) UpsertLLMSettings(ctx context.Context, settings store.LLMSettings) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        copy := settings
        m.settings = &amp;copy
        return nil
}</span>

func (m *MemoryStore) ListSkills(ctx context.Context) ([]store.Skill, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        results := make([]store.Skill, 0, len(m.skills))
        for _, skill := range m.skills </span><span class="cov8" title="1">{
                results = append(results, skill)
        }</span>
        <span class="cov8" title="1">return results, nil</span>
}

func (m *MemoryStore) GetSkill(ctx context.Context, skillID string) (*store.Skill, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        skill, ok := m.skills[skillID]
        if !ok </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">copy := skill
        return &amp;copy, nil</span>
}

func (m *MemoryStore) CreateSkill(ctx context.Context, skill store.Skill) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.skills[skill.ID] = skill
        return nil
}</span>

func (m *MemoryStore) UpdateSkill(ctx context.Context, skill store.Skill) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.skills[skill.ID] = skill
        return nil
}</span>

func (m *MemoryStore) DeleteSkill(ctx context.Context, skillID string) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        delete(m.skills, skillID)
        delete(m.files, skillID)
        return nil
}</span>

func (m *MemoryStore) ListSkillFiles(ctx context.Context, skillID string) ([]store.SkillFile, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        files := m.files[skillID]
        if files == nil </span><span class="cov8" title="1">{
                return []store.SkillFile{}, nil
        }</span>
        <span class="cov8" title="1">results := make([]store.SkillFile, 0, len(files))
        for _, file := range files </span><span class="cov8" title="1">{
                results = append(results, file)
        }</span>
        <span class="cov8" title="1">return results, nil</span>
}

func (m *MemoryStore) UpsertSkillFile(ctx context.Context, file store.SkillFile) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        if m.files[file.SkillID] == nil </span><span class="cov8" title="1">{
                m.files[file.SkillID] = map[string]store.SkillFile{}
        }</span>
        <span class="cov8" title="1">m.files[file.SkillID][file.Path] = file
        return nil</span>
}

func (m *MemoryStore) DeleteSkillFile(ctx context.Context, skillID string, path string) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        files := m.files[skillID]
        if files == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">delete(files, path)
        return nil</span>
}

func (m *MemoryStore) ListContextNodes(ctx context.Context) ([]store.ContextNode, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        results := make([]store.ContextNode, 0, len(m.context))
        for _, node := range m.context </span><span class="cov8" title="1">{
                results = append(results, node)
        }</span>
        <span class="cov8" title="1">return results, nil</span>
}

func (m *MemoryStore) GetContextFile(ctx context.Context, nodeID string) (*store.ContextNode, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        node, ok := m.context[nodeID]
        if !ok </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">copy := node
        return &amp;copy, nil</span>
}

func (m *MemoryStore) CreateContextFolder(ctx context.Context, node store.ContextNode) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.context[node.ID] = node
        return nil
}</span>

func (m *MemoryStore) CreateContextFile(ctx context.Context, node store.ContextNode) error <span class="cov8" title="1">{
        return m.CreateContextFolder(ctx, node)
}</span>

func (m *MemoryStore) DeleteContextNode(ctx context.Context, nodeID string) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.deleteContextSubtree(nodeID)
        return nil
}</span>

func (m *MemoryStore) GetMemorySettings(ctx context.Context) (*store.MemorySettings, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        if m.memory == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">copy := *m.memory
        return &amp;copy, nil</span>
}

func (m *MemoryStore) UpsertMemorySettings(ctx context.Context, settings store.MemorySettings) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        copy := settings
        m.memory = &amp;copy
        return nil
}</span>

func (m *MemoryStore) UpsertMemoryEntry(ctx context.Context, entry store.MemoryEntry) (bool, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        fingerprint := ""
        if entry.Metadata != nil </span><span class="cov8" title="1">{
                if value, ok := entry.Metadata["fingerprint"]; ok </span><span class="cov8" title="1">{
                        if key, ok := value.(string); ok </span><span class="cov8" title="1">{
                                fingerprint = strings.TrimSpace(key)
                        }</span>
                }
        }
        <span class="cov8" title="1">if fingerprint != "" </span><span class="cov8" title="1">{
                if _, exists := m.entryIndex[fingerprint]; exists </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">m.entryIndex[fingerprint] = entry</span>
        }
        <span class="cov8" title="1">m.entries = append(m.entries, entry)
        return true, nil</span>
}

func (m *MemoryStore) GetPersonalitySettings(ctx context.Context) (*store.PersonalitySettings, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        if m.personality == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">copy := *m.personality
        return &amp;copy, nil</span>
}

func (m *MemoryStore) UpsertPersonalitySettings(ctx context.Context, settings store.PersonalitySettings) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        copy := settings
        m.personality = &amp;copy
        return nil
}</span>

func (m *MemoryStore) SearchMemory(ctx context.Context, query string, limit int) ([]store.MemoryEntry, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        if query == "" || limit &lt;= 0 </span><span class="cov8" title="1">{
                return []store.MemoryEntry{}, nil
        }</span>
        <span class="cov8" title="1">results := []store.MemoryEntry{}
        for _, entry := range m.entries </span><span class="cov8" title="1">{
                if len(results) &gt;= limit </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if strings.Contains(strings.ToLower(entry.Content), strings.ToLower(query)) </span><span class="cov8" title="1">{
                        results = append(results, entry)
                }</span>
        }
        <span class="cov8" title="1">return results, nil</span>
}

func (m *MemoryStore) SearchMemoryWithEmbedding(ctx context.Context, query string, embedding []float32, limit int) ([]store.MemoryEntry, error) <span class="cov8" title="1">{
        return m.SearchMemory(ctx, query, limit)
}</span>

func (m *MemoryStore) deleteContextSubtree(nodeID string) <span class="cov8" title="1">{
        for id, node := range m.context </span><span class="cov8" title="1">{
                if node.ParentID == nodeID </span><span class="cov8" title="1">{
                        m.deleteContextSubtree(id)
                }</span>
        }
        <span class="cov8" title="1">delete(m.context, nodeID)</span>
}

func (m *MemoryStore) AppendEvent(ctx context.Context, event store.RunEvent) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        event.Type = normalizeEventType(event.Type)
        m.events[event.RunID] = append(m.events[event.RunID], event)
        m.applyRunStepLocked(event)
        m.applyRunStateLocked(event)
        return nil
}</span>

func normalizeEventType(eventType string) string <span class="cov8" title="1">{
        normalized := strings.TrimSpace(strings.ToLower(eventType))
        if normalized == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return strings.ReplaceAll(normalized, "_", ".")</span>
}

func (m *MemoryStore) ListEvents(ctx context.Context, runID string, afterSeq int64) ([]store.RunEvent, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        events := m.events[runID]
        if afterSeq &lt;= 0 </span><span class="cov8" title="1">{
                return append([]store.RunEvent{}, events...), nil
        }</span>
        <span class="cov8" title="1">filtered := []store.RunEvent{}
        for _, event := range events </span><span class="cov8" title="1">{
                if event.Seq &gt; afterSeq </span><span class="cov8" title="1">{
                        filtered = append(filtered, event)
                }</span>
        }
        <span class="cov8" title="1">return filtered, nil</span>
}

func (m *MemoryStore) NextSeq(ctx context.Context, runID string) (int64, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.seq[runID] += 1
        return m.seq[runID], nil
}</span>

func (m *MemoryStore) ListRunSteps(ctx context.Context, runID string) ([]store.RunStep, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        stepsByID := m.runSteps[runID]
        if len(stepsByID) == 0 </span><span class="cov0" title="0">{
                return []store.RunStep{}, nil
        }</span>

        <span class="cov8" title="1">steps := make([]store.RunStep, 0, len(stepsByID))
        for _, step := range stepsByID </span><span class="cov8" title="1">{
                steps = append(steps, step)
        }</span>
        <span class="cov8" title="1">sort.Slice(steps, func(i, j int) bool </span><span class="cov0" title="0">{
                if steps[i].Seq == steps[j].Seq </span><span class="cov0" title="0">{
                        return steps[i].ID &lt; steps[j].ID
                }</span>
                <span class="cov0" title="0">if steps[i].Seq == 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if steps[j].Seq == 0 </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">return steps[i].Seq &lt; steps[j].Seq</span>
        })
        <span class="cov8" title="1">return steps, nil</span>
}

func (m *MemoryStore) UpsertRunProcess(ctx context.Context, process store.RunProcess) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if process.ProcessID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("process id required")
        }</span>
        <span class="cov8" title="1">if m.processes[process.RunID] == nil </span><span class="cov8" title="1">{
                m.processes[process.RunID] = map[string]store.RunProcess{}
        }</span>
        <span class="cov8" title="1">existing, ok := m.processes[process.RunID][process.ProcessID]
        if !ok </span><span class="cov8" title="1">{
                if process.Metadata == nil </span><span class="cov8" title="1">{
                        process.Metadata = map[string]any{}
                }</span>
                <span class="cov8" title="1">m.processes[process.RunID][process.ProcessID] = process
                return nil</span>
        }
        <span class="cov8" title="1">if existing.Command == "" </span><span class="cov0" title="0">{
                existing.Command = process.Command
        }</span>
        <span class="cov8" title="1">if len(existing.Args) == 0 &amp;&amp; len(process.Args) &gt; 0 </span><span class="cov0" title="0">{
                existing.Args = append([]string{}, process.Args...)
        }</span>
        <span class="cov8" title="1">if existing.Cwd == "" </span><span class="cov8" title="1">{
                existing.Cwd = process.Cwd
        }</span>
        <span class="cov8" title="1">if process.Status != "" </span><span class="cov8" title="1">{
                existing.Status = process.Status
        }</span>
        <span class="cov8" title="1">if process.PID &gt; 0 </span><span class="cov8" title="1">{
                existing.PID = process.PID
        }</span>
        <span class="cov8" title="1">if existing.StartedAt == "" &amp;&amp; process.StartedAt != "" </span><span class="cov0" title="0">{
                existing.StartedAt = process.StartedAt
        }</span>
        <span class="cov8" title="1">if process.EndedAt != "" </span><span class="cov8" title="1">{
                existing.EndedAt = process.EndedAt
        }</span>
        <span class="cov8" title="1">if process.ExitCode != nil </span><span class="cov8" title="1">{
                code := *process.ExitCode
                existing.ExitCode = &amp;code
        }</span>
        <span class="cov8" title="1">if process.Signal != "" </span><span class="cov0" title="0">{
                existing.Signal = process.Signal
        }</span>
        <span class="cov8" title="1">if len(process.PreviewURLs) &gt; 0 </span><span class="cov8" title="1">{
                existing.PreviewURLs = dedupeStrings(append(existing.PreviewURLs, process.PreviewURLs...))
        }</span>
        <span class="cov8" title="1">if existing.Metadata == nil </span><span class="cov0" title="0">{
                existing.Metadata = map[string]any{}
        }</span>
        <span class="cov8" title="1">for key, value := range process.Metadata </span><span class="cov0" title="0">{
                existing.Metadata[key] = value
        }</span>
        <span class="cov8" title="1">m.processes[process.RunID][process.ProcessID] = existing
        return nil</span>
}

func (m *MemoryStore) GetRunProcess(ctx context.Context, runID string, processID string) (*store.RunProcess, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        byRun := m.processes[runID]
        if byRun == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">process, ok := byRun[processID]
        if !ok </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">copy := process
        return &amp;copy, nil</span>
}

func (m *MemoryStore) ListRunProcesses(ctx context.Context, runID string) ([]store.RunProcess, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        byRun := m.processes[runID]
        if byRun == nil </span><span class="cov0" title="0">{
                return []store.RunProcess{}, nil
        }</span>
        <span class="cov8" title="1">processes := make([]store.RunProcess, 0, len(byRun))
        for _, process := range byRun </span><span class="cov8" title="1">{
                processes = append(processes, process)
        }</span>
        <span class="cov8" title="1">sort.Slice(processes, func(i, j int) bool </span><span class="cov0" title="0">{
                left := parseTime(processes[i].StartedAt)
                right := parseTime(processes[j].StartedAt)
                if left.Equal(right) </span><span class="cov0" title="0">{
                        return processes[i].ProcessID &lt; processes[j].ProcessID
                }</span>
                <span class="cov0" title="0">return left.After(right)</span>
        })
        <span class="cov8" title="1">return processes, nil</span>
}

func (m *MemoryStore) UpsertArtifact(ctx context.Context, artifact store.Artifact) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        if artifact.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("artifact id required")
        }</span>
        <span class="cov8" title="1">if m.artifacts[artifact.RunID] == nil </span><span class="cov8" title="1">{
                m.artifacts[artifact.RunID] = map[string]store.Artifact{}
        }</span>
        <span class="cov8" title="1">m.artifacts[artifact.RunID][artifact.ID] = artifact
        return nil</span>
}

func (m *MemoryStore) ListArtifacts(ctx context.Context, runID string) ([]store.Artifact, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        artifacts := m.artifacts[runID]
        if artifacts == nil </span><span class="cov8" title="1">{
                return []store.Artifact{}, nil
        }</span>
        <span class="cov8" title="1">results := make([]store.Artifact, 0, len(artifacts))
        for _, artifact := range artifacts </span><span class="cov8" title="1">{
                results = append(results, artifact)
        }</span>
        <span class="cov8" title="1">sort.Slice(results, func(i, j int) bool </span><span class="cov0" title="0">{
                left := parseTime(results[i].CreatedAt)
                right := parseTime(results[j].CreatedAt)
                if left.Equal(right) </span><span class="cov0" title="0">{
                        return results[i].ID &lt; results[j].ID
                }</span>
                <span class="cov0" title="0">return left.Before(right)</span>
        })
        <span class="cov8" title="1">return results, nil</span>
}

func statusFromEvent(eventType string) string <span class="cov8" title="1">{
        switch eventType </span>{
        case "run.completed":<span class="cov0" title="0">
                return "completed"</span>
        case "run.failed":<span class="cov0" title="0">
                return "failed"</span>
        case "run.cancelled":<span class="cov0" title="0">
                return "cancelled"</span>
        case "run.partial":<span class="cov0" title="0">
                return "partial"</span>
        case "run.started":<span class="cov0" title="0">
                return "running"</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}

func parseTime(value string) time.Time <span class="cov0" title="0">{
        parsed, err := time.Parse(time.RFC3339Nano, value)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>
        <span class="cov0" title="0">return parsed</span>
}

func readString(metadata map[string]any, key string) string <span class="cov8" title="1">{
        if metadata == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">raw, ok := metadata[key]
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">value, ok := raw.(string)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(value)</span>
}

func (m *MemoryStore) applyRunStepLocked(event store.RunEvent) <span class="cov8" title="1">{
        step, ok := store.BuildRunStepFromEvent(event)
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if m.runSteps[event.RunID] == nil </span><span class="cov8" title="1">{
                m.runSteps[event.RunID] = map[string]store.RunStep{}
        }</span>
        <span class="cov8" title="1">existing, exists := m.runSteps[event.RunID][step.ID]
        if !exists </span><span class="cov8" title="1">{
                m.runSteps[event.RunID][step.ID] = step
                return
        }</span>
        <span class="cov8" title="1">m.runSteps[event.RunID][step.ID] = store.MergeRunStep(existing, step)</span>
}

func (m *MemoryStore) applyRunStateLocked(event store.RunEvent) <span class="cov8" title="1">{
        run, ok := m.runs[event.RunID]
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">eventType := strings.ReplaceAll(strings.ToLower(strings.TrimSpace(event.Type)), "_", ".")
        switch eventType </span>{
        case "run.started":<span class="cov0" title="0">
                run.Status = "running"
                run.Phase = "planning"</span>
        case "run.phase.changed":<span class="cov0" title="0">
                if phase := readString(event.Payload, "phase"); phase != "" </span><span class="cov0" title="0">{
                        run.Phase = phase
                }</span>
        case "run.completed":<span class="cov0" title="0">
                run.Status = "completed"
                run.Phase = "completed"
                run.CompletionReason = readString(event.Payload, "completion_reason")</span>
        case "run.partial":<span class="cov0" title="0">
                run.Status = "partial"
                run.Phase = "completed"
                run.CompletionReason = readString(event.Payload, "completion_reason")</span>
        case "run.failed":<span class="cov0" title="0">
                run.Status = "failed"
                run.Phase = "failed"
                if reason := readString(event.Payload, "completion_reason"); reason != "" </span><span class="cov0" title="0">{
                        run.CompletionReason = reason
                }</span> else<span class="cov0" title="0"> {
                        run.CompletionReason = "activity_error"
                }</span>
        case "run.cancelled":<span class="cov0" title="0">
                run.Status = "cancelled"
                run.Phase = "cancelled"
                run.CompletionReason = "user_cancelled"</span>
        case "run.resumed":<span class="cov0" title="0">
                run.Status = "running"
                run.Phase = "planning"
                if resumedFrom := readString(event.Payload, "resumed_from"); resumedFrom != "" </span><span class="cov0" title="0">{
                        run.ResumedFrom = resumedFrom
                }</span>
        }
        <span class="cov8" title="1">if event.Seq &gt; run.CheckpointSeq </span><span class="cov8" title="1">{
                run.CheckpointSeq = event.Seq
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(event.Timestamp) != "" </span><span class="cov0" title="0">{
                run.UpdatedAt = event.Timestamp
        }</span>
        <span class="cov8" title="1">m.runs[event.RunID] = run</span>
}

func dedupeStrings(values []string) []string <span class="cov8" title="1">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">seen := map[string]struct{}{}
        result := make([]string, 0, len(values))
        for _, value := range values </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(value)
                if trimmed == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, ok := seen[trimmed]; ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">seen[trimmed] = struct{}{}
                result = append(result, trimmed)</span>
        }
        <span class="cov8" title="1">if len(result) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return result</span>
}

func cloneMap(input map[string]any) map[string]any <span class="cov0" title="0">{
        if len(input) == 0 </span><span class="cov0" title="0">{
                return map[string]any{}
        }</span>
        <span class="cov0" title="0">out := make(map[string]any, len(input))
        for key, value := range input </span><span class="cov0" title="0">{
                out[key] = value
        }</span>
        <span class="cov0" title="0">return out</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "github.com/google/uuid"
        _ "github.com/jackc/pgx/v5/stdlib"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store"
)

type PostgresStore struct {
        db *sql.DB
}

var openDB = sql.Open

func New(conn string) (*PostgresStore, error) <span class="cov8" title="1">{
        db, err := openDB("pgx", conn)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        if err := db.PingContext(ctx); err != nil </span><span class="cov8" title="1">{
                _ = db.Close()
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := verifySchema(ctx, db); err != nil </span><span class="cov8" title="1">{
                _ = db.Close()
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;PostgresStore{db: db}, nil</span>
}

func verifySchema(ctx context.Context, db *sql.DB) error <span class="cov8" title="1">{
        required := []string{
                "runs",
                "messages",
                "run_events",
                "run_event_sequences",
                "run_steps",
                "run_processes",
                "llm_settings",
                "skills",
                "skill_files",
                "context_nodes",
                "memory_settings",
                "memory_entries",
                "personality_settings",
                "artifacts",
                "automations",
                "automation_inbox",
        }
        for _, table := range required </span><span class="cov8" title="1">{
                var regclass sql.NullString
                if err := db.QueryRowContext(ctx, "SELECT to_regclass($1)", fmt.Sprintf("public.%s", table)).Scan(&amp;regclass); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if !regclass.Valid </span><span class="cov8" title="1">{
                        return fmt.Errorf("database schema missing: %s table not found (run infra/migrations/001_init.sql)", table)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (p *PostgresStore) CreateRun(ctx context.Context, run store.Run) error <span class="cov8" title="1">{
        phase := strings.TrimSpace(run.Phase)
        if phase == "" </span><span class="cov8" title="1">{
                phase = "planning"
        }</span>
        <span class="cov8" title="1">policyProfile := strings.TrimSpace(run.PolicyProfile)
        if policyProfile == "" </span><span class="cov8" title="1">{
                policyProfile = "default"
        }</span>
        <span class="cov8" title="1">tagsBytes, err := json.Marshal(run.Tags)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">const query = `
                INSERT INTO runs (
                        id,
                        status,
                        phase,
                        completion_reason,
                        resumed_from,
                        checkpoint_seq,
                        policy_profile,
                        model_route,
                        tags,
                        created_at,
                        updated_at
                )
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
        `
        _, err = p.db.ExecContext(
                ctx,
                query,
                run.ID,
                run.Status,
                phase,
                nullString(run.CompletionReason),
                nullString(run.ResumedFrom),
                run.CheckpointSeq,
                policyProfile,
                nullString(run.ModelRoute),
                tagsBytes,
                run.CreatedAt,
                run.UpdatedAt,
        )
        return err</span>
}

func (p *PostgresStore) DeleteRun(ctx context.Context, runID string) error <span class="cov0" title="0">{
        _, err := p.db.ExecContext(ctx, "DELETE FROM runs WHERE id = $1", runID)
        return err
}</span>

func (p *PostgresStore) ListRuns(ctx context.Context) ([]store.RunSummary, error) <span class="cov8" title="1">{
        const query = `
                SELECT
                        r.id,
                        COALESCE(
                                CASE latest.type
                                        WHEN 'run.completed' THEN 'completed'
                                        WHEN 'run.failed' THEN 'failed'
                                        WHEN 'run.cancelled' THEN 'cancelled'
                                        WHEN 'run.partial' THEN 'partial'
                                        WHEN 'run.started' THEN 'running'
                                        ELSE r.status
                                END,
                                r.status
                        ) AS status,
                        r.phase,
                        r.completion_reason,
                        r.resumed_from,
                        r.checkpoint_seq,
                        r.policy_profile,
                        r.model_route,
                        r.tags,
                        r.created_at,
                        COALESCE(latest.timestamp, r.updated_at) AS updated_at,
                        COALESCE(NULLIF(r.title, ''), title_event.title, first_message.content, '') AS title,
                        COUNT(m.id) AS message_count
                FROM runs r
                LEFT JOIN LATERAL (
                        SELECT type, timestamp
                        FROM run_events
                        WHERE run_id = r.id
                        ORDER BY seq DESC
                        LIMIT 1
                ) latest ON true
                LEFT JOIN LATERAL (
                        SELECT payload-&gt;&gt;'title' AS title
                        FROM run_events
                        WHERE run_id = r.id
                                AND type = 'run.title.updated'
                                AND payload ? 'title'
                        ORDER BY seq DESC
                        LIMIT 1
                ) title_event ON true
                LEFT JOIN LATERAL (
                        SELECT content
                        FROM messages
                        WHERE run_id = r.id AND role = 'user'
                        ORDER BY sequence ASC
                        LIMIT 1
                ) first_message ON true
                LEFT JOIN messages m ON m.run_id = r.id
                GROUP BY r.id, r.status, r.phase, r.completion_reason, r.resumed_from, r.checkpoint_seq, r.policy_profile, r.model_route, r.tags, r.created_at, r.updated_at, r.title, latest.type, latest.timestamp, title_event.title, first_message.content
                ORDER BY COALESCE(latest.timestamp, r.updated_at) DESC
        `
        rows, err := p.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        results := []store.RunSummary{}
        for rows.Next() </span><span class="cov8" title="1">{
                var createdAt time.Time
                var updatedAt time.Time
                var completionReason sql.NullString
                var resumedFrom sql.NullString
                var modelRoute sql.NullString
                var tagsBytes []byte
                var summary store.RunSummary
                if err := rows.Scan(
                        &amp;summary.ID,
                        &amp;summary.Status,
                        &amp;summary.Phase,
                        &amp;completionReason,
                        &amp;resumedFrom,
                        &amp;summary.CheckpointSeq,
                        &amp;summary.PolicyProfile,
                        &amp;modelRoute,
                        &amp;tagsBytes,
                        &amp;createdAt,
                        &amp;updatedAt,
                        &amp;summary.Title,
                        &amp;summary.MessageCount,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if completionReason.Valid </span><span class="cov0" title="0">{
                        summary.CompletionReason = completionReason.String
                }</span>
                <span class="cov8" title="1">if resumedFrom.Valid </span><span class="cov0" title="0">{
                        summary.ResumedFrom = resumedFrom.String
                }</span>
                <span class="cov8" title="1">if modelRoute.Valid </span><span class="cov0" title="0">{
                        summary.ModelRoute = modelRoute.String
                }</span>
                <span class="cov8" title="1">summary.Tags = decodeStringSlice(tagsBytes)
                if summary.Phase == "" </span><span class="cov0" title="0">{
                        summary.Phase = "planning"
                }</span>
                <span class="cov8" title="1">summary.CreatedAt = createdAt.UTC().Format(time.RFC3339Nano)
                summary.UpdatedAt = updatedAt.UTC().Format(time.RFC3339Nano)
                results = append(results, summary)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return results, nil</span>
}

func (p *PostgresStore) AddMessage(ctx context.Context, msg store.Message) error <span class="cov8" title="1">{
        metadata := msg.Metadata
        if metadata == nil </span><span class="cov8" title="1">{
                metadata = map[string]any{}
        }</span>
        <span class="cov8" title="1">encoded, err := json.Marshal(metadata)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">const query = `
                INSERT INTO messages (id, run_id, role, content, sequence, created_at, metadata)
                VALUES ($1, $2, $3, $4, $5, $6, $7)
        `
        _, err = p.db.ExecContext(ctx, query, msg.ID, msg.RunID, msg.Role, msg.Content, msg.Sequence, msg.CreatedAt, encoded)
        return err</span>
}

func (p *PostgresStore) ListMessages(ctx context.Context, runID string) ([]store.Message, error) <span class="cov8" title="1">{
        const query = `
                SELECT id, run_id, role, content, sequence, created_at, metadata
                FROM messages
                WHERE run_id = $1
                ORDER BY sequence ASC
        `
        rows, err := p.db.QueryContext(ctx, query, runID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        results := []store.Message{}
        for rows.Next() </span><span class="cov8" title="1">{
                var createdAt time.Time
                var metadataBytes []byte
                var msg store.Message
                if err := rows.Scan(&amp;msg.ID, &amp;msg.RunID, &amp;msg.Role, &amp;msg.Content, &amp;msg.Sequence, &amp;createdAt, &amp;metadataBytes); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">msg.CreatedAt = createdAt.UTC().Format(time.RFC3339Nano)
                if len(metadataBytes) &gt; 0 </span><span class="cov8" title="1">{
                        metadata := map[string]any{}
                        if err := json.Unmarshal(metadataBytes, &amp;metadata); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">msg.Metadata = metadata</span>
                } else<span class="cov8" title="1"> {
                        msg.Metadata = map[string]any{}
                }</span>
                <span class="cov8" title="1">results = append(results, msg)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return results, nil</span>
}

func (p *PostgresStore) GetLLMSettings(ctx context.Context) (*store.LLMSettings, error) <span class="cov8" title="1">{
        const query = `
                SELECT mode, provider, model, base_url, api_key_enc, codex_auth_path, codex_home, created_at, updated_at
                FROM llm_settings
                WHERE id = 1
        `
        var createdAt time.Time
        var updatedAt time.Time
        settings := store.LLMSettings{}
        if err := p.db.QueryRowContext(ctx, query).Scan(
                &amp;settings.Mode,
                &amp;settings.Provider,
                &amp;settings.Model,
                &amp;settings.BaseURL,
                &amp;settings.APIKeyEnc,
                &amp;settings.CodexAuthPath,
                &amp;settings.CodexHome,
                &amp;createdAt,
                &amp;updatedAt,
        ); err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov8" title="1">settings.CreatedAt = createdAt.UTC().Format(time.RFC3339Nano)
        settings.UpdatedAt = updatedAt.UTC().Format(time.RFC3339Nano)
        return &amp;settings, nil</span>
}

func (p *PostgresStore) UpsertLLMSettings(ctx context.Context, settings store.LLMSettings) error <span class="cov8" title="1">{
        const query = `
                INSERT INTO llm_settings
                        (id, mode, provider, model, base_url, api_key_enc, codex_auth_path, codex_home, created_at, updated_at)
                VALUES
                        (1, $1, $2, $3, $4, $5, $6, $7, $8, $9)
                ON CONFLICT (id)
                DO UPDATE SET
                        mode = EXCLUDED.mode,
                        provider = EXCLUDED.provider,
                        model = EXCLUDED.model,
                        base_url = EXCLUDED.base_url,
                        api_key_enc = EXCLUDED.api_key_enc,
                        codex_auth_path = EXCLUDED.codex_auth_path,
                        codex_home = EXCLUDED.codex_home,
                        updated_at = EXCLUDED.updated_at
        `
        _, err := p.db.ExecContext(
                ctx,
                query,
                settings.Mode,
                settings.Provider,
                settings.Model,
                settings.BaseURL,
                settings.APIKeyEnc,
                settings.CodexAuthPath,
                settings.CodexHome,
                settings.CreatedAt,
                settings.UpdatedAt,
        )
        return err
}</span>

func (p *PostgresStore) ListSkills(ctx context.Context) ([]store.Skill, error) <span class="cov8" title="1">{
        const query = `
                SELECT id, name, description, created_at, updated_at
                FROM skills
                ORDER BY name ASC
        `
        rows, err := p.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        results := []store.Skill{}
        for rows.Next() </span><span class="cov8" title="1">{
                var createdAt time.Time
                var updatedAt time.Time
                var skill store.Skill
                if err := rows.Scan(&amp;skill.ID, &amp;skill.Name, &amp;skill.Description, &amp;createdAt, &amp;updatedAt); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">skill.CreatedAt = createdAt.UTC().Format(time.RFC3339Nano)
                skill.UpdatedAt = updatedAt.UTC().Format(time.RFC3339Nano)
                results = append(results, skill)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return results, nil</span>
}

func (p *PostgresStore) GetSkill(ctx context.Context, skillID string) (*store.Skill, error) <span class="cov8" title="1">{
        const query = `
                SELECT id, name, description, created_at, updated_at
                FROM skills
                WHERE id = $1
        `
        var createdAt time.Time
        var updatedAt time.Time
        skill := store.Skill{}
        if err := p.db.QueryRowContext(ctx, query, skillID).Scan(
                &amp;skill.ID,
                &amp;skill.Name,
                &amp;skill.Description,
                &amp;createdAt,
                &amp;updatedAt,
        ); err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov8" title="1">skill.CreatedAt = createdAt.UTC().Format(time.RFC3339Nano)
        skill.UpdatedAt = updatedAt.UTC().Format(time.RFC3339Nano)
        return &amp;skill, nil</span>
}

func (p *PostgresStore) CreateSkill(ctx context.Context, skill store.Skill) error <span class="cov8" title="1">{
        const query = `
                INSERT INTO skills (id, name, description, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5)
        `
        _, err := p.db.ExecContext(ctx, query, skill.ID, skill.Name, skill.Description, skill.CreatedAt, skill.UpdatedAt)
        return err
}</span>

func (p *PostgresStore) UpdateSkill(ctx context.Context, skill store.Skill) error <span class="cov8" title="1">{
        const query = `
                UPDATE skills
                SET name = $1, description = $2, updated_at = $3
                WHERE id = $4
        `
        _, err := p.db.ExecContext(ctx, query, skill.Name, skill.Description, skill.UpdatedAt, skill.ID)
        return err
}</span>

func (p *PostgresStore) DeleteSkill(ctx context.Context, skillID string) error <span class="cov8" title="1">{
        const query = `
                DELETE FROM skills
                WHERE id = $1
        `
        _, err := p.db.ExecContext(ctx, query, skillID)
        return err
}</span>

func (p *PostgresStore) ListSkillFiles(ctx context.Context, skillID string) ([]store.SkillFile, error) <span class="cov8" title="1">{
        const query = `
                SELECT id, skill_id, path, content, content_type, size_bytes, created_at, updated_at
                FROM skill_files
                WHERE skill_id = $1
                ORDER BY path ASC
        `
        rows, err := p.db.QueryContext(ctx, query, skillID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        results := []store.SkillFile{}
        for rows.Next() </span><span class="cov8" title="1">{
                var createdAt time.Time
                var updatedAt time.Time
                var file store.SkillFile
                if err := rows.Scan(
                        &amp;file.ID,
                        &amp;file.SkillID,
                        &amp;file.Path,
                        &amp;file.Content,
                        &amp;file.ContentType,
                        &amp;file.SizeBytes,
                        &amp;createdAt,
                        &amp;updatedAt,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">file.CreatedAt = createdAt.UTC().Format(time.RFC3339Nano)
                file.UpdatedAt = updatedAt.UTC().Format(time.RFC3339Nano)
                results = append(results, file)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return results, nil</span>
}

func (p *PostgresStore) UpsertSkillFile(ctx context.Context, file store.SkillFile) error <span class="cov8" title="1">{
        const query = `
                INSERT INTO skill_files
                        (id, skill_id, path, content, content_type, size_bytes, created_at, updated_at)
                VALUES
                        ($1, $2, $3, $4, $5, $6, $7, $8)
                ON CONFLICT (skill_id, path)
                DO UPDATE SET
                        content = EXCLUDED.content,
                        content_type = EXCLUDED.content_type,
                        size_bytes = EXCLUDED.size_bytes,
                        updated_at = EXCLUDED.updated_at
        `
        _, err := p.db.ExecContext(
                ctx,
                query,
                file.ID,
                file.SkillID,
                file.Path,
                file.Content,
                file.ContentType,
                file.SizeBytes,
                file.CreatedAt,
                file.UpdatedAt,
        )
        return err
}</span>

func (p *PostgresStore) DeleteSkillFile(ctx context.Context, skillID string, path string) error <span class="cov8" title="1">{
        const query = `
                DELETE FROM skill_files
                WHERE skill_id = $1 AND path = $2
        `
        _, err := p.db.ExecContext(ctx, query, skillID, path)
        return err
}</span>

func (p *PostgresStore) ListContextNodes(ctx context.Context) ([]store.ContextNode, error) <span class="cov8" title="1">{
        const query = `
                SELECT id, parent_id, name, node_type, content_type, size_bytes, created_at, updated_at
                FROM context_nodes
                ORDER BY name ASC
        `
        rows, err := p.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        results := []store.ContextNode{}
        for rows.Next() </span><span class="cov8" title="1">{
                var parentID sql.NullString
                var createdAt time.Time
                var updatedAt time.Time
                var node store.ContextNode
                if err := rows.Scan(
                        &amp;node.ID,
                        &amp;parentID,
                        &amp;node.Name,
                        &amp;node.NodeType,
                        &amp;node.ContentType,
                        &amp;node.SizeBytes,
                        &amp;createdAt,
                        &amp;updatedAt,
                ); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if parentID.Valid </span><span class="cov8" title="1">{
                        node.ParentID = parentID.String
                }</span>
                <span class="cov8" title="1">node.CreatedAt = createdAt.UTC().Format(time.RFC3339Nano)
                node.UpdatedAt = updatedAt.UTC().Format(time.RFC3339Nano)
                results = append(results, node)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return results, nil</span>
}

func (p *PostgresStore) GetContextFile(ctx context.Context, nodeID string) (*store.ContextNode, error) <span class="cov8" title="1">{
        const query = `
                SELECT id, parent_id, name, node_type, content, content_type, size_bytes, created_at, updated_at
                FROM context_nodes
                WHERE id = $1
        `
        var parentID sql.NullString
        var createdAt time.Time
        var updatedAt time.Time
        node := store.ContextNode{}
        if err := p.db.QueryRowContext(ctx, query, nodeID).Scan(
                &amp;node.ID,
                &amp;parentID,
                &amp;node.Name,
                &amp;node.NodeType,
                &amp;node.Content,
                &amp;node.ContentType,
                &amp;node.SizeBytes,
                &amp;createdAt,
                &amp;updatedAt,
        ); err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov8" title="1">if parentID.Valid </span><span class="cov8" title="1">{
                node.ParentID = parentID.String
        }</span>
        <span class="cov8" title="1">node.CreatedAt = createdAt.UTC().Format(time.RFC3339Nano)
        node.UpdatedAt = updatedAt.UTC().Format(time.RFC3339Nano)
        return &amp;node, nil</span>
}

func (p *PostgresStore) CreateContextFolder(ctx context.Context, node store.ContextNode) error <span class="cov8" title="1">{
        const query = `
                INSERT INTO context_nodes (id, parent_id, name, node_type, content, content_type, size_bytes, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        `
        var parentID any
        if node.ParentID == "" </span><span class="cov8" title="1">{
                parentID = nil
        }</span> else<span class="cov8" title="1"> {
                parentID = node.ParentID
        }</span>
        <span class="cov8" title="1">_, err := p.db.ExecContext(
                ctx,
                query,
                node.ID,
                parentID,
                node.Name,
                node.NodeType,
                node.Content,
                node.ContentType,
                node.SizeBytes,
                node.CreatedAt,
                node.UpdatedAt,
        )
        return err</span>
}

func (p *PostgresStore) CreateContextFile(ctx context.Context, node store.ContextNode) error <span class="cov8" title="1">{
        return p.CreateContextFolder(ctx, node)
}</span>

func (p *PostgresStore) DeleteContextNode(ctx context.Context, nodeID string) error <span class="cov8" title="1">{
        const query = `
                DELETE FROM context_nodes
                WHERE id = $1
        `
        _, err := p.db.ExecContext(ctx, query, nodeID)
        return err
}</span>

func (p *PostgresStore) GetMemorySettings(ctx context.Context) (*store.MemorySettings, error) <span class="cov8" title="1">{
        const query = `
                SELECT enabled, created_at, updated_at
                FROM memory_settings
                WHERE id = 1
        `
        var createdAt time.Time
        var updatedAt time.Time
        settings := store.MemorySettings{}
        if err := p.db.QueryRowContext(ctx, query).Scan(&amp;settings.Enabled, &amp;createdAt, &amp;updatedAt); err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov8" title="1">settings.CreatedAt = createdAt.UTC().Format(time.RFC3339Nano)
        settings.UpdatedAt = updatedAt.UTC().Format(time.RFC3339Nano)
        return &amp;settings, nil</span>
}

func (p *PostgresStore) UpsertMemorySettings(ctx context.Context, settings store.MemorySettings) error <span class="cov8" title="1">{
        const query = `
                INSERT INTO memory_settings (id, enabled, created_at, updated_at)
                VALUES (1, $1, $2, $3)
                ON CONFLICT (id)
                DO UPDATE SET enabled = EXCLUDED.enabled, updated_at = EXCLUDED.updated_at
        `
        _, err := p.db.ExecContext(ctx, query, settings.Enabled, settings.CreatedAt, settings.UpdatedAt)
        return err
}</span>

func (p *PostgresStore) UpsertMemoryEntry(ctx context.Context, entry store.MemoryEntry) (bool, error) <span class="cov8" title="1">{
        metadata := entry.Metadata
        if metadata == nil </span><span class="cov0" title="0">{
                metadata = map[string]any{}
        }</span>
        <span class="cov8" title="1">encoded, err := json.Marshal(metadata)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">fingerprint := readMetadataString(metadata, "fingerprint")
        if fingerprint == "" </span><span class="cov0" title="0">{
                return p.insertMemoryEntry(ctx, entry, encoded)
        }</span>
        <span class="cov8" title="1">return p.insertMemoryEntryWithFingerprint(ctx, entry, encoded, fingerprint)</span>
}

func (p *PostgresStore) GetPersonalitySettings(ctx context.Context) (*store.PersonalitySettings, error) <span class="cov8" title="1">{
        const query = `
                SELECT content, created_at, updated_at
                FROM personality_settings
                WHERE id = 1
        `
        settings := store.PersonalitySettings{}
        var createdAt time.Time
        var updatedAt time.Time
        if err := p.db.QueryRowContext(ctx, query).Scan(&amp;settings.Content, &amp;createdAt, &amp;updatedAt); err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">settings.CreatedAt = createdAt.UTC().Format(time.RFC3339Nano)
        settings.UpdatedAt = updatedAt.UTC().Format(time.RFC3339Nano)
        return &amp;settings, nil</span>
}

func (p *PostgresStore) UpsertPersonalitySettings(ctx context.Context, settings store.PersonalitySettings) error <span class="cov8" title="1">{
        const query = `
                INSERT INTO personality_settings (id, content, created_at, updated_at)
                VALUES (1, $1, $2, $3)
                ON CONFLICT (id)
                DO UPDATE SET content = EXCLUDED.content, updated_at = EXCLUDED.updated_at
        `
        _, err := p.db.ExecContext(ctx, query, settings.Content, settings.CreatedAt, settings.UpdatedAt)
        return err
}</span>

func (p *PostgresStore) SearchMemory(ctx context.Context, query string, limit int) ([]store.MemoryEntry, error) <span class="cov8" title="1">{
        if strings.TrimSpace(query) == "" || limit &lt;= 0 </span><span class="cov8" title="1">{
                return []store.MemoryEntry{}, nil
        }</span>
        <span class="cov8" title="1">const sqlQuery = `
                SELECT id, content, metadata, created_at, updated_at
                FROM memory_entries
                WHERE tsv @@ plainto_tsquery('english', $1)
                ORDER BY ts_rank_cd(tsv, plainto_tsquery('english', $1)) DESC, updated_at DESC
                LIMIT $2
        `
        rows, err := p.db.QueryContext(ctx, sqlQuery, query, limit)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        results := []store.MemoryEntry{}
        for rows.Next() </span><span class="cov8" title="1">{
                var createdAt time.Time
                var updatedAt time.Time
                var metadataBytes []byte
                var entry store.MemoryEntry
                if err := rows.Scan(&amp;entry.ID, &amp;entry.Content, &amp;metadataBytes, &amp;createdAt, &amp;updatedAt); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">entry.CreatedAt = createdAt.UTC().Format(time.RFC3339Nano)
                entry.UpdatedAt = updatedAt.UTC().Format(time.RFC3339Nano)
                if len(metadataBytes) &gt; 0 </span><span class="cov8" title="1">{
                        metadata := map[string]any{}
                        if err := json.Unmarshal(metadataBytes, &amp;metadata); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">entry.Metadata = metadata</span>
                } else<span class="cov8" title="1"> {
                        entry.Metadata = map[string]any{}
                }</span>
                <span class="cov8" title="1">results = append(results, entry)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return results, nil</span>
}

func (p *PostgresStore) SearchMemoryWithEmbedding(ctx context.Context, query string, embedding []float32, limit int) ([]store.MemoryEntry, error) <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                return []store.MemoryEntry{}, nil
        }</span>
        <span class="cov8" title="1">if len(embedding) == 0 || len(embedding) != memoryEmbeddingDimensions </span><span class="cov8" title="1">{
                return p.SearchMemory(ctx, query, limit)
        }</span>
        <span class="cov0" title="0">vector := formatVector(embedding)
        const sqlQuery = `
                SELECT id, content, metadata, created_at, updated_at
                FROM memory_entries
                WHERE embedding IS NOT NULL
                ORDER BY embedding &lt;=&gt; $1::vector
                LIMIT $2
        `
        rows, err := p.db.QueryContext(ctx, sqlQuery, vector, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        results := []store.MemoryEntry{}
        for rows.Next() </span><span class="cov0" title="0">{
                var createdAt time.Time
                var updatedAt time.Time
                var metadataBytes []byte
                var entry store.MemoryEntry
                if err := rows.Scan(&amp;entry.ID, &amp;entry.Content, &amp;metadataBytes, &amp;createdAt, &amp;updatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">entry.CreatedAt = createdAt.UTC().Format(time.RFC3339Nano)
                entry.UpdatedAt = updatedAt.UTC().Format(time.RFC3339Nano)
                if len(metadataBytes) &gt; 0 </span><span class="cov0" title="0">{
                        metadata := map[string]any{}
                        if err := json.Unmarshal(metadataBytes, &amp;metadata); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">entry.Metadata = metadata</span>
                } else<span class="cov0" title="0"> {
                        entry.Metadata = map[string]any{}
                }</span>
                <span class="cov0" title="0">results = append(results, entry)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                return p.SearchMemory(ctx, query, limit)
        }</span>
        <span class="cov0" title="0">return results, nil</span>
}

func (p *PostgresStore) AppendEvent(ctx context.Context, event store.RunEvent) error <span class="cov8" title="1">{
        event.Type = strings.ReplaceAll(strings.ToLower(strings.TrimSpace(event.Type)), "_", ".")
        payload := event.Payload
        if payload == nil </span><span class="cov8" title="1">{
                payload = map[string]any{}
        }</span>
        <span class="cov8" title="1">encoded, err := json.Marshal(payload)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">timestamp := event.Timestamp
        if timestamp == "" </span><span class="cov8" title="1">{
                timestamp = time.Now().UTC().Format(time.RFC3339Nano)
        }</span>
        <span class="cov8" title="1">timestampValue := parseTimestampValue(timestamp)
        traceID := strings.TrimSpace(event.TraceID)
        var traceIDValue any
        if traceID == "" </span><span class="cov8" title="1">{
                traceIDValue = nil
        }</span> else<span class="cov0" title="0"> if _, err := uuid.Parse(traceID); err != nil </span><span class="cov0" title="0">{
                traceIDValue = nil
        }</span> else<span class="cov0" title="0"> {
                traceIDValue = traceID
        }</span>
        <span class="cov8" title="1">const query = `
                INSERT INTO run_events (run_id, seq, type, timestamp, source, trace_id, payload)
                VALUES ($1, $2, $3, $4, $5, $6, $7)
        `
        tx, err := p.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        _ = tx.Rollback()
                }</span>
        }()

        <span class="cov8" title="1">if _, err = tx.ExecContext(ctx, query, event.RunID, event.Seq, event.Type, timestampValue, event.Source, traceIDValue, encoded); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if step, ok := store.BuildRunStepFromEvent(event); ok </span><span class="cov8" title="1">{
                if err = upsertRunStepTx(ctx, tx, step); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if err = applyRunStateUpdateTx(ctx, tx, event); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = tx.Commit()
        return err</span>
}

func (p *PostgresStore) ListEvents(ctx context.Context, runID string, afterSeq int64) ([]store.RunEvent, error) <span class="cov8" title="1">{
        const query = `
                SELECT run_id, seq, type, timestamp, source, trace_id, payload
                FROM run_events
                WHERE run_id = $1 AND seq &gt; $2
                ORDER BY seq ASC
        `
        rows, err := p.db.QueryContext(ctx, query, runID, afterSeq)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        results := []store.RunEvent{}
        for rows.Next() </span><span class="cov8" title="1">{
                var payloadBytes []byte
                var timestamp time.Time
                var traceID sql.NullString
                var event store.RunEvent
                if err := rows.Scan(&amp;event.RunID, &amp;event.Seq, &amp;event.Type, &amp;timestamp, &amp;event.Source, &amp;traceID, &amp;payloadBytes); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">event.Timestamp = timestamp.UTC().Format(time.RFC3339Nano)
                if traceID.Valid </span><span class="cov8" title="1">{
                        event.TraceID = traceID.String
                }</span>
                <span class="cov8" title="1">if len(payloadBytes) &gt; 0 </span><span class="cov8" title="1">{
                        payload := map[string]any{}
                        if err := json.Unmarshal(payloadBytes, &amp;payload); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">event.Payload = payload</span>
                } else<span class="cov8" title="1"> {
                        event.Payload = map[string]any{}
                }</span>
                <span class="cov8" title="1">results = append(results, event)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return results, nil</span>
}

func (p *PostgresStore) ListRunSteps(ctx context.Context, runID string) ([]store.RunStep, error) <span class="cov8" title="1">{
        const query = `
                SELECT run_id,
                        step_id,
                        parent_step_id,
                        name,
                        status,
                        plan_id,
                        attempt,
                        policy_decision,
                        dependencies,
                        expected_artifacts,
                        diagnostics,
                        started_at,
                        completed_at
                FROM run_steps
                WHERE run_id = $1
                ORDER BY COALESCE((diagnostics-&gt;&gt;'seq')::bigint, 9223372036854775807), created_at ASC
        `
        rows, err := p.db.QueryContext(ctx, query, runID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        steps := []store.RunStep{}
        for rows.Next() </span><span class="cov8" title="1">{
                var (
                        step              store.RunStep
                        parentStepID      sql.NullString
                        name              sql.NullString
                        planID            sql.NullString
                        policyDecision    sql.NullString
                        dependenciesBytes []byte
                        expectedBytes     []byte
                        diagnosticsBytes  []byte
                        startedAt         sql.NullTime
                        completedAt       sql.NullTime
                )
                if err := rows.Scan(
                        &amp;step.RunID,
                        &amp;step.ID,
                        &amp;parentStepID,
                        &amp;name,
                        &amp;step.Status,
                        &amp;planID,
                        &amp;step.Attempt,
                        &amp;policyDecision,
                        &amp;dependenciesBytes,
                        &amp;expectedBytes,
                        &amp;diagnosticsBytes,
                        &amp;startedAt,
                        &amp;completedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if parentStepID.Valid </span><span class="cov0" title="0">{
                        step.ParentStepID = parentStepID.String
                }</span>
                <span class="cov8" title="1">if name.Valid </span><span class="cov8" title="1">{
                        step.Name = name.String
                }</span>
                <span class="cov8" title="1">if planID.Valid </span><span class="cov0" title="0">{
                        step.PlanID = planID.String
                }</span>
                <span class="cov8" title="1">if policyDecision.Valid </span><span class="cov8" title="1">{
                        step.PolicyDecision = policyDecision.String
                }</span>
                <span class="cov8" title="1">if startedAt.Valid </span><span class="cov8" title="1">{
                        step.StartedAt = startedAt.Time.UTC().Format(time.RFC3339Nano)
                }</span>
                <span class="cov8" title="1">if completedAt.Valid </span><span class="cov8" title="1">{
                        step.CompletedAt = completedAt.Time.UTC().Format(time.RFC3339Nano)
                }</span>
                <span class="cov8" title="1">step.Dependencies = decodeStringSlice(dependenciesBytes)
                step.ExpectedArtifacts = decodeStringSlice(expectedBytes)
                step.Diagnostics = decodeJSONMap(diagnosticsBytes)
                step.Kind = readDiagString(step.Diagnostics, "kind")
                if step.Kind == "" </span><span class="cov0" title="0">{
                        step.Kind = "step"
                }</span>
                <span class="cov8" title="1">step.Source = readDiagString(step.Diagnostics, "source")
                step.Seq = readDiagInt64(step.Diagnostics, "seq")
                step.Error = readDiagString(step.Diagnostics, "error")
                if step.Name == "" </span><span class="cov0" title="0">{
                        step.Name = step.ID
                }</span>
                <span class="cov8" title="1">steps = append(steps, step)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return steps, nil</span>
}

func (p *PostgresStore) UpsertRunProcess(ctx context.Context, process store.RunProcess) error <span class="cov8" title="1">{
        if strings.TrimSpace(process.RunID) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("run id required")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(process.ProcessID) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("process id required")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(process.Command) == "" </span><span class="cov0" title="0">{
                process.Command = "process"
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(process.Status) == "" </span><span class="cov0" title="0">{
                process.Status = "running"
        }</span>
        <span class="cov8" title="1">argsBytes, err := json.Marshal(process.Args)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">previewBytes, err := json.Marshal(process.PreviewURLs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">metadata := process.Metadata
        if metadata == nil </span><span class="cov0" title="0">{
                metadata = map[string]any{}
        }</span>
        <span class="cov8" title="1">metadataBytes, err := json.Marshal(metadata)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">query := `
                INSERT INTO run_processes (
                        run_id,
                        process_id,
                        command,
                        args,
                        cwd,
                        status,
                        pid,
                        started_at,
                        ended_at,
                        exit_code,
                        signal,
                        preview_urls,
                        metadata
                ) VALUES ($1, $2, $3, $4::jsonb, $5, $6, $7, $8, $9, $10, $11, $12::jsonb, $13::jsonb)
                ON CONFLICT (run_id, process_id)
                DO UPDATE SET
                        command = COALESCE(NULLIF(EXCLUDED.command, ''), run_processes.command),
                        args = CASE
                                WHEN jsonb_typeof(EXCLUDED.args) = 'array' AND jsonb_array_length(EXCLUDED.args) &gt; 0 THEN EXCLUDED.args
                                ELSE run_processes.args
                        END,
                        cwd = COALESCE(NULLIF(EXCLUDED.cwd, ''), run_processes.cwd),
                        status = COALESCE(NULLIF(EXCLUDED.status, ''), run_processes.status),
                        pid = CASE WHEN EXCLUDED.pid &gt; 0 THEN EXCLUDED.pid ELSE run_processes.pid END,
                        started_at = COALESCE(run_processes.started_at, EXCLUDED.started_at),
                        ended_at = COALESCE(EXCLUDED.ended_at, run_processes.ended_at),
                        exit_code = COALESCE(EXCLUDED.exit_code, run_processes.exit_code),
                        signal = COALESCE(NULLIF(EXCLUDED.signal, ''), run_processes.signal),
                        preview_urls = CASE
                                WHEN jsonb_typeof(EXCLUDED.preview_urls) = 'array' AND jsonb_array_length(EXCLUDED.preview_urls) &gt; 0
                                        THEN EXCLUDED.preview_urls
                                ELSE run_processes.preview_urls
                        END,
                        metadata = run_processes.metadata || EXCLUDED.metadata
        `
        _, err = p.db.ExecContext(
                ctx,
                query,
                process.RunID,
                process.ProcessID,
                process.Command,
                argsBytes,
                nullString(process.Cwd),
                process.Status,
                process.PID,
                parseTimestampNull(process.StartedAt),
                parseTimestampNull(process.EndedAt),
                intPtrValue(process.ExitCode),
                nullString(process.Signal),
                previewBytes,
                metadataBytes,
        )
        return err</span>
}

func (p *PostgresStore) GetRunProcess(ctx context.Context, runID string, processID string) (*store.RunProcess, error) <span class="cov8" title="1">{
        const query = `
                SELECT run_id,
                        process_id,
                        command,
                        args,
                        cwd,
                        status,
                        pid,
                        started_at,
                        ended_at,
                        exit_code,
                        signal,
                        preview_urls,
                        metadata
                FROM run_processes
                WHERE run_id = $1 AND process_id = $2
        `
        processes, err := p.queryRunProcesses(ctx, query, runID, processID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(processes) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return &amp;processes[0], nil</span>
}

func (p *PostgresStore) ListRunProcesses(ctx context.Context, runID string) ([]store.RunProcess, error) <span class="cov8" title="1">{
        const query = `
                SELECT run_id,
                        process_id,
                        command,
                        args,
                        cwd,
                        status,
                        pid,
                        started_at,
                        ended_at,
                        exit_code,
                        signal,
                        preview_urls,
                        metadata
                FROM run_processes
                WHERE run_id = $1
                ORDER BY started_at DESC, process_id ASC
        `
        return p.queryRunProcesses(ctx, query, runID)
}</span>

func (p *PostgresStore) NextSeq(ctx context.Context, runID string) (int64, error) <span class="cov8" title="1">{
        const query = `
                INSERT INTO run_event_sequences (run_id, last_seq)
                VALUES ($1, 1)
                ON CONFLICT (run_id)
                DO UPDATE SET last_seq = run_event_sequences.last_seq + 1
                RETURNING last_seq
        `
        var seq int64
        if err := p.db.QueryRowContext(ctx, query, runID).Scan(&amp;seq); err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return seq, nil</span>
}

func (p *PostgresStore) UpsertArtifact(ctx context.Context, artifact store.Artifact) error <span class="cov8" title="1">{
        metadata := artifact.Metadata
        if metadata == nil </span><span class="cov0" title="0">{
                metadata = map[string]any{}
        }</span>
        <span class="cov8" title="1">encoded, err := json.Marshal(metadata)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">labelsBytes, err := json.Marshal(artifact.Labels)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">category := strings.TrimSpace(artifact.Category)
        if category == "" </span><span class="cov8" title="1">{
                category = "generic"
        }</span>
        <span class="cov8" title="1">retentionClass := strings.TrimSpace(artifact.RetentionClass)
        if retentionClass == "" </span><span class="cov8" title="1">{
                retentionClass = "default"
        }</span>
        <span class="cov8" title="1">const query = `
                INSERT INTO artifacts (
                        id,
                        run_id,
                        type,
                        category,
                        uri,
                        content_type,
                        size_bytes,
                        checksum,
                        labels,
                        searchable_text,
                        retention_class,
                        created_at,
                        metadata
                )
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9::jsonb, $10, $11, $12, $13)
                ON CONFLICT (id)
                DO UPDATE SET
                        type = EXCLUDED.type,
                        category = EXCLUDED.category,
                        uri = EXCLUDED.uri,
                        content_type = EXCLUDED.content_type,
                        size_bytes = EXCLUDED.size_bytes,
                        checksum = EXCLUDED.checksum,
                        labels = EXCLUDED.labels,
                        searchable_text = EXCLUDED.searchable_text,
                        retention_class = EXCLUDED.retention_class,
                        metadata = EXCLUDED.metadata,
                        created_at = EXCLUDED.created_at
        `
        _, err = p.db.ExecContext(
                ctx,
                query,
                artifact.ID,
                artifact.RunID,
                artifact.Type,
                category,
                artifact.URI,
                artifact.ContentType,
                artifact.SizeBytes,
                nullString(artifact.Checksum),
                labelsBytes,
                nullString(artifact.SearchableText),
                retentionClass,
                artifact.CreatedAt,
                encoded,
        )
        return err</span>
}

func (p *PostgresStore) ListArtifacts(ctx context.Context, runID string) ([]store.Artifact, error) <span class="cov8" title="1">{
        const query = `
                SELECT id, run_id, type, category, uri, content_type, size_bytes, checksum, labels, searchable_text, retention_class, created_at, metadata
                FROM artifacts
                WHERE run_id = $1
                ORDER BY created_at ASC
        `
        rows, err := p.db.QueryContext(ctx, query, runID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        results := []store.Artifact{}
        for rows.Next() </span><span class="cov8" title="1">{
                var createdAt time.Time
                var category sql.NullString
                var checksum sql.NullString
                var searchableText sql.NullString
                var retentionClass sql.NullString
                var labelsBytes []byte
                var metadataBytes []byte
                var artifact store.Artifact
                if err := rows.Scan(
                        &amp;artifact.ID,
                        &amp;artifact.RunID,
                        &amp;artifact.Type,
                        &amp;category,
                        &amp;artifact.URI,
                        &amp;artifact.ContentType,
                        &amp;artifact.SizeBytes,
                        &amp;checksum,
                        &amp;labelsBytes,
                        &amp;searchableText,
                        &amp;retentionClass,
                        &amp;createdAt,
                        &amp;metadataBytes,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if category.Valid </span><span class="cov8" title="1">{
                        artifact.Category = category.String
                }</span>
                <span class="cov8" title="1">if checksum.Valid </span><span class="cov0" title="0">{
                        artifact.Checksum = checksum.String
                }</span>
                <span class="cov8" title="1">artifact.Labels = decodeStringSlice(labelsBytes)
                if searchableText.Valid </span><span class="cov0" title="0">{
                        artifact.SearchableText = searchableText.String
                }</span>
                <span class="cov8" title="1">if retentionClass.Valid </span><span class="cov8" title="1">{
                        artifact.RetentionClass = retentionClass.String
                }</span>
                <span class="cov8" title="1">artifact.CreatedAt = createdAt.UTC().Format(time.RFC3339Nano)
                if len(metadataBytes) &gt; 0 </span><span class="cov8" title="1">{
                        metadata := map[string]any{}
                        if err := json.Unmarshal(metadataBytes, &amp;metadata); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">artifact.Metadata = metadata</span>
                } else<span class="cov0" title="0"> {
                        artifact.Metadata = map[string]any{}
                }</span>
                <span class="cov8" title="1">results = append(results, artifact)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return results, nil</span>
}

func (p *PostgresStore) ListAutomations(ctx context.Context) ([]store.Automation, error) <span class="cov0" title="0">{
        const query = `
                SELECT id, name, prompt, model, days, time_of_day, timezone, enabled, next_run_at, last_run_at, in_progress, created_at, updated_at
                FROM automations
                ORDER BY updated_at DESC
        `
        rows, err := p.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        results := make([]store.Automation, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        item      store.Automation
                        daysBytes []byte
                        nextRunAt sql.NullTime
                        lastRunAt sql.NullTime
                        createdAt time.Time
                        updatedAt time.Time
                )
                if err := rows.Scan(
                        &amp;item.ID,
                        &amp;item.Name,
                        &amp;item.Prompt,
                        &amp;item.Model,
                        &amp;daysBytes,
                        &amp;item.TimeOfDay,
                        &amp;item.Timezone,
                        &amp;item.Enabled,
                        &amp;nextRunAt,
                        &amp;lastRunAt,
                        &amp;item.InProgress,
                        &amp;createdAt,
                        &amp;updatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">item.Days = decodeStringSlice(daysBytes)
                if nextRunAt.Valid </span><span class="cov0" title="0">{
                        item.NextRunAt = nextRunAt.Time.UTC().Format(time.RFC3339Nano)
                }</span>
                <span class="cov0" title="0">if lastRunAt.Valid </span><span class="cov0" title="0">{
                        item.LastRunAt = lastRunAt.Time.UTC().Format(time.RFC3339Nano)
                }</span>
                <span class="cov0" title="0">item.CreatedAt = createdAt.UTC().Format(time.RFC3339Nano)
                item.UpdatedAt = updatedAt.UTC().Format(time.RFC3339Nano)
                results = append(results, item)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return results, nil</span>
}

func (p *PostgresStore) GetAutomation(ctx context.Context, automationID string) (*store.Automation, error) <span class="cov0" title="0">{
        const query = `
                SELECT id, name, prompt, model, days, time_of_day, timezone, enabled, next_run_at, last_run_at, in_progress, created_at, updated_at
                FROM automations
                WHERE id = $1
        `
        var (
                item      store.Automation
                daysBytes []byte
                nextRunAt sql.NullTime
                lastRunAt sql.NullTime
                createdAt time.Time
                updatedAt time.Time
        )
        if err := p.db.QueryRowContext(ctx, query, automationID).Scan(
                &amp;item.ID,
                &amp;item.Name,
                &amp;item.Prompt,
                &amp;item.Model,
                &amp;daysBytes,
                &amp;item.TimeOfDay,
                &amp;item.Timezone,
                &amp;item.Enabled,
                &amp;nextRunAt,
                &amp;lastRunAt,
                &amp;item.InProgress,
                &amp;createdAt,
                &amp;updatedAt,
        ); err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">item.Days = decodeStringSlice(daysBytes)
        if nextRunAt.Valid </span><span class="cov0" title="0">{
                item.NextRunAt = nextRunAt.Time.UTC().Format(time.RFC3339Nano)
        }</span>
        <span class="cov0" title="0">if lastRunAt.Valid </span><span class="cov0" title="0">{
                item.LastRunAt = lastRunAt.Time.UTC().Format(time.RFC3339Nano)
        }</span>
        <span class="cov0" title="0">item.CreatedAt = createdAt.UTC().Format(time.RFC3339Nano)
        item.UpdatedAt = updatedAt.UTC().Format(time.RFC3339Nano)
        return &amp;item, nil</span>
}

func (p *PostgresStore) CreateAutomation(ctx context.Context, automation store.Automation) error <span class="cov0" title="0">{
        daysBytes, err := json.Marshal(automation.Days)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">const query = `
                INSERT INTO automations (
                        id, name, prompt, model, days, time_of_day, timezone, enabled, next_run_at, last_run_at, in_progress, created_at, updated_at
                ) VALUES (
                        $1, $2, $3, $4, $5::jsonb, $6, $7, $8, $9, $10, $11, $12, $13
                )
        `
        _, err = p.db.ExecContext(
                ctx,
                query,
                automation.ID,
                automation.Name,
                automation.Prompt,
                automation.Model,
                daysBytes,
                automation.TimeOfDay,
                automation.Timezone,
                automation.Enabled,
                parseTimestampNull(automation.NextRunAt),
                parseTimestampNull(automation.LastRunAt),
                automation.InProgress,
                parseTimestampValue(automation.CreatedAt),
                parseTimestampValue(automation.UpdatedAt),
        )
        return err</span>
}

func (p *PostgresStore) UpdateAutomation(ctx context.Context, automation store.Automation) error <span class="cov0" title="0">{
        daysBytes, err := json.Marshal(automation.Days)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">const query = `
                UPDATE automations
                SET
                        name = $2,
                        prompt = $3,
                        model = $4,
                        days = $5::jsonb,
                        time_of_day = $6,
                        timezone = $7,
                        enabled = $8,
                        next_run_at = $9,
                        last_run_at = $10,
                        in_progress = $11,
                        updated_at = $12
                WHERE id = $1
        `
        _, err = p.db.ExecContext(
                ctx,
                query,
                automation.ID,
                automation.Name,
                automation.Prompt,
                automation.Model,
                daysBytes,
                automation.TimeOfDay,
                automation.Timezone,
                automation.Enabled,
                parseTimestampNull(automation.NextRunAt),
                parseTimestampNull(automation.LastRunAt),
                automation.InProgress,
                parseTimestampValue(automation.UpdatedAt),
        )
        return err</span>
}

func (p *PostgresStore) DeleteAutomation(ctx context.Context, automationID string) error <span class="cov0" title="0">{
        _, err := p.db.ExecContext(ctx, "DELETE FROM automations WHERE id = $1", automationID)
        return err
}</span>

func (p *PostgresStore) ListAutomationInbox(ctx context.Context, automationID string) ([]store.AutomationInboxEntry, error) <span class="cov0" title="0">{
        const query = `
                SELECT id, automation_id, run_id, status, phase, completion_reason, final_response, timed_out, error, unread, trigger, started_at, completed_at, diagnostics, created_at, updated_at
                FROM automation_inbox
                WHERE automation_id = $1
                ORDER BY started_at DESC, created_at DESC
        `
        rows, err := p.db.QueryContext(ctx, query, automationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        results := make([]store.AutomationInboxEntry, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                var (
                        entry            store.AutomationInboxEntry
                        runID            sql.NullString
                        phase            sql.NullString
                        completionReason sql.NullString
                        finalResponse    sql.NullString
                        errorValue       sql.NullString
                        completedAt      sql.NullTime
                        diagnosticsBytes []byte
                        createdAt        time.Time
                        updatedAt        time.Time
                        startedAt        time.Time
                )
                if err := rows.Scan(
                        &amp;entry.ID,
                        &amp;entry.AutomationID,
                        &amp;runID,
                        &amp;entry.Status,
                        &amp;phase,
                        &amp;completionReason,
                        &amp;finalResponse,
                        &amp;entry.TimedOut,
                        &amp;errorValue,
                        &amp;entry.Unread,
                        &amp;entry.Trigger,
                        &amp;startedAt,
                        &amp;completedAt,
                        &amp;diagnosticsBytes,
                        &amp;createdAt,
                        &amp;updatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if runID.Valid </span><span class="cov0" title="0">{
                        entry.RunID = runID.String
                }</span>
                <span class="cov0" title="0">if phase.Valid </span><span class="cov0" title="0">{
                        entry.Phase = phase.String
                }</span>
                <span class="cov0" title="0">if completionReason.Valid </span><span class="cov0" title="0">{
                        entry.CompletionReason = completionReason.String
                }</span>
                <span class="cov0" title="0">if finalResponse.Valid </span><span class="cov0" title="0">{
                        entry.FinalResponse = finalResponse.String
                }</span>
                <span class="cov0" title="0">if errorValue.Valid </span><span class="cov0" title="0">{
                        entry.Error = errorValue.String
                }</span>
                <span class="cov0" title="0">entry.StartedAt = startedAt.UTC().Format(time.RFC3339Nano)
                if completedAt.Valid </span><span class="cov0" title="0">{
                        entry.CompletedAt = completedAt.Time.UTC().Format(time.RFC3339Nano)
                }</span>
                <span class="cov0" title="0">entry.Diagnostics = decodeJSONMap(diagnosticsBytes)
                entry.CreatedAt = createdAt.UTC().Format(time.RFC3339Nano)
                entry.UpdatedAt = updatedAt.UTC().Format(time.RFC3339Nano)
                results = append(results, entry)</span>
        }
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return results, nil</span>
}

func (p *PostgresStore) CreateAutomationInboxEntry(ctx context.Context, entry store.AutomationInboxEntry) error <span class="cov0" title="0">{
        diagnostics := entry.Diagnostics
        if diagnostics == nil </span><span class="cov0" title="0">{
                diagnostics = map[string]any{}
        }</span>
        <span class="cov0" title="0">encoded, err := json.Marshal(diagnostics)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">const query = `
                INSERT INTO automation_inbox (
                        id, automation_id, run_id, status, phase, completion_reason, final_response, timed_out, error, unread, trigger, started_at, completed_at, diagnostics, created_at, updated_at
                ) VALUES (
                        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14::jsonb, $15, $16
                )
        `
        _, err = p.db.ExecContext(
                ctx,
                query,
                entry.ID,
                entry.AutomationID,
                nullString(entry.RunID),
                entry.Status,
                nullString(entry.Phase),
                nullString(entry.CompletionReason),
                nullString(entry.FinalResponse),
                entry.TimedOut,
                nullString(entry.Error),
                entry.Unread,
                entry.Trigger,
                parseTimestampValue(entry.StartedAt),
                parseTimestampNull(entry.CompletedAt),
                encoded,
                parseTimestampValue(entry.CreatedAt),
                parseTimestampValue(entry.UpdatedAt),
        )
        return err</span>
}

func (p *PostgresStore) UpdateAutomationInboxEntry(ctx context.Context, entry store.AutomationInboxEntry) error <span class="cov0" title="0">{
        diagnostics := entry.Diagnostics
        if diagnostics == nil </span><span class="cov0" title="0">{
                diagnostics = map[string]any{}
        }</span>
        <span class="cov0" title="0">encoded, err := json.Marshal(diagnostics)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">const query = `
                UPDATE automation_inbox
                SET
                        run_id = $3,
                        status = $4,
                        phase = $5,
                        completion_reason = $6,
                        final_response = $7,
                        timed_out = $8,
                        error = $9,
                        unread = $10,
                        trigger = $11,
                        started_at = $12,
                        completed_at = $13,
                        diagnostics = $14::jsonb,
                        updated_at = $15
                WHERE automation_id = $1 AND id = $2
        `
        _, err = p.db.ExecContext(
                ctx,
                query,
                entry.AutomationID,
                entry.ID,
                nullString(entry.RunID),
                entry.Status,
                nullString(entry.Phase),
                nullString(entry.CompletionReason),
                nullString(entry.FinalResponse),
                entry.TimedOut,
                nullString(entry.Error),
                entry.Unread,
                entry.Trigger,
                parseTimestampValue(entry.StartedAt),
                parseTimestampNull(entry.CompletedAt),
                encoded,
                parseTimestampValue(entry.UpdatedAt),
        )
        return err</span>
}

func (p *PostgresStore) MarkAutomationInboxEntryRead(ctx context.Context, automationID string, entryID string) error <span class="cov0" title="0">{
        _, err := p.db.ExecContext(
                ctx,
                `UPDATE automation_inbox SET unread = FALSE, updated_at = NOW() WHERE automation_id = $1 AND id = $2`,
                automationID,
                entryID,
        )
        return err
}</span>

func (p *PostgresStore) MarkAutomationInboxReadAll(ctx context.Context, automationID string) error <span class="cov0" title="0">{
        _, err := p.db.ExecContext(
                ctx,
                `UPDATE automation_inbox SET unread = FALSE, updated_at = NOW() WHERE automation_id = $1`,
                automationID,
        )
        return err
}</span>

func (p *PostgresStore) insertMemoryEntry(ctx context.Context, entry store.MemoryEntry, metadata []byte) (bool, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO memory_entries (id, content, metadata, embedding, created_at, updated_at)
                VALUES ($1, $2, $3, NULL, $4, $5)
        `
        params := []any{entry.ID, entry.Content, metadata, entry.CreatedAt, entry.UpdatedAt}
        if len(entry.Embedding) == memoryEmbeddingDimensions </span><span class="cov0" title="0">{
                query = `
                        INSERT INTO memory_entries (id, content, metadata, embedding, created_at, updated_at)
                        VALUES ($1, $2, $3, $4::vector, $5, $6)
                `
                params = []any{entry.ID, entry.Content, metadata, formatVector(entry.Embedding), entry.CreatedAt, entry.UpdatedAt}
        }</span>
        <span class="cov0" title="0">if _, err := p.db.ExecContext(ctx, query, params...); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (p *PostgresStore) insertMemoryEntryWithFingerprint(ctx context.Context, entry store.MemoryEntry, metadata []byte, fingerprint string) (bool, error) <span class="cov8" title="1">{
        query := `
                WITH inserted AS (
                        INSERT INTO memory_entries (id, content, metadata, embedding, created_at, updated_at)
                        SELECT $1, $2, $3, NULL, $4, $5
                        WHERE NOT EXISTS (
                                SELECT 1 FROM memory_entries WHERE metadata-&gt;&gt;'fingerprint' = $6
                        )
                        RETURNING id
                )
                SELECT COUNT(*) FROM inserted
        `
        params := []any{entry.ID, entry.Content, metadata, entry.CreatedAt, entry.UpdatedAt, fingerprint}
        if len(entry.Embedding) == memoryEmbeddingDimensions </span><span class="cov0" title="0">{
                query = `
                        WITH inserted AS (
                                INSERT INTO memory_entries (id, content, metadata, embedding, created_at, updated_at)
                                SELECT $1, $2, $3, $4::vector, $5, $6
                                WHERE NOT EXISTS (
                                        SELECT 1 FROM memory_entries WHERE metadata-&gt;&gt;'fingerprint' = $7
                                )
                                RETURNING id
                        )
                        SELECT COUNT(*) FROM inserted
                `
                params = []any{entry.ID, entry.Content, metadata, formatVector(entry.Embedding), entry.CreatedAt, entry.UpdatedAt, fingerprint}
        }</span>
        <span class="cov8" title="1">var insertedCount int
        if err := p.db.QueryRowContext(ctx, query, params...).Scan(&amp;insertedCount); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return insertedCount &gt; 0, nil</span>
}

func upsertRunStepTx(ctx context.Context, tx *sql.Tx, step store.RunStep) error <span class="cov8" title="1">{
        if strings.TrimSpace(step.RunID) == "" || strings.TrimSpace(step.ID) == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(step.Name) == "" </span><span class="cov0" title="0">{
                step.Name = step.ID
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(step.Kind) == "" </span><span class="cov0" title="0">{
                step.Kind = "step"
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(step.Status) == "" </span><span class="cov0" title="0">{
                step.Status = "running"
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(step.PolicyDecision) == "" </span><span class="cov8" title="1">{
                step.PolicyDecision = "unknown"
        }</span>
        <span class="cov8" title="1">diagnostics := step.Diagnostics
        if diagnostics == nil </span><span class="cov0" title="0">{
                diagnostics = map[string]any{}
        }</span>
        <span class="cov8" title="1">diagnostics["kind"] = step.Kind
        if step.Source != "" </span><span class="cov8" title="1">{
                diagnostics["source"] = step.Source
        }</span>
        <span class="cov8" title="1">if step.Seq &gt; 0 </span><span class="cov8" title="1">{
                diagnostics["seq"] = step.Seq
        }</span>
        <span class="cov8" title="1">if step.Error != "" </span><span class="cov8" title="1">{
                diagnostics["error"] = step.Error
        }</span>
        <span class="cov8" title="1">if step.PlanID != "" </span><span class="cov0" title="0">{
                diagnostics["plan_id"] = step.PlanID
        }</span>
        <span class="cov8" title="1">if step.Attempt &gt; 0 </span><span class="cov0" title="0">{
                diagnostics["attempt"] = step.Attempt
        }</span>
        <span class="cov8" title="1">if step.PolicyDecision != "" </span><span class="cov8" title="1">{
                diagnostics["policy_decision"] = step.PolicyDecision
        }</span>
        <span class="cov8" title="1">dependenciesBytes, err := json.Marshal(step.Dependencies)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">expectedArtifactsBytes, err := json.Marshal(step.ExpectedArtifacts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">diagnosticsBytes, err := json.Marshal(diagnostics)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">query := `
                INSERT INTO run_steps (
                        run_id,
                        step_id,
                        parent_step_id,
                        name,
                        status,
                        plan_id,
                        attempt,
                        policy_decision,
                        dependencies,
                        expected_artifacts,
                        diagnostics,
                        started_at,
                        completed_at,
                        created_at,
                        updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9::jsonb, $10::jsonb, $11::jsonb, $12, $13, NOW(), NOW())
                ON CONFLICT (run_id, step_id)
                DO UPDATE SET
                        parent_step_id = COALESCE(run_steps.parent_step_id, EXCLUDED.parent_step_id),
                        name = COALESCE(NULLIF(EXCLUDED.name, ''), run_steps.name),
                        status = EXCLUDED.status,
                        plan_id = COALESCE(NULLIF(EXCLUDED.plan_id, ''), run_steps.plan_id),
                        attempt = CASE WHEN EXCLUDED.attempt &gt; 0 THEN EXCLUDED.attempt ELSE run_steps.attempt END,
                        policy_decision = COALESCE(NULLIF(EXCLUDED.policy_decision, ''), run_steps.policy_decision),
                        dependencies = CASE
                                WHEN jsonb_typeof(EXCLUDED.dependencies) = 'array' AND jsonb_array_length(EXCLUDED.dependencies) &gt; 0 THEN EXCLUDED.dependencies
                                ELSE run_steps.dependencies
                        END,
                        expected_artifacts = CASE
                                WHEN jsonb_typeof(EXCLUDED.expected_artifacts) = 'array' AND jsonb_array_length(EXCLUDED.expected_artifacts) &gt; 0 THEN EXCLUDED.expected_artifacts
                                ELSE run_steps.expected_artifacts
                        END,
                        diagnostics = run_steps.diagnostics || EXCLUDED.diagnostics,
                        started_at = COALESCE(run_steps.started_at, EXCLUDED.started_at),
                        completed_at = COALESCE(EXCLUDED.completed_at, run_steps.completed_at),
                        updated_at = NOW()
        `
        _, err = tx.ExecContext(
                ctx,
                query,
                step.RunID,
                step.ID,
                nullString(step.ParentStepID),
                step.Name,
                step.Status,
                nullString(step.PlanID),
                step.Attempt,
                nullString(step.PolicyDecision),
                dependenciesBytes,
                expectedArtifactsBytes,
                diagnosticsBytes,
                parseTimestampNull(step.StartedAt),
                parseTimestampNull(step.CompletedAt),
        )
        return err</span>
}

func applyRunStateUpdateTx(ctx context.Context, tx *sql.Tx, event store.RunEvent) error <span class="cov8" title="1">{
        eventType := strings.ReplaceAll(strings.ToLower(strings.TrimSpace(event.Type)), "_", ".")
        if eventType == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">phase := ""
        status := ""
        completionReason := ""
        resumedFrom := ""

        switch eventType </span>{
        case "run.started":<span class="cov8" title="1">
                status = "running"
                phase = "planning"</span>
        case "run.phase.changed":<span class="cov0" title="0">
                phase = readDiagString(event.Payload, "phase")</span>
        case "run.completed":<span class="cov0" title="0">
                status = "completed"
                phase = "completed"
                completionReason = readDiagString(event.Payload, "completion_reason")</span>
        case "run.partial":<span class="cov0" title="0">
                status = "partial"
                phase = "completed"
                completionReason = readDiagString(event.Payload, "completion_reason")</span>
        case "run.failed":<span class="cov0" title="0">
                status = "failed"
                phase = "failed"
                completionReason = readDiagString(event.Payload, "completion_reason")
                if completionReason == "" </span><span class="cov0" title="0">{
                        completionReason = "activity_error"
                }</span>
        case "run.cancelled":<span class="cov0" title="0">
                status = "cancelled"
                phase = "cancelled"
                completionReason = "user_cancelled"</span>
        case "run.resumed":<span class="cov0" title="0">
                status = "running"
                phase = "planning"
                resumedFrom = readDiagString(event.Payload, "resumed_from")</span>
        default:<span class="cov8" title="1">
                return nil</span>
        }

        <span class="cov8" title="1">query := `
                UPDATE runs
                SET
                        status = COALESCE(NULLIF($2, ''), status),
                        phase = COALESCE(NULLIF($3, ''), phase),
                        completion_reason = CASE
                                WHEN NULLIF($4, '') IS NOT NULL THEN $4
                                ELSE completion_reason
                        END,
                        resumed_from = CASE
                                WHEN NULLIF($5, '') IS NOT NULL THEN $5::uuid
                                ELSE resumed_from
                        END,
                        checkpoint_seq = GREATEST(checkpoint_seq, $6),
                        updated_at = $7
                WHERE id = $1
        `
        _, err := tx.ExecContext(
                ctx,
                query,
                event.RunID,
                status,
                phase,
                nullString(completionReason),
                nullString(resumedFrom),
                event.Seq,
                parseTimestampValue(event.Timestamp),
        )
        return err</span>
}

func parseTimestampValue(value string) time.Time <span class="cov8" title="1">{
        parsed, err := time.Parse(time.RFC3339Nano, strings.TrimSpace(value))
        if err != nil </span><span class="cov8" title="1">{
                return time.Now().UTC()
        }</span>
        <span class="cov8" title="1">return parsed.UTC()</span>
}

func parseTimestampNull(value string) any <span class="cov8" title="1">{
        value = strings.TrimSpace(value)
        if value == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">parsed, err := time.Parse(time.RFC3339Nano, value)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return parsed.UTC()</span>
}

func nullString(value string) any <span class="cov8" title="1">{
        value = strings.TrimSpace(value)
        if value == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return value</span>
}

func decodeStringSlice(raw []byte) []string <span class="cov8" title="1">{
        if len(raw) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">values := []string{}
        if err := json.Unmarshal(raw, &amp;values); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if len(values) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return values</span>
}

func decodeJSONMap(raw []byte) map[string]any <span class="cov8" title="1">{
        if len(raw) == 0 </span><span class="cov0" title="0">{
                return map[string]any{}
        }</span>
        <span class="cov8" title="1">payload := map[string]any{}
        if err := json.Unmarshal(raw, &amp;payload); err != nil </span><span class="cov0" title="0">{
                return map[string]any{}
        }</span>
        <span class="cov8" title="1">return payload</span>
}

func readDiagString(payload map[string]any, key string) string <span class="cov8" title="1">{
        if payload == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">value, ok := payload[key]
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">text, ok := value.(string)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(text)</span>
}

func readDiagInt64(payload map[string]any, key string) int64 <span class="cov8" title="1">{
        if payload == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">value, ok := payload[key]
        if !ok </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">switch typed := value.(type) </span>{
        case float64:<span class="cov8" title="1">
                return int64(typed)</span>
        case int64:<span class="cov0" title="0">
                return typed</span>
        case int:<span class="cov0" title="0">
                return int64(typed)</span>
        case json.Number:<span class="cov0" title="0">
                parsed, err := typed.Int64()
                if err == nil </span><span class="cov0" title="0">{
                        return parsed
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func intPtrValue(value *int) any <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return *value</span>
}

func (p *PostgresStore) queryRunProcesses(ctx context.Context, query string, args ...any) ([]store.RunProcess, error) <span class="cov8" title="1">{
        rows, err := p.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        results := []store.RunProcess{}
        for rows.Next() </span><span class="cov8" title="1">{
                var (
                        process      store.RunProcess
                        argsBytes    []byte
                        previewBytes []byte
                        metaBytes    []byte
                        cwd          sql.NullString
                        status       sql.NullString
                        pid          sql.NullInt64
                        startedAt    sql.NullTime
                        endedAt      sql.NullTime
                        exitCode     sql.NullInt64
                        signal       sql.NullString
                )
                if err := rows.Scan(
                        &amp;process.RunID,
                        &amp;process.ProcessID,
                        &amp;process.Command,
                        &amp;argsBytes,
                        &amp;cwd,
                        &amp;status,
                        &amp;pid,
                        &amp;startedAt,
                        &amp;endedAt,
                        &amp;exitCode,
                        &amp;signal,
                        &amp;previewBytes,
                        &amp;metaBytes,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">process.Args = decodeStringSlice(argsBytes)
                if cwd.Valid </span><span class="cov8" title="1">{
                        process.Cwd = cwd.String
                }</span>
                <span class="cov8" title="1">if status.Valid </span><span class="cov8" title="1">{
                        process.Status = status.String
                }</span>
                <span class="cov8" title="1">if pid.Valid </span><span class="cov8" title="1">{
                        process.PID = int(pid.Int64)
                }</span>
                <span class="cov8" title="1">if startedAt.Valid </span><span class="cov8" title="1">{
                        process.StartedAt = startedAt.Time.UTC().Format(time.RFC3339Nano)
                }</span>
                <span class="cov8" title="1">if endedAt.Valid </span><span class="cov8" title="1">{
                        process.EndedAt = endedAt.Time.UTC().Format(time.RFC3339Nano)
                }</span>
                <span class="cov8" title="1">if exitCode.Valid </span><span class="cov8" title="1">{
                        code := int(exitCode.Int64)
                        process.ExitCode = &amp;code
                }</span>
                <span class="cov8" title="1">if signal.Valid </span><span class="cov8" title="1">{
                        process.Signal = signal.String
                }</span>
                <span class="cov8" title="1">process.PreviewURLs = decodeStringSlice(previewBytes)
                process.Metadata = decodeJSONMap(metaBytes)
                results = append(results, process)</span>
        }
        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return results, nil</span>
}

func formatVector(values []float32) string <span class="cov0" title="0">{
        parts := make([]string, 0, len(values))
        for _, value := range values </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("%g", value))
        }</span>
        <span class="cov0" title="0">return "[" + strings.Join(parts, ",") + "]"</span>
}

const memoryEmbeddingDimensions = 1536

func readMetadataString(metadata map[string]any, key string) string <span class="cov8" title="1">{
        if metadata == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">value, ok := metadata[key]
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">if s, ok := value.(string); ok </span><span class="cov8" title="1">{
                return strings.TrimSpace(s)
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package store

import (
        "fmt"
        "strings"
)

func BuildRunStepFromEvent(event RunEvent) (RunStep, bool) <span class="cov8" title="1">{
        eventType := normalizeEventType(event.Type)
        switch eventType </span>{
        case "step.planned":<span class="cov8" title="1">
                stepID := firstString(event.Payload, "step_id")
                if stepID == "" </span><span class="cov0" title="0">{
                        stepID = fmt.Sprintf("step-%d", event.Seq)
                }</span>
                <span class="cov8" title="1">name := firstString(event.Payload, "name")
                if name == "" </span><span class="cov0" title="0">{
                        name = stepID
                }</span>
                <span class="cov8" title="1">step := RunStep{
                        RunID:             event.RunID,
                        ID:                stepID,
                        ParentStepID:      firstString(event.Payload, "parent_step_id"),
                        Name:              name,
                        Kind:              "step",
                        Status:            "pending",
                        PlanID:            firstString(event.Payload, "plan_id"),
                        Attempt:           firstInt(event.Payload, "attempt"),
                        PolicyDecision:    firstString(event.Payload, "policy_decision"),
                        Source:            event.Source,
                        Seq:               event.Seq,
                        Dependencies:      readStringSlice(event.Payload, "dependencies"),
                        ExpectedArtifacts: readStringSlice(event.Payload, "expected_artifacts"),
                }
                step.Diagnostics = buildDiagnostics(event, step)
                return step, true</span>
        case "step.started":<span class="cov8" title="1">
                stepID := firstString(event.Payload, "step_id")
                if stepID == "" </span><span class="cov0" title="0">{
                        stepID = fmt.Sprintf("step-%d", event.Seq)
                }</span>
                <span class="cov8" title="1">name := firstString(event.Payload, "name")
                if name == "" </span><span class="cov0" title="0">{
                        name = stepID
                }</span>
                <span class="cov8" title="1">step := RunStep{
                        RunID:             event.RunID,
                        ID:                stepID,
                        ParentStepID:      firstString(event.Payload, "parent_step_id"),
                        Name:              name,
                        Kind:              "step",
                        Status:            "running",
                        PlanID:            firstString(event.Payload, "plan_id"),
                        Attempt:           firstInt(event.Payload, "attempt"),
                        PolicyDecision:    firstString(event.Payload, "policy_decision"),
                        Source:            event.Source,
                        Seq:               event.Seq,
                        StartedAt:         event.Timestamp,
                        Dependencies:      readStringSlice(event.Payload, "dependencies"),
                        ExpectedArtifacts: readStringSlice(event.Payload, "expected_artifacts"),
                }
                step.Diagnostics = buildDiagnostics(event, step)
                return step, true</span>
        case "step.completed", "step.failed":<span class="cov8" title="1">
                stepID := firstString(event.Payload, "step_id")
                if stepID == "" </span><span class="cov0" title="0">{
                        stepID = fmt.Sprintf("step-%d", event.Seq)
                }</span>
                <span class="cov8" title="1">name := firstString(event.Payload, "name")
                if name == "" </span><span class="cov8" title="1">{
                        name = stepID
                }</span>
                <span class="cov8" title="1">status := "completed"
                if eventType == "step.failed" </span><span class="cov8" title="1">{
                        status = "failed"
                }</span>
                <span class="cov8" title="1">step := RunStep{
                        RunID:             event.RunID,
                        ID:                stepID,
                        ParentStepID:      firstString(event.Payload, "parent_step_id"),
                        Name:              name,
                        Kind:              "step",
                        Status:            status,
                        PlanID:            firstString(event.Payload, "plan_id"),
                        Attempt:           firstInt(event.Payload, "attempt"),
                        PolicyDecision:    firstString(event.Payload, "policy_decision"),
                        Source:            event.Source,
                        Seq:               event.Seq,
                        CompletedAt:       event.Timestamp,
                        Error:             firstString(event.Payload, "error"),
                        Dependencies:      readStringSlice(event.Payload, "dependencies"),
                        ExpectedArtifacts: readStringSlice(event.Payload, "expected_artifacts"),
                }
                step.Diagnostics = buildDiagnostics(event, step)
                return step, true</span>
        case "tool.started", "tool.completed", "tool.failed":<span class="cov8" title="1">
                toolID := firstString(event.Payload, "invocation_id", "tool_call_id")
                if toolID == "" </span><span class="cov0" title="0">{
                        toolID = fmt.Sprintf("tool-%d", event.Seq)
                }</span>
                <span class="cov8" title="1">toolName := firstString(event.Payload, "tool_name")
                if toolName == "" </span><span class="cov0" title="0">{
                        toolName = eventType
                }</span>
                <span class="cov8" title="1">status := "running"
                switch eventType </span>{
                case "tool.completed":<span class="cov8" title="1">
                        status = "completed"</span>
                case "tool.failed":<span class="cov0" title="0">
                        status = "failed"</span>
                }
                <span class="cov8" title="1">step := RunStep{
                        RunID:          event.RunID,
                        ID:             toolID,
                        Name:           toolName,
                        Kind:           "tool",
                        Status:         status,
                        PlanID:         firstString(event.Payload, "plan_id"),
                        Attempt:        firstInt(event.Payload, "attempt"),
                        PolicyDecision: firstString(event.Payload, "policy_decision"),
                        Source:         event.Source,
                        Seq:            event.Seq,
                        Error:          firstString(event.Payload, "error"),
                        Diagnostics:    map[string]any{},
                        Dependencies:   readStringSlice(event.Payload, "dependencies"),
                }
                if status == "running" </span><span class="cov0" title="0">{
                        step.StartedAt = event.Timestamp
                }</span> else<span class="cov8" title="1"> {
                        step.CompletedAt = event.Timestamp
                }</span>
                <span class="cov8" title="1">step.Diagnostics = buildDiagnostics(event, step)
                return step, true</span>
        default:<span class="cov8" title="1">
                return RunStep{}, false</span>
        }
}

func MergeRunStep(existing RunStep, incoming RunStep) RunStep <span class="cov8" title="1">{
        merged := existing

        if merged.RunID == "" </span><span class="cov0" title="0">{
                merged.RunID = incoming.RunID
        }</span>
        <span class="cov8" title="1">if merged.ID == "" </span><span class="cov0" title="0">{
                merged.ID = incoming.ID
        }</span>
        <span class="cov8" title="1">if merged.ParentStepID == "" </span><span class="cov8" title="1">{
                merged.ParentStepID = incoming.ParentStepID
        }</span>
        <span class="cov8" title="1">if merged.Name == "" </span><span class="cov0" title="0">{
                merged.Name = incoming.Name
        }</span>
        <span class="cov8" title="1">if merged.Kind == "" </span><span class="cov0" title="0">{
                merged.Kind = incoming.Kind
        }</span>
        <span class="cov8" title="1">if merged.Source == "" </span><span class="cov0" title="0">{
                merged.Source = incoming.Source
        }</span>
        <span class="cov8" title="1">if incoming.Source != "" </span><span class="cov8" title="1">{
                merged.Source = incoming.Source
        }</span>
        <span class="cov8" title="1">if incoming.Status != "" </span><span class="cov8" title="1">{
                merged.Status = incoming.Status
        }</span>
        <span class="cov8" title="1">if merged.PlanID == "" </span><span class="cov8" title="1">{
                merged.PlanID = incoming.PlanID
        }</span>
        <span class="cov8" title="1">if incoming.Attempt &gt; 0 </span><span class="cov0" title="0">{
                merged.Attempt = incoming.Attempt
        }</span>
        <span class="cov8" title="1">if incoming.PolicyDecision != "" </span><span class="cov0" title="0">{
                merged.PolicyDecision = incoming.PolicyDecision
        }</span>
        <span class="cov8" title="1">if merged.Seq == 0 || (incoming.Seq &gt; 0 &amp;&amp; incoming.Seq &lt; merged.Seq) </span><span class="cov8" title="1">{
                merged.Seq = incoming.Seq
        }</span>
        <span class="cov8" title="1">if merged.StartedAt == "" &amp;&amp; incoming.StartedAt != "" </span><span class="cov8" title="1">{
                merged.StartedAt = incoming.StartedAt
        }</span>
        <span class="cov8" title="1">if incoming.CompletedAt != "" </span><span class="cov8" title="1">{
                merged.CompletedAt = incoming.CompletedAt
        }</span>
        <span class="cov8" title="1">if incoming.Error != "" </span><span class="cov8" title="1">{
                merged.Error = incoming.Error
        }</span>
        <span class="cov8" title="1">if len(merged.Dependencies) == 0 &amp;&amp; len(incoming.Dependencies) &gt; 0 </span><span class="cov0" title="0">{
                merged.Dependencies = append([]string{}, incoming.Dependencies...)
        }</span>
        <span class="cov8" title="1">if len(merged.ExpectedArtifacts) == 0 &amp;&amp; len(incoming.ExpectedArtifacts) &gt; 0 </span><span class="cov0" title="0">{
                merged.ExpectedArtifacts = append([]string{}, incoming.ExpectedArtifacts...)
        }</span>
        <span class="cov8" title="1">if merged.Diagnostics == nil </span><span class="cov0" title="0">{
                merged.Diagnostics = map[string]any{}
        }</span>
        <span class="cov8" title="1">for key, value := range incoming.Diagnostics </span><span class="cov8" title="1">{
                merged.Diagnostics[key] = value
        }</span>
        <span class="cov8" title="1">if merged.Name == "" </span><span class="cov0" title="0">{
                merged.Name = merged.ID
        }</span>
        <span class="cov8" title="1">if merged.Kind == "" </span><span class="cov0" title="0">{
                merged.Kind = "step"
        }</span>
        <span class="cov8" title="1">if merged.Status == "" </span><span class="cov0" title="0">{
                merged.Status = "running"
        }</span>
        <span class="cov8" title="1">return merged</span>
}

func normalizeEventType(eventType string) string <span class="cov8" title="1">{
        normalized := strings.TrimSpace(strings.ToLower(eventType))
        switch normalized </span>{
        case "step_started":<span class="cov0" title="0">
                return "step.started"</span>
        case "step.planned", "step_planned":<span class="cov8" title="1">
                return "step.planned"</span>
        case "step_completed":<span class="cov0" title="0">
                return "step.completed"</span>
        case "step_failed":<span class="cov0" title="0">
                return "step.failed"</span>
        case "tool_started":<span class="cov0" title="0">
                return "tool.started"</span>
        case "tool_output":<span class="cov0" title="0">
                return "tool.completed"</span>
        case "tool_error":<span class="cov0" title="0">
                return "tool.failed"</span>
        default:<span class="cov8" title="1">
                return strings.ReplaceAll(normalized, "_", ".")</span>
        }
}

func firstString(payload map[string]any, keys ...string) string <span class="cov8" title="1">{
        if payload == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">for _, key := range keys </span><span class="cov8" title="1">{
                value, ok := payload[key]
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">switch typed := value.(type) </span>{
                case string:<span class="cov8" title="1">
                        if trimmed := strings.TrimSpace(typed); trimmed != "" </span><span class="cov8" title="1">{
                                return trimmed
                        }</span>
                }
        }
        <span class="cov8" title="1">return ""</span>
}

func firstInt(payload map[string]any, keys ...string) int <span class="cov8" title="1">{
        if payload == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">for _, key := range keys </span><span class="cov8" title="1">{
                value, ok := payload[key]
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">switch typed := value.(type) </span>{
                case int:<span class="cov0" title="0">
                        return typed</span>
                case int64:<span class="cov0" title="0">
                        return int(typed)</span>
                case float64:<span class="cov0" title="0">
                        return int(typed)</span>
                }
        }
        <span class="cov8" title="1">return 0</span>
}

func readStringSlice(payload map[string]any, key string) []string <span class="cov8" title="1">{
        if payload == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">value, ok := payload[key]
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">raw, ok := value.([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">results := make([]string, 0, len(raw))
        for _, item := range raw </span><span class="cov0" title="0">{
                text, ok := item.(string)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">trimmed := strings.TrimSpace(text)
                if trimmed == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">results = append(results, trimmed)</span>
        }
        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return results</span>
}

func buildDiagnostics(event RunEvent, step RunStep) map[string]any <span class="cov8" title="1">{
        diagnostics := map[string]any{}
        for key, value := range event.Payload </span><span class="cov8" title="1">{
                diagnostics[key] = value
        }</span>
        <span class="cov8" title="1">diagnostics["source"] = event.Source
        diagnostics["seq"] = event.Seq
        diagnostics["kind"] = step.Kind
        if step.Error != "" </span><span class="cov8" title="1">{
                diagnostics["error"] = step.Error
        }</span>
        <span class="cov8" title="1">if event.TraceID != "" </span><span class="cov0" title="0">{
                diagnostics["trace_id"] = event.TraceID
        }</span>
        <span class="cov8" title="1">return diagnostics</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package workflows

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "regexp"
        "sort"
        "strconv"
        "strings"
        "time"

        "github.com/google/uuid"

        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/llm"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/personality"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/secrets"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/skills"
        "github.com/Keyring-Network/keyring-gavryn/control-plane/internal/store"
)

type GenerateInput struct {
        RunID string
}

type PlanInput struct {
        RunID   string
        Message string
}

type PlannedStep struct {
        ID                string   `json:"id"`
        Name              string   `json:"name"`
        Dependencies      []string `json:"dependencies,omitempty"`
        ExpectedArtifacts []string `json:"expected_artifacts,omitempty"`
}

type PlanOutput struct {
        PlanID string        `json:"plan_id"`
        Steps  []PlannedStep `json:"steps"`
}

type ExecuteInput struct {
        RunID   string
        Message string
        PlanID  string
}

type ExecuteOutput struct {
        PlanID string `json:"plan_id"`
}

type VerifyInput struct {
        RunID   string
        Message string
        PlanID  string
}

type VerifyOutput struct {
        Status           string `json:"status"`
        CompletionReason string `json:"completion_reason"`
}

type RunFailureInput struct {
        RunID string
        Error string
}

var (
        newProvider   = llm.NewProvider
        decryptSecret = secrets.Decrypt
        marshalJSON   = json.Marshal
        buildSystem   = (*RunActivities).buildSystemPrompt
        buildMemory   = (*RunActivities).buildMemoryPrompt
)

const (
        defaultMaxToolIterations = 4
        webResearchMaxIterations = 18
        maxToolCalls             = 12
        maxToolResultChars       = 4000
        maxToolJSONChars         = 120000

        maxToolParseContentChars = 300000
        maxPendingToolBlockChars = 140000
        maxLLMGenerateAttempts   = 2
        maxToolIntentReprompts   = 2
        maxToolRecoveryReprompts = 1
        maxNoContentReprompts    = 1
        maxWebResearchReprompts  = 2
        maxAutoResearchSeedPages = 12
        maxAutoResearchLinks     = 48
        maxAutoResearchPerSeed   = 8
        autoResearchScrollPasses = 3
        autoResearchScrollAmount = 1200
        runTitleGenerateTimeout  = 2 * time.Second
        maxConversationMessages  = 80
        maxConversationChars     = 120000
        maxLLMPhaseBudget        = 20 * time.Second
)

var allowedToolNames = map[string]struct{}{
        "browser.navigate":     {},
        "browser.snapshot":     {},
        "browser.click":        {},
        "browser.type":         {},
        "browser.scroll":       {},
        "browser.extract":      {},
        "browser.evaluate":     {},
        "browser.pdf":          {},
        "document.create_pptx": {},
        "document.create_docx": {},
        "document.create_pdf":  {},
        "document.create_csv":  {},
        "editor.list":          {},
        "editor.read":          {},
        "editor.write":         {},
        "editor.delete":        {},
        "editor.stat":          {},
        "process.exec":         {},
        "process.start":        {},
        "process.status":       {},
        "process.logs":         {},
        "process.stop":         {},
        "process.list":         {},
}

var (
        fencedToolBlockRE       = regexp.MustCompile("(?s)```(?:tool|json)\\s*\\n?.*?```")
        inlineToolFenceRE       = regexp.MustCompile("(?s)```(tool|json)\\s*(\\{.*?\\})\\s*```")
        retryableStatusRE       = regexp.MustCompile(`(?:^|\D)(429|500|502|503|504)(?:\D|$)`)
        topNRequestRE           = regexp.MustCompile(`\btop\s+(\d{1,2})\b`)
        sourceLinkRE            = regexp.MustCompile(`https?://[^\s\)\]\}&gt;\"]+`)
        markdownLinkRE          = regexp.MustCompile(`\[(?P&lt;label&gt;[^\]]+)\]\((?P&lt;url&gt;https?://[^)]+)\)`)
        topStoryLineRE          = regexp.MustCompile(`(?m)^\d+\.\s+\*\*.+`)
        tickerSymbolRE          = regexp.MustCompile(`\$[A-Z]{2,6}`)
        datePathRE              = regexp.MustCompile(`/20\d{2}/(?:0[1-9]|1[0-2])(?:/(?:0[1-9]|[12]\d|3[01]))?`)
        anyYearRE               = regexp.MustCompile(`\b20\d{2}\b`)
        monthDateRE             = regexp.MustCompile(`(?i)\b(?:jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:t(?:ember)?)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)\s+\d{1,2},\s+20\d{2}\b`)
        monthYearRE             = regexp.MustCompile(`(?i)\b(?:january|february|march|april|may|june|july|august|september|october|november|december)\s+20\d{2}\b`)
        legacyYearRE            = regexp.MustCompile(`\b20(1\d|2[0-5])\b`)
        sentenceSplitRE         = regexp.MustCompile(`[.!?]+\s+`)
        lowValueResearchSignals = []string{
                "news video prices",
                "data &amp; indices",
                "sponsored",
                "latest news",
                "price index",
                "crypto news &amp; price indexes",
                "markets prices",
                "navigation markets",
                "ecosystem english news indices",
                "in depth learn podcasts about",
                "video prices research consensus",
                "we also share information about your use of our site",
                "manage choices",
                "accept all cookies",
                "coindesk has adopted a set of principles",
                "bullish owns and invests",
                "list of partners (vendors)",
                "browser type and information",
                "register now 404",
                "hmm, that's weird",
        }
)

type toolCall struct {
        ToolName string
        Input    map[string]any
}

type browserUserTabConfig struct {
        Enabled            bool
        InteractionAllowed bool
        DomainAllowlist    []string
        PreferredBrowser   string
        BrowserUserAgent   string
}

type toolExecutionError struct {
        InvocationID string
        Message      string
}

func (e *toolExecutionError) Error() string <span class="cov8" title="1">{
        if e == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(e.Message)</span>
}

type toolRunnerResponse struct {
        Status string         `json:"status"`
        Output map[string]any `json:"output"`
        Error  string         `json:"error,omitempty"`
}

type RunActivities struct {
        store               store.Store
        defaultConfig       llm.Config
        secretsKey          []byte
        controlPlane        string
        toolRunner          string
        httpClient          *http.Client
        requestTimeout      time.Duration
        toolTimeout         time.Duration
        memoryMaxResults    int
        memoryMaxEntryChars int
}

type llmProviderCandidate struct {
        Name     string
        Provider llm.Provider
}

type RunActivitiesOption func(*RunActivities)

func WithMemoryConfig(maxResults int, maxEntryChars int) RunActivitiesOption <span class="cov0" title="0">{
        return func(a *RunActivities) </span><span class="cov0" title="0">{
                if maxResults &gt; 0 </span><span class="cov0" title="0">{
                        a.memoryMaxResults = maxResults
                }</span>
                <span class="cov0" title="0">if maxEntryChars &gt; 0 </span><span class="cov0" title="0">{
                        a.memoryMaxEntryChars = maxEntryChars
                }</span>
        }
}

func NewRunActivities(store store.Store, defaultConfig llm.Config, secretsKey []byte, controlPlaneURL string, toolRunnerURL string, opts ...RunActivitiesOption) *RunActivities <span class="cov8" title="1">{
        activities := &amp;RunActivities{
                store:               store,
                defaultConfig:       defaultConfig,
                secretsKey:          secretsKey,
                controlPlane:        strings.TrimRight(controlPlaneURL, "/"),
                toolRunner:          strings.TrimRight(toolRunnerURL, "/"),
                httpClient:          &amp;http.Client{Timeout: 60 * time.Second},
                requestTimeout:      10 * time.Second,
                toolTimeout:         30 * time.Second,
                memoryMaxResults:    5,
                memoryMaxEntryChars: 400,
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                if opt != nil </span><span class="cov0" title="0">{
                        opt(activities)
                }</span>
        }
        <span class="cov8" title="1">return activities</span>
}

func (a *RunActivities) PlanExecution(ctx context.Context, input PlanInput) (PlanOutput, error) <span class="cov0" title="0">{
        if strings.TrimSpace(input.RunID) == "" </span><span class="cov0" title="0">{
                return PlanOutput{}, errors.New("run_id required")
        }</span>
        <span class="cov0" title="0">trimmedMessage := strings.TrimSpace(input.Message)
        if trimmedMessage == "" </span><span class="cov0" title="0">{
                messages, err := a.store.ListMessages(ctx, input.RunID)
                if err != nil </span><span class="cov0" title="0">{
                        return PlanOutput{}, err
                }</span>
                <span class="cov0" title="0">trimmedMessage = latestUserMessage(messages)</span>
        }
        <span class="cov0" title="0">planID := uuid.New().String()
        steps := buildExecutionPlan(trimmedMessage)
        _ = a.emitEvent(ctx, input.RunID, "run.phase.changed", map[string]any{
                "phase":   "planning",
                "plan_id": planID,
        })
        _ = a.emitEvent(ctx, input.RunID, "step.started", map[string]any{
                "step_id": "planner",
                "name":    "Plan execution",
                "plan_id": planID,
        })
        for _, step := range steps </span><span class="cov0" title="0">{
                _ = a.emitEvent(ctx, input.RunID, "step.planned", map[string]any{
                        "plan_id":            planID,
                        "step_id":            step.ID,
                        "name":               step.Name,
                        "dependencies":       step.Dependencies,
                        "expected_artifacts": step.ExpectedArtifacts,
                        "parent_step_id":     "planner",
                })
        }</span>
        <span class="cov0" title="0">_ = a.emitEvent(ctx, input.RunID, "step.completed", map[string]any{
                "step_id":            "planner",
                "name":               "Plan execution",
                "plan_id":            planID,
                "planned_step_count": len(steps),
        })
        return PlanOutput{
                PlanID: planID,
                Steps:  steps,
        }, nil</span>
}

func buildExecutionPlan(message string) []PlannedStep <span class="cov0" title="0">{
        text := strings.ToLower(strings.TrimSpace(message))
        if text == "" </span><span class="cov0" title="0">{
                return []PlannedStep{
                        {
                                ID:                "execute_request",
                                Name:              "Execute request",
                                ExpectedArtifacts: []string{"assistant.reply"},
                        },
                }
        }</span>
        <span class="cov0" title="0">containsAny := func(phrases ...string) bool </span><span class="cov0" title="0">{
                for _, phrase := range phrases </span><span class="cov0" title="0">{
                        if strings.Contains(text, phrase) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }
        <span class="cov0" title="0">if containsAny("browse", "research", "news", "find", "search the web") </span><span class="cov0" title="0">{
                return []PlannedStep{
                        {
                                ID:                "collect_sources",
                                Name:              "Collect web sources",
                                ExpectedArtifacts: []string{"browser.snapshot", "browser.extract"},
                        },
                        {
                                ID:                "synthesize_findings",
                                Name:              "Synthesize findings with citations",
                                Dependencies:      []string{"collect_sources"},
                                ExpectedArtifacts: []string{"assistant.reply"},
                        },
                }
        }</span>
        <span class="cov0" title="0">if containsAny("create", "build", "website", "nextjs", "app", "implement", "code") </span><span class="cov0" title="0">{
                steps := []PlannedStep{
                        {
                                ID:                "inspect_workspace",
                                Name:              "Inspect workspace and existing files",
                                ExpectedArtifacts: []string{"workspace.snapshot"},
                        },
                        {
                                ID:                "implement_changes",
                                Name:              "Create or update project files",
                                Dependencies:      []string{"inspect_workspace"},
                                ExpectedArtifacts: []string{"workspace.changed"},
                        },
                        {
                                ID:                "validate_changes",
                                Name:              "Run validation commands",
                                Dependencies:      []string{"implement_changes"},
                                ExpectedArtifacts: []string{"process.exec"},
                        },
                }
                if containsAny("website", "nextjs", "frontend", "marketing") </span><span class="cov0" title="0">{
                        steps = append(steps, PlannedStep{
                                ID:                "start_preview",
                                Name:              "Start preview server",
                                Dependencies:      []string{"validate_changes"},
                                ExpectedArtifacts: []string{"process.start", "preview.url"},
                        })
                }</span>
                <span class="cov0" title="0">return steps</span>
        }
        <span class="cov0" title="0">return []PlannedStep{
                {
                        ID:                "execute_request",
                        Name:              "Execute request",
                        ExpectedArtifacts: []string{"assistant.reply"},
                },
        }</span>
}

func (a *RunActivities) ExecutePlan(ctx context.Context, input ExecuteInput) (ExecuteOutput, error) <span class="cov0" title="0">{
        if strings.TrimSpace(input.RunID) == "" </span><span class="cov0" title="0">{
                return ExecuteOutput{}, errors.New("run_id required")
        }</span>
        <span class="cov0" title="0">_ = a.emitEvent(ctx, input.RunID, "run.phase.changed", map[string]any{
                "phase":   "executing",
                "plan_id": strings.TrimSpace(input.PlanID),
        })
        err := a.GenerateAssistantReply(ctx, GenerateInput{RunID: input.RunID})
        if err != nil </span><span class="cov0" title="0">{
                return ExecuteOutput{}, err
        }</span>
        <span class="cov0" title="0">return ExecuteOutput{PlanID: strings.TrimSpace(input.PlanID)}, nil</span>
}

func (a *RunActivities) VerifyExecution(ctx context.Context, input VerifyInput) (VerifyOutput, error) <span class="cov0" title="0">{
        if strings.TrimSpace(input.RunID) == "" </span><span class="cov0" title="0">{
                return VerifyOutput{}, errors.New("run_id required")
        }</span>
        <span class="cov0" title="0">_ = a.emitEvent(ctx, input.RunID, "run.phase.changed", map[string]any{
                "phase":   "validating",
                "plan_id": strings.TrimSpace(input.PlanID),
        })
        _ = a.emitEvent(ctx, input.RunID, "step.started", map[string]any{
                "step_id": "verifier",
                "name":    "Verify run outputs",
                "plan_id": strings.TrimSpace(input.PlanID),
        })

        eventsList, err := a.store.ListEvents(ctx, input.RunID, 0)
        if err != nil </span><span class="cov0" title="0">{
                _ = a.emitEvent(ctx, input.RunID, "step.failed", map[string]any{
                        "step_id": "verifier",
                        "name":    "Verify run outputs",
                        "error":   err.Error(),
                })
                return VerifyOutput{}, err
        }</span>

        <span class="cov0" title="0">var (
                hasTerminalEvent bool
                status           = "partial"
                reason           = "verification_pending"
        )
        for i := len(eventsList) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                switch eventsList[i].Type </span>{
                case "run.completed":<span class="cov0" title="0">
                        hasTerminalEvent = true
                        status = "completed"
                        reason = "verified_success"</span>
                case "run.partial":<span class="cov0" title="0">
                        hasTerminalEvent = true
                        status = "partial"
                        reason = "verified_partial"</span>
                case "run.failed":<span class="cov0" title="0">
                        hasTerminalEvent = true
                        status = "failed"
                        reason = "verified_failed"</span>
                }
                <span class="cov0" title="0">if hasTerminalEvent </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">if !hasTerminalEvent </span><span class="cov0" title="0">{
                reason = "missing_terminal_event"
                _ = a.postCompletionEvent(ctx, input.RunID, "partial", reason)
        }</span>

        <span class="cov0" title="0">_ = a.emitEvent(ctx, input.RunID, "step.completed", map[string]any{
                "step_id":           "verifier",
                "name":              "Verify run outputs",
                "status":            status,
                "completion_reason": reason,
                "plan_id":           strings.TrimSpace(input.PlanID),
        })
        _ = a.emitEvent(ctx, input.RunID, "run.phase.changed", map[string]any{
                "phase":             "completed",
                "status":            status,
                "completion_reason": reason,
                "plan_id":           strings.TrimSpace(input.PlanID),
        })
        return VerifyOutput{
                Status:           status,
                CompletionReason: reason,
        }, nil</span>
}

func (a *RunActivities) GenerateAssistantReply(ctx context.Context, input GenerateInput) error <span class="cov8" title="1">{
        if input.RunID == "" </span><span class="cov8" title="1">{
                return errors.New("run_id required")
        }</span>
        <span class="cov8" title="1">messages, err := a.store.ListMessages(ctx, input.RunID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">cfg, err := a.resolveConfig(ctx, messages)
        if err != nil </span><span class="cov8" title="1">{
                _ = a.postEvent(ctx, input.RunID, "run.failed", map[string]any{"error": err.Error()})
                return err
        }</span>
        <span class="cov8" title="1">modelRoute := a.resolveModelRoute(ctx, input.RunID, messages)
        providers, err := a.buildProviderCandidates(cfg, modelRoute)
        if err != nil </span><span class="cov8" title="1">{
                _ = a.postEvent(ctx, input.RunID, "run.failed", map[string]any{"error": err.Error()})
                return err
        }</span>
        <span class="cov8" title="1">primaryProvider := providers[0].Provider
        llmMessages := make([]llm.Message, 0, len(messages))
        for _, msg := range messages </span><span class="cov8" title="1">{
                if msg.Content == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">llmMessages = append(llmMessages, llm.Message{Role: msg.Role, Content: msg.Content})</span>
        }
        <span class="cov8" title="1">if systemPrompt := buildSystem(a, ctx); systemPrompt != "" </span><span class="cov8" title="1">{
                llmMessages = append([]llm.Message{{Role: "system", Content: systemPrompt}}, llmMessages...)
        }</span>
        <span class="cov8" title="1">if memoryPrompt := buildMemory(a, ctx, messages); memoryPrompt != "" </span><span class="cov8" title="1">{
                llmMessages = append([]llm.Message{{Role: "system", Content: memoryPrompt}}, llmMessages...)
        }</span>
        <span class="cov8" title="1">if len(llmMessages) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">_ = a.emitEvent(ctx, input.RunID, "step.started", map[string]any{
                "step_id": "assistant_reply",
                "name":    "Generate assistant reply",
        })
        llmMessages = clampConversationWindow(llmMessages, maxConversationMessages, maxConversationChars)
        latestUserRequest := latestUserMessage(messages)
        browserUserTab := resolveBrowserUserTabConfig(messages)
        mustExecuteTools := a.toolRunner != "" &amp;&amp; requestLikelyNeedsTools(latestUserRequest)
        researchRequirements := deriveWebResearchRequirements(latestUserRequest, mustExecuteTools)
        if researchRequirements.Enabled </span><span class="cov8" title="1">{
                llmMessages = append(llmMessages, llm.Message{
                        Role:    "system",
                        Content: buildWebResearchExecutionPrompt(researchRequirements),
                })
                llmMessages = clampConversationWindow(llmMessages, maxConversationMessages, maxConversationChars)
        }</span>
        <span class="cov8" title="1">var lastResponse string
        successfulToolCalls := make([]toolCall, 0)
        hadToolErrors := false
        pendingToolBlock := ""
        toolIntentRepromptCount := 0
        toolRecoveryRepromptCount := 0
        noContentRepromptCount := 0
        webResearchRepromptCount := 0
        autoWebResearchRecoveryAttempted := false
        iterationLimit := defaultMaxToolIterations
        if researchRequirements.Enabled </span><span class="cov8" title="1">{
                iterationLimit = webResearchMaxIterations
        }</span>
        <span class="cov8" title="1">for iteration := 0; iteration &lt; iterationLimit; iteration++ </span><span class="cov8" title="1">{
                llmMessages = clampConversationWindow(llmMessages, maxConversationMessages, maxConversationChars)
                response, err := a.generateWithRetry(ctx, input.RunID, providers, llmMessages)
                if err != nil </span><span class="cov8" title="1">{
                        if isNoContentLLMError(err) </span><span class="cov8" title="1">{
                                if noContentRepromptCount &lt; maxNoContentReprompts </span><span class="cov8" title="1">{
                                        noContentRepromptCount++
                                        llmMessages = append(llmMessages,
                                                llm.Message{Role: "system", Content: buildNoContentRetryPrompt(mustExecuteTools, latestUserRequest)},
                                        )
                                        llmMessages = clampConversationWindow(llmMessages, maxConversationMessages, maxConversationChars)
                                        continue</span>
                                }
                                <span class="cov8" title="1">if len(successfulToolCalls) &gt; 0 </span><span class="cov8" title="1">{
                                        if researchRequirements.Enabled &amp;&amp; !hasSufficientWebResearchEvidenceForRequest(successfulToolCalls, researchRequirements, latestUserRequest) &amp;&amp; !autoWebResearchRecoveryAttempted </span><span class="cov0" title="0">{
                                                autoWebResearchRecoveryAttempted = true
                                                recoveredCalls, recoveredHadErrors := a.autoDeepenWebResearch(ctx, input.RunID, latestUserRequest, successfulToolCalls, browserUserTab)
                                                if recoveredHadErrors </span><span class="cov0" title="0">{
                                                        hadToolErrors = true
                                                }</span>
                                                <span class="cov0" title="0">if len(recoveredCalls) &gt; 0 </span><span class="cov0" title="0">{
                                                        successfulToolCalls = append(successfulToolCalls, recoveredCalls...)
                                                }</span>
                                        }
                                        <span class="cov8" title="1">final := a.composeBestEffortFinalResponse(ctx, input.RunID, providers, llmMessages, latestUserRequest, successfulToolCalls, researchRequirements, hadToolErrors, err)
                                        final = enforceResearchQualityFallback(final, successfulToolCalls, researchRequirements, latestUserRequest)
                                        if postErr := a.postMessage(ctx, input.RunID, final); postErr != nil </span><span class="cov0" title="0">{
                                                return postErr
                                        }</span>
                                        <span class="cov8" title="1">status := ternaryStatus(hadToolErrors)
                                        _ = a.emitEvent(ctx, input.RunID, "step.completed", map[string]any{
                                                "step_id": "assistant_reply",
                                                "name":    "Generate assistant reply",
                                                "status":  status,
                                        })
                                        completionReason := "llm_no_content_after_tools"
                                        if researchRequirements.Enabled </span><span class="cov0" title="0">{
                                                if hasSufficientWebResearchEvidenceForRequest(successfulToolCalls, researchRequirements, latestUserRequest) &amp;&amp; !hadToolErrors </span><span class="cov0" title="0">{
                                                        completionReason = "research_evidence_complete"
                                                }</span> else<span class="cov0" title="0"> if !hasSufficientWebResearchEvidenceForRequest(successfulToolCalls, researchRequirements, latestUserRequest) </span><span class="cov0" title="0">{
                                                        status = "partial"
                                                        completionReason = "insufficient_web_research_evidence"
                                                }</span>
                                        }
                                        <span class="cov8" title="1">if hadToolErrors &amp;&amp; completionReason != "insufficient_web_research_evidence" </span><span class="cov0" title="0">{
                                                status = "partial"
                                                completionReason = "partial_tool_errors"
                                        }</span>
                                        <span class="cov8" title="1">_ = a.postCompletionEvent(ctx, input.RunID, status, completionReason)
                                        a.maybeGenerateRunTitle(ctx, input.RunID, primaryProvider, messages, final)
                                        return nil</span>
                                }
                                <span class="cov8" title="1">fallback := buildNoContentFallback(successfulToolCalls)
                                if postErr := a.postMessage(ctx, input.RunID, fallback); postErr != nil </span><span class="cov0" title="0">{
                                        return postErr
                                }</span>
                                <span class="cov8" title="1">_ = a.emitEvent(ctx, input.RunID, "step.completed", map[string]any{
                                        "step_id": "assistant_reply",
                                        "name":    "Generate assistant reply",
                                        "status":  "partial",
                                })
                                _ = a.postCompletionEvent(ctx, input.RunID, "partial", "llm_no_content")
                                a.maybeGenerateRunTitle(ctx, input.RunID, primaryProvider, messages, fallback)
                                return nil</span>
                        }
                        <span class="cov8" title="1">if isRetryableLLMError(err) </span><span class="cov8" title="1">{
                                if len(successfulToolCalls) &gt; 0 </span><span class="cov8" title="1">{
                                        if researchRequirements.Enabled &amp;&amp; !hasSufficientWebResearchEvidenceForRequest(successfulToolCalls, researchRequirements, latestUserRequest) &amp;&amp; !autoWebResearchRecoveryAttempted </span><span class="cov8" title="1">{
                                                autoWebResearchRecoveryAttempted = true
                                                recoveredCalls, recoveredHadErrors := a.autoDeepenWebResearch(ctx, input.RunID, latestUserRequest, successfulToolCalls, browserUserTab)
                                                if recoveredHadErrors </span><span class="cov8" title="1">{
                                                        hadToolErrors = true
                                                }</span>
                                                <span class="cov8" title="1">if len(recoveredCalls) &gt; 0 </span><span class="cov8" title="1">{
                                                        successfulToolCalls = append(successfulToolCalls, recoveredCalls...)
                                                }</span>
                                        }
                                        <span class="cov8" title="1">final := a.composeBestEffortFinalResponse(ctx, input.RunID, providers, llmMessages, latestUserRequest, successfulToolCalls, researchRequirements, hadToolErrors, err)
                                        final = enforceResearchQualityFallback(final, successfulToolCalls, researchRequirements, latestUserRequest)
                                        if postErr := a.postMessage(ctx, input.RunID, final); postErr != nil </span><span class="cov0" title="0">{
                                                return postErr
                                        }</span>
                                        <span class="cov8" title="1">status := ternaryStatus(hadToolErrors)
                                        _ = a.emitEvent(ctx, input.RunID, "step.completed", map[string]any{
                                                "step_id": "assistant_reply",
                                                "name":    "Generate assistant reply",
                                                "status":  status,
                                        })
                                        completionReason := "llm_transient_after_tools"
                                        if researchRequirements.Enabled </span><span class="cov8" title="1">{
                                                if hasSufficientWebResearchEvidenceForRequest(successfulToolCalls, researchRequirements, latestUserRequest) &amp;&amp; !hadToolErrors </span><span class="cov0" title="0">{
                                                        completionReason = "research_evidence_complete"
                                                }</span> else<span class="cov8" title="1"> if !hasSufficientWebResearchEvidenceForRequest(successfulToolCalls, researchRequirements, latestUserRequest) </span><span class="cov8" title="1">{
                                                        status = "partial"
                                                        completionReason = "insufficient_web_research_evidence"
                                                }</span>
                                        }
                                        <span class="cov8" title="1">if hadToolErrors &amp;&amp; completionReason != "insufficient_web_research_evidence" </span><span class="cov0" title="0">{
                                                status = "partial"
                                                completionReason = "partial_tool_errors"
                                        }</span>
                                        <span class="cov8" title="1">_ = a.postCompletionEvent(ctx, input.RunID, status, completionReason)
                                        a.maybeGenerateRunTitle(ctx, input.RunID, primaryProvider, messages, final)
                                        return nil</span>
                                }
                                <span class="cov8" title="1">fallback := buildTransientLLMFallback(err)
                                if postErr := a.postMessage(ctx, input.RunID, fallback); postErr != nil </span><span class="cov0" title="0">{
                                        return postErr
                                }</span>
                                <span class="cov8" title="1">_ = a.emitEvent(ctx, input.RunID, "step.completed", map[string]any{
                                        "step_id": "assistant_reply",
                                        "name":    "Generate assistant reply",
                                        "status":  "partial",
                                })
                                _ = a.postCompletionEvent(ctx, input.RunID, "partial", "llm_transient_error")
                                return nil</span>
                        }
                        <span class="cov8" title="1">_ = a.emitEvent(ctx, input.RunID, "step.failed", map[string]any{
                                "step_id": "assistant_reply",
                                "name":    "Generate assistant reply",
                                "error":   err.Error(),
                        })
                        _ = a.postEvent(ctx, input.RunID, "run.failed", map[string]any{"error": err.Error()})
                        return err</span>
                }
                <span class="cov8" title="1">lastResponse = response
                parseInput := response
                if strings.TrimSpace(pendingToolBlock) != "" </span><span class="cov8" title="1">{
                        parseInput = pendingToolBlock + response
                }</span>
                <span class="cov8" title="1">toolCalls, parseStatus := parseToolCalls(parseInput)
                if len(toolCalls) == 0 </span><span class="cov8" title="1">{
                        if parseStatus.sawToolBlock </span><span class="cov8" title="1">{
                                if parseStatus.hadIncomplete </span><span class="cov8" title="1">{
                                        pendingToolBlock = buildPendingToolBlock(parseInput)
                                }</span> else<span class="cov8" title="1"> {
                                        pendingToolBlock = ""
                                }</span>
                                <span class="cov8" title="1">if toolRecoveryRepromptCount &gt;= maxToolRecoveryReprompts </span><span class="cov8" title="1">{
                                        fallback := buildInvalidToolPayloadFallback(successfulToolCalls)
                                        if postErr := a.postMessage(ctx, input.RunID, fallback); postErr != nil </span><span class="cov0" title="0">{
                                                return postErr
                                        }</span>
                                        <span class="cov8" title="1">_ = a.emitEvent(ctx, input.RunID, "step.completed", map[string]any{
                                                "step_id": "assistant_reply",
                                                "name":    "Generate assistant reply",
                                                "status":  "partial",
                                        })
                                        _ = a.postCompletionEvent(ctx, input.RunID, "partial", "invalid_tool_payload")
                                        return nil</span>
                                }
                                <span class="cov8" title="1">toolRecoveryRepromptCount++
                                llmMessages = append(llmMessages,
                                        llm.Message{Role: "assistant", Content: response},
                                        llm.Message{Role: "system", Content: buildToolRecoveryPrompt(parseStatus)},
                                )
                                llmMessages = clampConversationWindow(llmMessages, maxConversationMessages, maxConversationChars)
                                continue</span>
                        }
                        <span class="cov8" title="1">toolRecoveryRepromptCount = 0
                        pendingToolBlock = ""
                        if mustExecuteTools &amp;&amp; len(successfulToolCalls) == 0 </span><span class="cov8" title="1">{
                                if toolIntentRepromptCount &lt; maxToolIntentReprompts </span><span class="cov8" title="1">{
                                        toolIntentRepromptCount++
                                        llmMessages = append(llmMessages,
                                                llm.Message{Role: "assistant", Content: response},
                                                llm.Message{Role: "system", Content: buildToolOnlyRetryPrompt(latestUserRequest)},
                                        )
                                        llmMessages = clampConversationWindow(llmMessages, maxConversationMessages, maxConversationChars)
                                        continue</span>
                                }
                                <span class="cov8" title="1">if researchRequirements.Enabled &amp;&amp; !autoWebResearchRecoveryAttempted </span><span class="cov8" title="1">{
                                        autoWebResearchRecoveryAttempted = true
                                        recoveredCalls, recoveredHadErrors := a.autoDeepenWebResearch(ctx, input.RunID, latestUserRequest, successfulToolCalls, browserUserTab)
                                        if recoveredHadErrors </span><span class="cov8" title="1">{
                                                hadToolErrors = true
                                        }</span>
                                        <span class="cov8" title="1">if len(recoveredCalls) &gt; 0 </span><span class="cov0" title="0">{
                                                successfulToolCalls = append(successfulToolCalls, recoveredCalls...)
                                                uniqueSources, extractCount := summarizeWebResearchEvidenceForRequest(successfulToolCalls, latestUserRequest)
                                                if hasSufficientWebResearchEvidenceForRequest(successfulToolCalls, researchRequirements, latestUserRequest) </span><span class="cov0" title="0">{
                                                        final := a.composeBestEffortFinalResponse(ctx, input.RunID, providers, llmMessages, latestUserRequest, successfulToolCalls, researchRequirements, hadToolErrors, nil)
                                                        if strings.TrimSpace(final) == "" </span><span class="cov0" title="0">{
                                                                final = buildDeterministicWebResearchSummaryForRequest(successfulToolCalls, researchRequirements, latestUserRequest)
                                                        }</span>
                                                        <span class="cov0" title="0">if err := a.postMessage(ctx, input.RunID, final); err != nil </span><span class="cov0" title="0">{
                                                                return err
                                                        }</span>
                                                        <span class="cov0" title="0">status := ternaryStatus(hadToolErrors)
                                                        _ = a.emitEvent(ctx, input.RunID, "step.completed", map[string]any{
                                                                "step_id": "assistant_reply",
                                                                "name":    "Generate assistant reply",
                                                                "status":  status,
                                                        })
                                                        completionReason := "research_evidence_complete"
                                                        if hadToolErrors </span><span class="cov0" title="0">{
                                                                completionReason = "partial_tool_errors"
                                                        }</span>
                                                        <span class="cov0" title="0">_ = a.postCompletionEvent(ctx, input.RunID, status, completionReason)
                                                        a.maybeGenerateRunTitle(ctx, input.RunID, primaryProvider, messages, final)
                                                        return nil</span>
                                                }
                                                <span class="cov0" title="0">llmMessages = append(llmMessages,
                                                        llm.Message{Role: "assistant", Content: response},
                                                        llm.Message{Role: "system", Content: buildWebResearchRetryPrompt(researchRequirements, uniqueSources, extractCount, countSourceLinks(response))},
                                                )
                                                llmMessages = clampConversationWindow(llmMessages, maxConversationMessages, maxConversationChars)
                                                continue</span>
                                        }
                                }
                                <span class="cov8" title="1">fallback := buildMissingToolCallsFallback()
                                if err := a.postMessage(ctx, input.RunID, fallback); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">_ = a.emitEvent(ctx, input.RunID, "step.completed", map[string]any{
                                        "step_id": "assistant_reply",
                                        "name":    "Generate assistant reply",
                                        "status":  "partial",
                                })
                                _ = a.postCompletionEvent(ctx, input.RunID, "partial", "missing_tool_calls")
                                return nil</span>
                        }
                        <span class="cov8" title="1">if shouldRepromptToolExecution(a.toolRunner != "", latestUserRequest, response, toolIntentRepromptCount) </span><span class="cov8" title="1">{
                                toolIntentRepromptCount++
                                llmMessages = append(llmMessages,
                                        llm.Message{Role: "assistant", Content: response},
                                        llm.Message{Role: "system", Content: buildToolOnlyRetryPrompt(latestUserRequest)},
                                )
                                llmMessages = clampConversationWindow(llmMessages, maxConversationMessages, maxConversationChars)
                                continue</span>
                        }
                        <span class="cov8" title="1">if researchRequirements.Enabled </span><span class="cov8" title="1">{
                                uniqueSources, extractCount := summarizeWebResearchEvidenceForRequest(successfulToolCalls, latestUserRequest)
                                linkCount := countSourceLinks(response)
                                if shouldRepromptForWebResearch(researchRequirements, uniqueSources, extractCount, linkCount) </span><span class="cov8" title="1">{
                                        intentOnlyNarrative := looksLikeInProgressResearchNarrative(response)
                                        if intentOnlyNarrative &amp;&amp; !autoWebResearchRecoveryAttempted </span><span class="cov8" title="1">{
                                                autoWebResearchRecoveryAttempted = true
                                                recoveredCalls, recoveredHadErrors := a.autoDeepenWebResearch(ctx, input.RunID, latestUserRequest, successfulToolCalls, browserUserTab)
                                                if recoveredHadErrors </span><span class="cov8" title="1">{
                                                        hadToolErrors = true
                                                }</span>
                                                <span class="cov8" title="1">if len(recoveredCalls) &gt; 0 </span><span class="cov8" title="1">{
                                                        successfulToolCalls = append(successfulToolCalls, recoveredCalls...)
                                                        uniqueSources, extractCount = summarizeWebResearchEvidenceForRequest(successfulToolCalls, latestUserRequest)
                                                        linkCount = countSourceLinks(response)
                                                        if hasSufficientWebResearchEvidenceForRequest(successfulToolCalls, researchRequirements, latestUserRequest) </span><span class="cov0" title="0">{
                                                                final := a.composeBestEffortFinalResponse(ctx, input.RunID, providers, llmMessages, latestUserRequest, successfulToolCalls, researchRequirements, hadToolErrors, nil)
                                                                if strings.TrimSpace(final) == "" </span><span class="cov0" title="0">{
                                                                        final = buildDeterministicWebResearchSummaryForRequest(successfulToolCalls, researchRequirements, latestUserRequest)
                                                                }</span>
                                                                <span class="cov0" title="0">if err := a.postMessage(ctx, input.RunID, final); err != nil </span><span class="cov0" title="0">{
                                                                        return err
                                                                }</span>
                                                                <span class="cov0" title="0">status := ternaryStatus(hadToolErrors)
                                                                _ = a.emitEvent(ctx, input.RunID, "step.completed", map[string]any{
                                                                        "step_id": "assistant_reply",
                                                                        "name":    "Generate assistant reply",
                                                                        "status":  status,
                                                                })
                                                                completionReason := "research_evidence_complete"
                                                                if hadToolErrors </span><span class="cov0" title="0">{
                                                                        completionReason = "partial_tool_errors"
                                                                }</span>
                                                                <span class="cov0" title="0">_ = a.postCompletionEvent(ctx, input.RunID, status, completionReason)
                                                                a.maybeGenerateRunTitle(ctx, input.RunID, primaryProvider, messages, final)
                                                                return nil</span>
                                                        }
                                                }
                                        }
                                        <span class="cov8" title="1">repromptBudget := maxWebResearchReprompts
                                        if intentOnlyNarrative </span><span class="cov8" title="1">{
                                                repromptBudget++
                                        }</span>
                                        <span class="cov8" title="1">if webResearchRepromptCount &lt; repromptBudget </span><span class="cov8" title="1">{
                                                webResearchRepromptCount++
                                                llmMessages = append(llmMessages,
                                                        llm.Message{Role: "assistant", Content: response},
                                                        llm.Message{Role: "system", Content: buildWebResearchRetryPrompt(researchRequirements, uniqueSources, extractCount, linkCount)},
                                                )
                                                llmMessages = clampConversationWindow(llmMessages, maxConversationMessages, maxConversationChars)
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">if !autoWebResearchRecoveryAttempted </span><span class="cov8" title="1">{
                                                autoWebResearchRecoveryAttempted = true
                                                recoveredCalls, recoveredHadErrors := a.autoDeepenWebResearch(ctx, input.RunID, latestUserRequest, successfulToolCalls, browserUserTab)
                                                if recoveredHadErrors </span><span class="cov0" title="0">{
                                                        hadToolErrors = true
                                                }</span>
                                                <span class="cov8" title="1">if len(recoveredCalls) &gt; 0 </span><span class="cov8" title="1">{
                                                        successfulToolCalls = append(successfulToolCalls, recoveredCalls...)
                                                        uniqueSources, extractCount = summarizeWebResearchEvidenceForRequest(successfulToolCalls, latestUserRequest)
                                                        linkCount = countSourceLinks(response)
                                                        if hasSufficientWebResearchEvidenceForRequest(successfulToolCalls, researchRequirements, latestUserRequest) </span><span class="cov0" title="0">{
                                                                final := a.composeBestEffortFinalResponse(ctx, input.RunID, providers, llmMessages, latestUserRequest, successfulToolCalls, researchRequirements, hadToolErrors, nil)
                                                                if strings.TrimSpace(final) == "" </span><span class="cov0" title="0">{
                                                                        final = buildDeterministicWebResearchSummaryForRequest(successfulToolCalls, researchRequirements, latestUserRequest)
                                                                }</span>
                                                                <span class="cov0" title="0">if err := a.postMessage(ctx, input.RunID, final); err != nil </span><span class="cov0" title="0">{
                                                                        return err
                                                                }</span>
                                                                <span class="cov0" title="0">status := ternaryStatus(hadToolErrors)
                                                                _ = a.emitEvent(ctx, input.RunID, "step.completed", map[string]any{
                                                                        "step_id": "assistant_reply",
                                                                        "name":    "Generate assistant reply",
                                                                        "status":  status,
                                                                })
                                                                completionReason := "research_evidence_complete"
                                                                if hadToolErrors </span><span class="cov0" title="0">{
                                                                        completionReason = "partial_tool_errors"
                                                                }</span>
                                                                <span class="cov0" title="0">_ = a.postCompletionEvent(ctx, input.RunID, status, completionReason)
                                                                a.maybeGenerateRunTitle(ctx, input.RunID, primaryProvider, messages, final)
                                                                return nil</span>
                                                        }
                                                        <span class="cov8" title="1">if shouldRepromptForWebResearch(researchRequirements, uniqueSources, extractCount, linkCount) </span><span class="cov8" title="1">{
                                                                llmMessages = append(llmMessages,
                                                                        llm.Message{Role: "assistant", Content: response},
                                                                        llm.Message{Role: "system", Content: buildWebResearchRetryPrompt(researchRequirements, uniqueSources, extractCount, linkCount)},
                                                                )
                                                                llmMessages = clampConversationWindow(llmMessages, maxConversationMessages, maxConversationChars)
                                                                continue</span>
                                                        }
                                                }
                                        }
                                        <span class="cov8" title="1">final := buildInsufficientWebResearchFallback(successfulToolCalls, researchRequirements, latestUserRequest, response)
                                        if err := a.postMessage(ctx, input.RunID, final); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov8" title="1">_ = a.emitEvent(ctx, input.RunID, "step.completed", map[string]any{
                                                "step_id": "assistant_reply",
                                                "name":    "Generate assistant reply",
                                                "status":  "partial",
                                        })
                                        _ = a.postCompletionEvent(ctx, input.RunID, "partial", "insufficient_web_research_evidence")
                                        a.maybeGenerateRunTitle(ctx, input.RunID, primaryProvider, messages, final)
                                        return nil</span>
                                }
                        }
                        <span class="cov8" title="1">finalResponse := strings.TrimSpace(stripFencedToolBlocks(response))
                        if finalResponse == "" </span><span class="cov0" title="0">{
                                finalResponse = response
                        }</span>
                        <span class="cov8" title="1">if researchRequirements.Enabled &amp;&amp; (responseHasLowResearchQuality(finalResponse) || strings.Contains(strings.ToLower(finalResponse), "&lt;think&gt;")) </span><span class="cov0" title="0">{
                                synthesized := a.composeBestEffortFinalResponse(ctx, input.RunID, providers, llmMessages, latestUserRequest, successfulToolCalls, researchRequirements, hadToolErrors, nil)
                                if strings.TrimSpace(synthesized) != "" </span><span class="cov0" title="0">{
                                        finalResponse = strings.TrimSpace(synthesized)
                                }</span>
                        }
                        <span class="cov8" title="1">if researchRequirements.Enabled </span><span class="cov0" title="0">{
                                if deterministic := strings.TrimSpace(buildDeterministicWebResearchSummaryForRequest(successfulToolCalls, researchRequirements, latestUserRequest)); deterministic != "" </span><span class="cov0" title="0">{
                                        finalResponse = deterministic
                                }</span>
                        }
                        <span class="cov8" title="1">finalResponse = enforceResearchQualityFallback(finalResponse, successfulToolCalls, researchRequirements, latestUserRequest)
                        if err := a.postMessage(ctx, input.RunID, finalResponse); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">_ = a.emitEvent(ctx, input.RunID, "step.completed", map[string]any{
                                "step_id": "assistant_reply",
                                "name":    "Generate assistant reply",
                                "status":  ternaryStatus(hadToolErrors),
                        })
                        completionReason := "success"
                        if hadToolErrors </span><span class="cov8" title="1">{
                                completionReason = "partial_tool_errors"
                        }</span>
                        <span class="cov8" title="1">_ = a.postCompletionEvent(ctx, input.RunID, ternaryStatus(hadToolErrors), completionReason)
                        a.maybeGenerateRunTitle(ctx, input.RunID, primaryProvider, messages, finalResponse)
                        return nil</span>
                }
                <span class="cov8" title="1">if a.toolRunner == "" </span><span class="cov8" title="1">{
                        _ = a.postEvent(ctx, input.RunID, "tool.failed", map[string]any{"error": "tool runner url not configured"})
                        hadToolErrors = true
                        llmMessages = append(llmMessages,
                                llm.Message{Role: "assistant", Content: response},
                                llm.Message{Role: "system", Content: "Tool execution is currently unavailable because the tool runner is not configured. Provide a helpful response without using tools, and explain this limitation briefly."},
                        )
                        llmMessages = clampConversationWindow(llmMessages, maxConversationMessages, maxConversationChars)
                        continue</span>
                }
                <span class="cov8" title="1">pendingToolBlock = ""
                toolRecoveryRepromptCount = 0
                llmMessages = append(llmMessages, llm.Message{Role: "assistant", Content: response})
                if len(toolCalls) &gt; maxToolCalls </span><span class="cov0" title="0">{
                        toolCalls = toolCalls[:maxToolCalls]
                }</span>
                <span class="cov8" title="1">for _, call := range toolCalls </span><span class="cov8" title="1">{
                        if !isToolAllowed(call.ToolName) </span><span class="cov0" title="0">{
                                err := fmt.Errorf("tool not allowed: %s", call.ToolName)
                                _ = a.postEvent(ctx, input.RunID, "tool.failed", buildToolFailurePayload(call.ToolName, err))
                                hadToolErrors = true
                                llmMessages = append(llmMessages, llm.Message{Role: "system", Content: formatToolResult(call.ToolName, nil, err)})
                                llmMessages = clampConversationWindow(llmMessages, maxConversationMessages, maxConversationChars)
                                continue</span>
                        }
                        <span class="cov8" title="1">output, err := a.executeToolCall(ctx, input.RunID, call, browserUserTab)
                        if err != nil </span><span class="cov8" title="1">{
                                _ = a.postEvent(ctx, input.RunID, "tool.failed", buildToolFailurePayload(call.ToolName, err))
                                hadToolErrors = true
                                llmMessages = append(llmMessages, llm.Message{Role: "system", Content: formatToolResult(call.ToolName, nil, err)})
                                llmMessages = clampConversationWindow(llmMessages, maxConversationMessages, maxConversationChars)
                                continue</span>
                        }
                        <span class="cov8" title="1">successfulToolCalls = append(successfulToolCalls, toolCall{ToolName: call.ToolName, Input: output})
                        llmMessages = append(llmMessages, llm.Message{Role: "system", Content: formatToolResult(call.ToolName, output, nil)})
                        llmMessages = clampConversationWindow(llmMessages, maxConversationMessages, maxConversationChars)</span>
                }
                <span class="cov8" title="1">if researchRequirements.Enabled &amp;&amp; hasSufficientWebResearchEvidenceForRequest(successfulToolCalls, researchRequirements, latestUserRequest) </span><span class="cov0" title="0">{
                        final := a.composeBestEffortFinalResponse(ctx, input.RunID, providers, llmMessages, latestUserRequest, successfulToolCalls, researchRequirements, hadToolErrors, nil)
                        if strings.TrimSpace(final) == "" </span><span class="cov0" title="0">{
                                final = buildDeterministicWebResearchSummaryForRequest(successfulToolCalls, researchRequirements, latestUserRequest)
                        }</span>
                        <span class="cov0" title="0">if err := a.postMessage(ctx, input.RunID, final); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">status := ternaryStatus(hadToolErrors)
                        _ = a.emitEvent(ctx, input.RunID, "step.completed", map[string]any{
                                "step_id": "assistant_reply",
                                "name":    "Generate assistant reply",
                                "status":  status,
                        })
                        completionReason := "research_evidence_complete"
                        if hadToolErrors </span><span class="cov0" title="0">{
                                completionReason = "partial_tool_errors"
                        }</span>
                        <span class="cov0" title="0">_ = a.postCompletionEvent(ctx, input.RunID, status, completionReason)
                        a.maybeGenerateRunTitle(ctx, input.RunID, primaryProvider, messages, final)
                        return nil</span>
                }
        }
        <span class="cov8" title="1">if lastResponse != "" </span><span class="cov8" title="1">{
                if researchRequirements.Enabled &amp;&amp; !hasSufficientWebResearchEvidenceForRequest(successfulToolCalls, researchRequirements, latestUserRequest) </span><span class="cov0" title="0">{
                        if !autoWebResearchRecoveryAttempted </span><span class="cov0" title="0">{
                                recoveredCalls, recoveredHadErrors := a.autoDeepenWebResearch(ctx, input.RunID, latestUserRequest, successfulToolCalls, browserUserTab)
                                if recoveredHadErrors </span><span class="cov0" title="0">{
                                        hadToolErrors = true
                                }</span>
                                <span class="cov0" title="0">if len(recoveredCalls) &gt; 0 </span><span class="cov0" title="0">{
                                        successfulToolCalls = append(successfulToolCalls, recoveredCalls...)
                                }</span>
                        }
                }
                <span class="cov8" title="1">if researchRequirements.Enabled &amp;&amp; !hasSufficientWebResearchEvidenceForRequest(successfulToolCalls, researchRequirements, latestUserRequest) </span><span class="cov0" title="0">{
                        final := buildInsufficientWebResearchFallback(successfulToolCalls, researchRequirements, latestUserRequest, lastResponse)
                        if err := a.postMessage(ctx, input.RunID, final); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">_ = a.emitEvent(ctx, input.RunID, "step.completed", map[string]any{
                                "step_id": "assistant_reply",
                                "name":    "Generate assistant reply",
                                "status":  "partial",
                        })
                        _ = a.postCompletionEvent(ctx, input.RunID, "partial", "insufficient_web_research_evidence")
                        a.maybeGenerateRunTitle(ctx, input.RunID, primaryProvider, messages, final)
                        return nil</span>
                }
                <span class="cov8" title="1">final := strings.TrimSpace(stripFencedToolBlocks(lastResponse))
                if researchRequirements.Enabled </span><span class="cov0" title="0">{
                        synthesized := a.composeBestEffortFinalResponse(ctx, input.RunID, providers, llmMessages, latestUserRequest, successfulToolCalls, researchRequirements, hadToolErrors, nil)
                        if strings.TrimSpace(synthesized) == "" </span><span class="cov0" title="0">{
                                if hasSufficientWebResearchEvidenceForRequest(successfulToolCalls, researchRequirements, latestUserRequest) </span><span class="cov0" title="0">{
                                        synthesized = buildDeterministicWebResearchSummaryForRequest(successfulToolCalls, researchRequirements, latestUserRequest)
                                }</span> else<span class="cov0" title="0"> {
                                        synthesized = buildInsufficientWebResearchFallback(successfulToolCalls, researchRequirements, latestUserRequest, lastResponse)
                                }</span>
                        }
                        <span class="cov0" title="0">if strings.TrimSpace(synthesized) != "" </span><span class="cov0" title="0">{
                                final = synthesized
                        }</span>
                }
                <span class="cov8" title="1">if final == "" &amp;&amp; len(successfulToolCalls) &gt; 0 </span><span class="cov8" title="1">{
                        final = a.composeBestEffortFinalResponse(ctx, input.RunID, providers, llmMessages, latestUserRequest, successfulToolCalls, researchRequirements, hadToolErrors, nil)
                }</span>
                <span class="cov8" title="1">if final == "" </span><span class="cov0" title="0">{
                        final = buildToolExecutionFallback(successfulToolCalls)
                }</span>
                <span class="cov8" title="1">if researchRequirements.Enabled </span><span class="cov0" title="0">{
                        if deterministic := strings.TrimSpace(buildDeterministicWebResearchSummaryForRequest(successfulToolCalls, researchRequirements, latestUserRequest)); deterministic != "" </span><span class="cov0" title="0">{
                                final = deterministic
                        }</span>
                }
                <span class="cov8" title="1">final = enforceResearchQualityFallback(final, successfulToolCalls, researchRequirements, latestUserRequest)
                if err := a.postMessage(ctx, input.RunID, final); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">status := ternaryStatus(hadToolErrors)
                completionReason := "max_iterations"
                if !hadToolErrors </span><span class="cov8" title="1">{
                        completionReason = "success"
                }</span>
                <span class="cov8" title="1">if researchRequirements.Enabled </span><span class="cov0" title="0">{
                        if hasSufficientWebResearchEvidenceForRequest(successfulToolCalls, researchRequirements, latestUserRequest) </span><span class="cov0" title="0">{
                                if !hadToolErrors </span><span class="cov0" title="0">{
                                        status = "completed"
                                        completionReason = "research_evidence_complete"
                                }</span> else<span class="cov0" title="0"> {
                                        status = "partial"
                                        completionReason = "partial_tool_errors"
                                }</span>
                        } else<span class="cov0" title="0"> {
                                status = "partial"
                                completionReason = "insufficient_web_research_evidence"
                        }</span>
                }
                <span class="cov8" title="1">_ = a.emitEvent(ctx, input.RunID, "step.completed", map[string]any{
                        "step_id": "assistant_reply",
                        "name":    "Generate assistant reply",
                        "status":  status,
                })
                _ = a.postCompletionEvent(ctx, input.RunID, status, completionReason)
                a.maybeGenerateRunTitle(ctx, input.RunID, primaryProvider, messages, final)
                return nil</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (a *RunActivities) HandleRunFailure(ctx context.Context, input RunFailureInput) error <span class="cov8" title="1">{
        if strings.TrimSpace(input.RunID) == "" </span><span class="cov8" title="1">{
                return errors.New("run_id required")
        }</span>
        <span class="cov8" title="1">detail := strings.TrimSpace(input.Error)
        if detail == "" </span><span class="cov0" title="0">{
                detail = "unknown workflow activity error"
        }</span>
        <span class="cov8" title="1">payload := map[string]any{
                "error":             detail,
                "phase":             "failed",
                "completion_reason": "activity_error",
        }
        if err := a.postEvent(ctx, input.RunID, "run.failed", payload); err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return a.appendLocalEvent(ctx, input.RunID, "run.failed", "llm", payload)</span>
}

func ternaryStatus(partial bool) string <span class="cov8" title="1">{
        if partial </span><span class="cov8" title="1">{
                return "partial"
        }</span>
        <span class="cov8" title="1">return "completed"</span>
}

func (a *RunActivities) postCompletionEvent(ctx context.Context, runID string, status string, reason string) error <span class="cov8" title="1">{
        eventType := "run.completed"
        if strings.EqualFold(status, "partial") </span><span class="cov8" title="1">{
                eventType = "run.partial"
        }</span>
        <span class="cov8" title="1">payload := map[string]any{
                "status":            status,
                "phase":             "completed",
                "completion_reason": reason,
        }
        var eventErr error
        if err := a.postEvent(ctx, runID, eventType, payload); err != nil </span><span class="cov0" title="0">{
                eventErr = a.appendLocalEvent(ctx, runID, eventType, "llm", payload)
        }</span>
        <span class="cov8" title="1">_ = a.cleanupRunResources(ctx, runID)
        return eventErr</span>
}

func (a *RunActivities) emitEvent(ctx context.Context, runID string, eventType string, payload map[string]any) error <span class="cov8" title="1">{
        if err := a.postEvent(ctx, runID, eventType, payload); err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return a.appendLocalEvent(ctx, runID, eventType, "llm", payload)</span>
}

func (a *RunActivities) appendLocalEvent(ctx context.Context, runID string, eventType string, source string, payload map[string]any) error <span class="cov8" title="1">{
        seq, err := a.store.NextSeq(ctx, runID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return a.store.AppendEvent(ctx, store.RunEvent{
                RunID:     runID,
                Seq:       seq,
                Type:      eventType,
                Timestamp: time.Now().UTC().Format(time.RFC3339Nano),
                Source:    source,
                TraceID:   uuid.New().String(),
                Payload:   payload,
        })</span>
}

func (a *RunActivities) buildProviderCandidates(cfg llm.Config, modelRoute string) ([]llmProviderCandidate, error) <span class="cov8" title="1">{
        candidates := make([]llmProviderCandidate, 0, 4)
        seen := map[string]struct{}{}

        appendCandidate := func(name string, candidateCfg llm.Config, required bool) error </span><span class="cov8" title="1">{
                key := strings.TrimSpace(candidateCfg.Provider) + "|" + strings.TrimSpace(candidateCfg.Model)
                if _, exists := seen[key]; exists </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">provider, err := newProvider(candidateCfg)
                if err != nil </span><span class="cov8" title="1">{
                        if required </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov8" title="1">seen[key] = struct{}{}
                candidates = append(candidates, llmProviderCandidate{
                        Name:     strings.TrimSpace(name),
                        Provider: provider,
                })
                return nil</span>
        }

        <span class="cov8" title="1">routeEntries := parseModelRoute(modelRoute)
        if len(routeEntries) &gt; 0 </span><span class="cov8" title="1">{
                for _, entry := range routeEntries </span><span class="cov8" title="1">{
                        routeCfg := cfg
                        routeCfg.Provider = entry.provider
                        if entry.model != "" </span><span class="cov8" title="1">{
                                routeCfg.Model = entry.model
                        }</span>
                        <span class="cov8" title="1">_ = appendCandidate(entry.provider, routeCfg, false)</span>
                }
                <span class="cov8" title="1">if len(candidates) &gt; 0 </span><span class="cov8" title="1">{
                        return candidates, nil
                }</span>
        }
        <span class="cov8" title="1">if err := appendCandidate(strings.TrimSpace(cfg.Provider), cfg, true); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">fallbackProvider := strings.TrimSpace(cfg.FallbackProvider)
        if fallbackProvider != "" </span><span class="cov8" title="1">{
                fallbackCfg := cfg
                fallbackCfg.Provider = fallbackProvider
                if model := strings.TrimSpace(cfg.FallbackModel); model != "" </span><span class="cov8" title="1">{
                        fallbackCfg.Model = model
                }</span>
                <span class="cov8" title="1">if baseURL := strings.TrimSpace(cfg.FallbackBaseURL); baseURL != "" </span><span class="cov0" title="0">{
                        fallbackCfg.BaseURL = baseURL
                }</span>
                <span class="cov8" title="1">_ = appendCandidate(fallbackProvider, fallbackCfg, false)</span>
        }

        <span class="cov8" title="1">return candidates, nil</span>
}

type modelRouteEntry struct {
        provider string
        model    string
}

func parseModelRoute(raw string) []modelRouteEntry <span class="cov8" title="1">{
        raw = strings.TrimSpace(raw)
        if raw == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">parts := strings.FieldsFunc(raw, func(r rune) bool </span><span class="cov8" title="1">{
                return r == ',' || r == ';' || r == '\n'
        }</span>)
        <span class="cov8" title="1">results := make([]modelRouteEntry, 0, len(parts))
        for _, part := range parts </span><span class="cov8" title="1">{
                part = strings.TrimSpace(part)
                if part == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">provider := part
                model := ""
                if strings.Contains(part, ":") </span><span class="cov8" title="1">{
                        split := strings.SplitN(part, ":", 2)
                        provider = strings.TrimSpace(split[0])
                        model = strings.TrimSpace(split[1])
                }</span>
                <span class="cov8" title="1">if provider == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">results = append(results, modelRouteEntry{provider: provider, model: model})</span>
        }
        <span class="cov8" title="1">return results</span>
}

func (a *RunActivities) resolveModelRoute(ctx context.Context, runID string, messages []store.Message) string <span class="cov8" title="1">{
        for i := len(messages) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if messages[i].Role != "user" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if route := readString(messages[i].Metadata, "model_route"); route != "" </span><span class="cov0" title="0">{
                        return route
                }</span>
        }
        <span class="cov8" title="1">if strings.TrimSpace(runID) == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">eventsList, err := a.store.ListEvents(ctx, runID, 0)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">for i := len(eventsList) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if eventsList[i].Type != "run.started" &amp;&amp; eventsList[i].Type != "run.resumed" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">if route := readString(eventsList[i].Payload, "model_route"); route != "" </span><span class="cov0" title="0">{
                        return route
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func (a *RunActivities) resolveConfig(ctx context.Context, messages []store.Message) (llm.Config, error) <span class="cov8" title="1">{
        cfg := a.defaultConfig
        settings, err := a.store.GetLLMSettings(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return cfg, err
        }</span>
        <span class="cov8" title="1">if settings != nil </span><span class="cov8" title="1">{
                cfg.Mode = settings.Mode
                cfg.Provider = settings.Provider
                cfg.Model = settings.Model
                cfg.BaseURL = settings.BaseURL
                cfg.CodexAuthPath = settings.CodexAuthPath
                cfg.CodexHome = settings.CodexHome
                if settings.APIKeyEnc != "" </span><span class="cov8" title="1">{
                        if a.secretsKey == nil </span><span class="cov8" title="1">{
                                return cfg, errors.New("LLM_SECRETS_KEY is required to decrypt API keys")
                        }</span>
                        <span class="cov8" title="1">apiKey, err := decryptSecret(a.secretsKey, settings.APIKeyEnc)
                        if err != nil </span><span class="cov8" title="1">{
                                return cfg, err
                        }</span>
                        <span class="cov8" title="1">switch settings.Provider </span>{
                        case "openrouter":<span class="cov8" title="1">
                                cfg.OpenRouterAPIKey = apiKey</span>
                        case "opencode-zen":<span class="cov0" title="0">
                                cfg.OpenCodeAPIKey = apiKey</span>
                        default:<span class="cov8" title="1">
                                cfg.OpenAIAPIKey = apiKey</span>
                        }
                }
        }
        <span class="cov8" title="1">if overrideProvider, overrideModel := extractOverrides(messages); overrideProvider != "" || overrideModel != "" </span><span class="cov8" title="1">{
                if overrideProvider != "" </span><span class="cov8" title="1">{
                        cfg.Provider = overrideProvider
                }</span>
                <span class="cov8" title="1">if overrideModel != "" </span><span class="cov8" title="1">{
                        cfg.Model = overrideModel
                }</span>
        }
        <span class="cov8" title="1">if requiresAPIKey(cfg.Provider) </span><span class="cov8" title="1">{
                if cfg.Provider == "openrouter" </span><span class="cov8" title="1">{
                        if cfg.OpenRouterAPIKey == "" </span><span class="cov8" title="1">{
                                return cfg, errors.New("missing API key for provider")
                        }</span>
                } else<span class="cov8" title="1"> if cfg.OpenAIAPIKey == "" </span><span class="cov8" title="1">{
                        return cfg, errors.New("missing API key for provider")
                }</span>
        }
        <span class="cov8" title="1">return cfg, nil</span>
}

func extractOverrides(messages []store.Message) (string, string) <span class="cov8" title="1">{
        for i := len(messages) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                msg := messages[i]
                if msg.Role != "user" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">provider := readString(msg.Metadata, "llm_provider")
                model := readString(msg.Metadata, "llm_model")
                return provider, model</span>
        }
        <span class="cov8" title="1">return "", ""</span>
}

func resolveBrowserUserTabConfig(messages []store.Message) browserUserTabConfig <span class="cov8" title="1">{
        config := browserUserTabConfig{}
        for i := len(messages) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                msg := messages[i]
                if msg.Role != "user" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">mode := strings.ToLower(readString(msg.Metadata, "browser_mode"))
                if mode == "" </span><span class="cov8" title="1">{
                        mode = strings.ToLower(readString(msg.Metadata, "browser_control_mode"))
                }</span>
                <span class="cov8" title="1">if mode != "user_tab" </span><span class="cov8" title="1">{
                        return config
                }</span>
                <span class="cov8" title="1">config.Enabled = true
                interaction := strings.ToLower(readString(msg.Metadata, "browser_interaction"))
                switch interaction </span>{
                case "", "true", "allow", "allowed", "enabled", "interactive":<span class="cov8" title="1">
                        config.InteractionAllowed = true</span>
                }
                <span class="cov8" title="1">config.DomainAllowlist = parseDomainAllowlist(readString(msg.Metadata, "browser_domain_allowlist"))
                config.BrowserUserAgent = strings.TrimSpace(readString(msg.Metadata, "browser_user_agent"))
                config.PreferredBrowser = normalizePreferredBrowser(firstNonEmptyString(
                        readString(msg.Metadata, "browser_preferred_browser"),
                        readString(msg.Metadata, "browser_browser"),
                        inferPreferredBrowserFromUserAgent(config.BrowserUserAgent),
                ))
                return config</span>
        }
        <span class="cov8" title="1">return config</span>
}

func normalizePreferredBrowser(raw string) string <span class="cov8" title="1">{
        value := strings.ToLower(strings.TrimSpace(raw))
        switch value </span>{
        case "brave", "brave browser":<span class="cov8" title="1">
                return "brave"</span>
        case "chrome", "google chrome":<span class="cov0" title="0">
                return "chrome"</span>
        case "edge", "microsoft edge":<span class="cov0" title="0">
                return "edge"</span>
        case "chromium":<span class="cov0" title="0">
                return "chromium"</span>
        case "arc":<span class="cov0" title="0">
                return "arc"</span>
        case "opera":<span class="cov0" title="0">
                return "opera"</span>
        case "vivaldi":<span class="cov0" title="0">
                return "vivaldi"</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}

func inferPreferredBrowserFromUserAgent(userAgent string) string <span class="cov8" title="1">{
        ua := strings.ToLower(strings.TrimSpace(userAgent))
        switch </span>{
        case strings.Contains(ua, "brave"):<span class="cov8" title="1">
                return "brave"</span>
        case strings.Contains(ua, "edg/"):<span class="cov0" title="0">
                return "edge"</span>
        case strings.Contains(ua, "opr/") || strings.Contains(ua, "opera"):<span class="cov0" title="0">
                return "opera"</span>
        case strings.Contains(ua, "vivaldi"):<span class="cov0" title="0">
                return "vivaldi"</span>
        case strings.Contains(ua, "arc/") || strings.Contains(ua, " arc"):<span class="cov0" title="0">
                return "arc"</span>
        case strings.Contains(ua, "chromium"):<span class="cov0" title="0">
                return "chromium"</span>
        case strings.Contains(ua, "chrome/"):<span class="cov0" title="0">
                return "chrome"</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}

func parseDomainAllowlist(raw string) []string <span class="cov8" title="1">{
        raw = strings.TrimSpace(raw)
        if raw == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">parts := strings.FieldsFunc(raw, func(r rune) bool </span><span class="cov8" title="1">{
                return r == ',' || r == ';' || r == '\n' || r == '\t' || r == ' '
        }</span>)
        <span class="cov8" title="1">if len(parts) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">seen := map[string]struct{}{}
        out := make([]string, 0, len(parts))
        for _, part := range parts </span><span class="cov8" title="1">{
                candidate := strings.ToLower(strings.TrimSpace(part))
                if candidate == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(candidate, "http://") || strings.HasPrefix(candidate, "https://") </span><span class="cov8" title="1">{
                        if parsed, err := url.Parse(candidate); err == nil </span><span class="cov8" title="1">{
                                candidate = strings.ToLower(strings.TrimSpace(parsed.Hostname()))
                        }</span>
                }
                <span class="cov8" title="1">candidate = strings.TrimPrefix(candidate, ".")
                if candidate == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, exists := seen[candidate]; exists </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">seen[candidate] = struct{}{}
                out = append(out, candidate)</span>
        }
        <span class="cov8" title="1">if len(out) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return out</span>
}

func (a *RunActivities) buildMemoryPrompt(ctx context.Context, messages []store.Message) string <span class="cov8" title="1">{
        settings, err := a.store.GetMemorySettings(ctx)
        if err != nil || settings == nil || !settings.Enabled </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">query := ""
        var queryEmbedding []float32
        for i := len(messages) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if messages[i].Role == "user" &amp;&amp; strings.TrimSpace(messages[i].Content) != "" </span><span class="cov8" title="1">{
                        query = messages[i].Content
                        // TODO: generate embeddings for user queries when an embedding provider is configured.
                        queryEmbedding = readFloat32Slice(messages[i].Metadata, "embedding")
                        break</span>
                }
        }
        <span class="cov8" title="1">if query == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">limit := a.memoryMaxResults
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 5
        }</span>
        <span class="cov8" title="1">var entries []store.MemoryEntry
        if len(queryEmbedding) &gt; 0 </span><span class="cov8" title="1">{
                entries, err = a.store.SearchMemoryWithEmbedding(ctx, query, queryEmbedding, limit)
        }</span> else<span class="cov8" title="1"> {
                entries, err = a.store.SearchMemory(ctx, query, limit)
        }</span>
        <span class="cov8" title="1">if err != nil || len(entries) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">lines := make([]string, 0, len(entries)+1)
        lines = append(lines, "Relevant memory:")
        for _, entry := range entries </span><span class="cov8" title="1">{
                content := strings.TrimSpace(entry.Content)
                if content == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if a.memoryMaxEntryChars &gt; 0 </span><span class="cov8" title="1">{
                        content = truncateRunes(content, a.memoryMaxEntryChars)
                }</span>
                <span class="cov8" title="1">lines = append(lines, "- "+content)</span>
        }
        <span class="cov8" title="1">return strings.Join(lines, "\n")</span>
}

func (a *RunActivities) buildSystemPrompt(ctx context.Context) string <span class="cov8" title="1">{
        personalityText := a.resolvePersonality(ctx)
        currentTime := time.Now().UTC()
        skillsRoot := "~/.config/opencode/skills"
        if root, err := skills.RootDir(); err == nil </span><span class="cov8" title="1">{
                skillsRoot = root
        }</span>
        <span class="cov8" title="1">memoryEnabled := false
        if settings, err := a.store.GetMemorySettings(ctx); err == nil &amp;&amp; settings != nil </span><span class="cov8" title="1">{
                memoryEnabled = settings.Enabled
        }</span>
        <span class="cov8" title="1">capabilities := a.detectToolCapabilities(ctx)
        runtimeLines := []string{
                "Runtime context:",
                fmt.Sprintf("- Current date/time (UTC): %s", currentTime.Format(time.RFC3339)),
                fmt.Sprintf("- Tool runner availability: %s.", capabilities.runnerStatus),
                fmt.Sprintf("- Browser tool availability: %s.", capabilities.browserStatus),
                fmt.Sprintf("- Available tool families: %s.", capabilities.familiesLine),
                "- For web research or code/file tasks, execute tools immediately instead of replying with intent-only prose.",
                "- For software generation tasks, create/update files with editor tools, validate with process.exec, and use process.start/process.status/process.logs for long-running dev servers.",
                "- Browser tool names must be canonical: browser.navigate, browser.snapshot, browser.click, browser.type, browser.scroll, browser.extract, browser.evaluate, browser.pdf. Do not invent aliases like browser.search/browser.browse.",
                "- Use tools only when they are available; if unavailable, state that clearly and do not imply files or commands were created/executed.",
                "- To call tools, respond with a fenced JSON block: ```tool {\"tool_calls\":[{\"tool_name\":\"editor.write\",\"input\":{...}}]} ```.",
        }
        lines := []string{
                "System resources:",
                fmt.Sprintf("- Skills directory: %s (each skill has SKILL.md and optional references/ and scripts/).", skillsRoot),
                "- Context root: /context (virtual tree stored in the control plane; paths are relative to this root).",
                "- Skills may reference context paths when relevant.",
        }
        if memoryEnabled </span><span class="cov8" title="1">{
                lines = append(lines, "- Memory: enabled; use relevant memory entries when provided.")
        }</span> else<span class="cov8" title="1"> {
                lines = append(lines, "- Memory: disabled unless the user enables it.")
        }</span>
        <span class="cov8" title="1">blocks := []string{}
        if strings.TrimSpace(personalityText) != "" </span><span class="cov8" title="1">{
                blocks = append(blocks, strings.TrimSpace(personalityText))
        }</span>
        <span class="cov8" title="1">blocks = append(blocks, strings.Join(runtimeLines, "\n"))
        blocks = append(blocks, strings.Join(lines, "\n"))
        return strings.Join(blocks, "\n\n")</span>
}

func (a *RunActivities) resolvePersonality(ctx context.Context) string <span class="cov8" title="1">{
        if settings, err := a.store.GetPersonalitySettings(ctx); err == nil &amp;&amp; settings != nil </span><span class="cov0" title="0">{
                if content := strings.TrimSpace(settings.Content); content != "" </span><span class="cov0" title="0">{
                        return content
                }</span>
        }
        <span class="cov8" title="1">if content, err := personality.ReadFromDisk(); err == nil </span><span class="cov8" title="1">{
                if trimmed := strings.TrimSpace(content); trimmed != "" </span><span class="cov8" title="1">{
                        return trimmed
                }</span>
        }
        <span class="cov8" title="1">return personality.Default</span>
}

func readString(metadata map[string]any, key string) string <span class="cov8" title="1">{
        if metadata == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">value, ok := metadata[key]
        if !ok </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if s, ok := value.(string); ok </span><span class="cov8" title="1">{
                return strings.TrimSpace(s)
        }</span>
        <span class="cov8" title="1">return ""</span>
}

func readFloat32Slice(metadata map[string]any, key string) []float32 <span class="cov8" title="1">{
        if metadata == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">value, ok := metadata[key]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">slice, ok := value.([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">results := make([]float32, 0, len(slice))
        for _, item := range slice </span><span class="cov8" title="1">{
                switch v := item.(type) </span>{
                case float32:<span class="cov0" title="0">
                        results = append(results, v)</span>
                case float64:<span class="cov8" title="1">
                        results = append(results, float32(v))</span>
                case int:<span class="cov0" title="0">
                        results = append(results, float32(v))</span>
                case int64:<span class="cov0" title="0">
                        results = append(results, float32(v))</span>
                case json.Number:<span class="cov0" title="0">
                        if parsed, err := v.Float64(); err == nil </span><span class="cov0" title="0">{
                                results = append(results, float32(parsed))
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(results) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return results</span>
}

func truncateRunes(value string, maxChars int) string <span class="cov8" title="1">{
        if maxChars &lt;= 0 </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov8" title="1">runes := []rune(value)
        if len(runes) &lt;= maxChars </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return string(runes[:maxChars]) + ""</span>
}

func requiresAPIKey(provider string) bool <span class="cov8" title="1">{
        switch provider </span>{
        case "openai", "openrouter", "opencode-zen", "kimi-for-coding", "moonshot-ai":<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

type toolParseStatus struct {
        sawToolBlock  bool
        hadIncomplete bool
        hadOversized  bool
}

func parseToolCalls(content string) ([]toolCall, toolParseStatus) <span class="cov8" title="1">{
        content = trimForToolParsing(content)
        if inlineCalls := parseInlineFencedToolCalls(content); len(inlineCalls) &gt; 0 </span><span class="cov8" title="1">{
                return inlineCalls, toolParseStatus{sawToolBlock: true}
        }</span>
        <span class="cov8" title="1">blocks := extractFencedBlocks(content)
        status := toolParseStatus{}
        for _, block := range blocks </span><span class="cov8" title="1">{
                lang := strings.ToLower(strings.TrimSpace(block.lang))
                if lang != "tool" &amp;&amp; lang != "json" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if lang == "tool" </span><span class="cov8" title="1">{
                        status.sawToolBlock = true
                }</span>
                <span class="cov8" title="1">body := strings.TrimSpace(block.body)
                if !block.complete </span><span class="cov8" title="1">{
                        status.hadIncomplete = true
                        if body != "" </span><span class="cov8" title="1">{
                                status.sawToolBlock = true
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">if body == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if len(body) &gt; maxToolJSONChars </span><span class="cov0" title="0">{
                        status.hadOversized = true
                        status.sawToolBlock = true
                        continue</span>
                }
                <span class="cov8" title="1">if lang == "json" &amp;&amp; (strings.Contains(body, "\"tool_calls\"") || strings.Contains(body, "\"tool_name\"")) </span><span class="cov0" title="0">{
                        status.sawToolBlock = true
                }</span>
                <span class="cov8" title="1">var payload map[string]any
                if err := json.Unmarshal([]byte(body), &amp;payload); err != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">calls := parseToolCallsFromPayload(payload)
                if len(calls) &gt; 0 </span><span class="cov0" title="0">{
                        return calls, status
                }</span>
        }
        <span class="cov8" title="1">if directCalls := parseBareToolPayload(content); len(directCalls) &gt; 0 </span><span class="cov8" title="1">{
                status.sawToolBlock = true
                return directCalls, status
        }</span>
        <span class="cov8" title="1">return nil, status</span>
}

func parseInlineFencedToolCalls(content string) []toolCall <span class="cov8" title="1">{
        matches := inlineToolFenceRE.FindAllStringSubmatch(content, -1)
        if len(matches) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">calls := make([]toolCall, 0, len(matches))
        for _, match := range matches </span><span class="cov8" title="1">{
                if len(match) &lt; 3 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">payloadText := strings.TrimSpace(match[2])
                if payloadText == "" || len(payloadText) &gt; maxToolJSONChars </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">var payload map[string]any
                if err := json.Unmarshal([]byte(payloadText), &amp;payload); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">parsed := parseToolCallsFromPayload(payload)
                if len(parsed) &gt; 0 </span><span class="cov8" title="1">{
                        calls = append(calls, parsed...)
                }</span>
        }
        <span class="cov8" title="1">if len(calls) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return calls</span>
}

func parseBareToolPayload(content string) []toolCall <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(content)
        if trimmed == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if !strings.HasPrefix(trimmed, "{") || !strings.HasSuffix(trimmed, "}") </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if len(trimmed) &gt; maxToolJSONChars </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">var payload map[string]any
        if err := json.Unmarshal([]byte(trimmed), &amp;payload); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return parseToolCallsFromPayload(payload)</span>
}

func stripFencedToolBlocks(content string) string <span class="cov8" title="1">{
        cleaned := fencedToolBlockRE.ReplaceAllString(content, "")
        return strings.TrimSpace(cleaned)
}</span>

type toolCapabilities struct {
        runnerStatus  string
        browserStatus string
        familiesLine  string
}

func (a *RunActivities) detectToolCapabilities(ctx context.Context) toolCapabilities <span class="cov8" title="1">{
        families := []string{"editor", "process", "document"}
        if a.toolRunner == "" </span><span class="cov8" title="1">{
                return toolCapabilities{
                        runnerStatus:  "unavailable (tool runner URL not configured)",
                        browserStatus: "unavailable",
                        familiesLine:  strings.Join(families, ", "),
                }
        }</span>
        <span class="cov8" title="1">baseURL := strings.TrimRight(a.toolRunner, "/")
        probeCtx, cancel := context.WithTimeout(ctx, 2*time.Second)
        defer cancel()
        healthReq, err := http.NewRequestWithContext(probeCtx, http.MethodGet, baseURL+"/health", nil)
        if err != nil </span><span class="cov0" title="0">{
                return toolCapabilities{runnerStatus: "unavailable", browserStatus: "unavailable", familiesLine: strings.Join(families, ", ")}
        }</span>
        <span class="cov8" title="1">resp, err := a.httpClient.Do(healthReq)
        if err != nil </span><span class="cov8" title="1">{
                return toolCapabilities{runnerStatus: "unavailable", browserStatus: "unavailable", familiesLine: strings.Join(families, ", ")}
        }</span>
        <span class="cov8" title="1">_ = resp.Body.Close()
        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov8" title="1">{
                return toolCapabilities{runnerStatus: fmt.Sprintf("unavailable (health status %d)", resp.StatusCode), browserStatus: "unavailable", familiesLine: strings.Join(families, ", ")}
        }</span>
        <span class="cov0" title="0">runnerStatus := "available"
        browserStatus := "unknown"
        capReq, err := http.NewRequestWithContext(probeCtx, http.MethodGet, baseURL+"/tools/capabilities", nil)
        if err != nil </span><span class="cov0" title="0">{
                return toolCapabilities{runnerStatus: runnerStatus, browserStatus: browserStatus, familiesLine: strings.Join(families, ", ")}
        }</span>
        <span class="cov0" title="0">capResp, err := a.httpClient.Do(capReq)
        if err != nil </span><span class="cov0" title="0">{
                return toolCapabilities{runnerStatus: runnerStatus, browserStatus: browserStatus, familiesLine: strings.Join(families, ", ")}
        }</span>
        <span class="cov0" title="0">defer capResp.Body.Close()
        if capResp.StatusCode &lt; 200 || capResp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return toolCapabilities{runnerStatus: runnerStatus, browserStatus: browserStatus, familiesLine: strings.Join(families, ", ")}
        }</span>
        <span class="cov0" title="0">var payload struct {
                Tools   []string `json:"tools"`
                Browser struct {
                        Enabled bool `json:"enabled"`
                        Healthy bool `json:"healthy"`
                } `json:"browser"`
        }
        if err := json.NewDecoder(capResp.Body).Decode(&amp;payload); err != nil </span><span class="cov0" title="0">{
                return toolCapabilities{runnerStatus: runnerStatus, browserStatus: browserStatus, familiesLine: strings.Join(families, ", ")}
        }</span>
        <span class="cov0" title="0">if payload.Browser.Enabled &amp;&amp; payload.Browser.Healthy </span><span class="cov0" title="0">{
                browserStatus = "available"
                families = append([]string{"browser"}, families...)
        }</span> else<span class="cov0" title="0"> if payload.Browser.Enabled </span><span class="cov0" title="0">{
                browserStatus = "configured but unavailable"
        }</span> else<span class="cov0" title="0"> {
                browserStatus = "unavailable"
        }</span>
        <span class="cov0" title="0">if len(payload.Tools) &gt; 0 </span><span class="cov0" title="0">{
                hasBrowser := false
                hasDocument := false
                hasEditor := false
                hasProcess := false
                for _, name := range payload.Tools </span><span class="cov0" title="0">{
                        switch </span>{
                        case strings.HasPrefix(name, "browser."):<span class="cov0" title="0">
                                hasBrowser = true</span>
                        case strings.HasPrefix(name, "document."):<span class="cov0" title="0">
                                hasDocument = true</span>
                        case strings.HasPrefix(name, "editor."):<span class="cov0" title="0">
                                hasEditor = true</span>
                        case strings.HasPrefix(name, "process."):<span class="cov0" title="0">
                                hasProcess = true</span>
                        }
                }
                <span class="cov0" title="0">families = families[:0]
                if hasBrowser </span><span class="cov0" title="0">{
                        families = append(families, "browser")
                }</span>
                <span class="cov0" title="0">if hasEditor </span><span class="cov0" title="0">{
                        families = append(families, "editor")
                }</span>
                <span class="cov0" title="0">if hasProcess </span><span class="cov0" title="0">{
                        families = append(families, "process")
                }</span>
                <span class="cov0" title="0">if hasDocument </span><span class="cov0" title="0">{
                        families = append(families, "document")
                }</span>
                <span class="cov0" title="0">if len(families) == 0 </span><span class="cov0" title="0">{
                        families = append(families, "none")
                }</span>
        }
        <span class="cov0" title="0">return toolCapabilities{runnerStatus: runnerStatus, browserStatus: browserStatus, familiesLine: strings.Join(families, ", ")}</span>
}

func (a *RunActivities) maybeGenerateRunTitle(ctx context.Context, runID string, provider llm.Provider, messages []store.Message, assistantReply string) <span class="cov8" title="1">{
        if strings.TrimSpace(assistantReply) == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">events, err := a.store.ListEvents(ctx, runID, 0)
        if err == nil </span><span class="cov8" title="1">{
                for i := len(events) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                        if events[i].Type != "run.title.updated" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if title := readString(events[i].Payload, "title"); title != "" </span><span class="cov8" title="1">{
                                return
                        }</span>
                }
        }
        <span class="cov8" title="1">latestUser := ""
        for i := len(messages) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if messages[i].Role == "user" </span><span class="cov8" title="1">{
                        latestUser = strings.TrimSpace(messages[i].Content)
                        if latestUser != "" </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">if latestUser == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">titlePrompt := []llm.Message{
                {Role: "system", Content: "Generate a concise chat title (3-6 words). Return only the title text, no punctuation wrappers."},
                {Role: "user", Content: fmt.Sprintf("User request: %s\n\nAssistant response: %s", truncateRunes(latestUser, 280), truncateRunes(strings.TrimSpace(assistantReply), 600))},
        }
        titleCtx := ctx
        cancel := func() </span>{<span class="cov0" title="0">}</span>
        <span class="cov8" title="1">if runTitleGenerateTimeout &gt; 0 </span><span class="cov8" title="1">{
                titleCtx, cancel = context.WithTimeout(ctx, runTitleGenerateTimeout)
        }</span>
        <span class="cov8" title="1">defer cancel()
        titleRaw, err := provider.Generate(titleCtx, titlePrompt)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">title := sanitizeRunTitle(titleRaw)
        if title == "" </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">seq, err := a.store.NextSeq(ctx, runID)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">_ = a.store.AppendEvent(ctx, store.RunEvent{
                RunID:     runID,
                Seq:       seq,
                Type:      "run.title.updated",
                Timestamp: time.Now().UTC().Format(time.RFC3339Nano),
                Source:    "llm",
                Payload:   map[string]any{"title": title},
        })</span>
}

func sanitizeRunTitle(raw string) string <span class="cov8" title="1">{
        title := strings.TrimSpace(raw)
        title = strings.Trim(title, "`\"' ")
        if idx := strings.Index(title, "\n"); idx &gt;= 0 </span><span class="cov8" title="1">{
                title = strings.TrimSpace(title[:idx])
        }</span>
        <span class="cov8" title="1">title = strings.TrimSuffix(title, ".")
        title = strings.TrimSpace(title)
        if title == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return truncateRunes(title, 72)</span>
}

type fencedBlock struct {
        lang     string
        body     string
        complete bool
}

func extractFencedBlocks(content string) []fencedBlock <span class="cov8" title="1">{
        content = trimForToolParsing(content)
        lines := strings.Split(content, "\n")
        blocks := []fencedBlock{}
        for i := 0; i &lt; len(lines); i++ </span><span class="cov8" title="1">{
                line := strings.TrimSpace(lines[i])
                if !strings.HasPrefix(line, "```") </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">lang := strings.TrimSpace(strings.TrimPrefix(line, "```"))
                bodyLines := []string{}
                complete := false
                for j := i + 1; j &lt; len(lines); j++ </span><span class="cov8" title="1">{
                        if strings.HasPrefix(strings.TrimSpace(lines[j]), "```") </span><span class="cov8" title="1">{
                                i = j
                                complete = true
                                break</span>
                        }
                        <span class="cov8" title="1">bodyLines = append(bodyLines, lines[j])</span>
                }
                <span class="cov8" title="1">blocks = append(blocks, fencedBlock{lang: lang, body: strings.Join(bodyLines, "\n"), complete: complete})</span>
        }
        <span class="cov8" title="1">return blocks</span>
}

func trimForToolParsing(content string) string <span class="cov8" title="1">{
        if maxToolParseContentChars &lt;= 0 || len(content) &lt;= maxToolParseContentChars </span><span class="cov8" title="1">{
                return content
        }</span>
        <span class="cov0" title="0">return content[len(content)-maxToolParseContentChars:]</span>
}

func clampToTail(value string, maxChars int) string <span class="cov8" title="1">{
        if maxChars &lt;= 0 </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov8" title="1">runes := []rune(value)
        if len(runes) &lt;= maxChars </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov0" title="0">return string(runes[len(runes)-maxChars:])</span>
}

func buildPendingToolBlock(content string) string <span class="cov8" title="1">{
        blocks := extractFencedBlocks(content)
        for i := len(blocks) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                block := blocks[i]
                lang := strings.ToLower(strings.TrimSpace(block.lang))
                if block.complete || (lang != "tool" &amp;&amp; lang != "json") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">pending := "```" + strings.TrimSpace(block.lang) + "\n" + block.body
                return clampToTail(pending, maxPendingToolBlockChars)</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func buildToolRecoveryPrompt(status toolParseStatus) string <span class="cov8" title="1">{
        if status.hadIncomplete &amp;&amp; status.hadOversized </span><span class="cov0" title="0">{
                return fmt.Sprintf("Your previous tool block was incomplete and exceeded parser limits. Resend one complete fenced ```tool JSON block, split into smaller calls, and keep each block under %d characters.", maxToolJSONChars)
        }</span>
        <span class="cov8" title="1">if status.hadIncomplete </span><span class="cov8" title="1">{
                return "Your previous tool block looks incomplete (missing closing ``` or truncated JSON). Resend one complete fenced ```tool JSON block only, with no prose before or after."
        }</span>
        <span class="cov8" title="1">if status.hadOversized </span><span class="cov0" title="0">{
                return fmt.Sprintf("Your previous tool block exceeded parser limits. Retry with smaller tool calls and keep each fenced tool JSON block under %d characters.", maxToolJSONChars)
        }</span>
        <span class="cov8" title="1">return "Your previous tool block was invalid and was not executed. Reply with either: (1) one valid fenced ```tool JSON payload, or (2) a normal assistant response with no tool block."</span>
}

func parseToolCallsFromPayload(payload map[string]any) []toolCall <span class="cov8" title="1">{
        if payload == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if rawCalls, ok := payload["tool_calls"].([]any); ok </span><span class="cov8" title="1">{
                calls := make([]toolCall, 0, len(rawCalls))
                for _, raw := range rawCalls </span><span class="cov8" title="1">{
                        if callMap, ok := raw.(map[string]any); ok </span><span class="cov8" title="1">{
                                if call, ok := parseToolCallMap(callMap); ok </span><span class="cov8" title="1">{
                                        calls = append(calls, call)
                                }</span>
                        }
                }
                <span class="cov8" title="1">return calls</span>
        }
        <span class="cov8" title="1">if call, ok := parseToolCallMap(payload); ok </span><span class="cov8" title="1">{
                return []toolCall{call}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func parseToolCallMap(payload map[string]any) (toolCall, bool) <span class="cov8" title="1">{
        if functionData, ok := payload["function"].(map[string]any); ok </span><span class="cov8" title="1">{
                if name := readStringAny(functionData["name"]); name != "" </span><span class="cov8" title="1">{
                        payload["tool_name"] = name
                }</span>
                <span class="cov8" title="1">if _, hasInput := payload["input"]; !hasInput </span><span class="cov8" title="1">{
                        if _, hasArgs := payload["arguments"]; !hasArgs </span><span class="cov8" title="1">{
                                if functionArgs, ok := functionData["arguments"]; ok </span><span class="cov8" title="1">{
                                        payload["arguments"] = functionArgs
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">name := readStringAny(payload["tool_name"])
        if name == "" </span><span class="cov0" title="0">{
                name = readStringAny(payload["name"])
        }</span>
        <span class="cov8" title="1">input := parseToolInputFromPayload(payload)
        name, input = canonicalizeToolCall(name, input)
        if name == "" </span><span class="cov0" title="0">{
                return toolCall{}, false
        }</span>
        <span class="cov8" title="1">return toolCall{ToolName: name, Input: input}, true</span>
}

func parseToolInputFromPayload(payload map[string]any) map[string]any <span class="cov8" title="1">{
        for _, key := range []string{"input", "arguments", "args", "parameters"} </span><span class="cov8" title="1">{
                parsed, ok := parseToolInputValue(payload[key])
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">return parsed</span>
        }
        <span class="cov0" title="0">return map[string]any{}</span>
}

func parseToolInputValue(value any) (map[string]any, bool) <span class="cov8" title="1">{
        switch typed := value.(type) </span>{
        case map[string]any:<span class="cov8" title="1">
                return typed, true</span>
        case string:<span class="cov8" title="1">
                trimmed := strings.TrimSpace(typed)
                if trimmed == "" </span><span class="cov0" title="0">{
                        return map[string]any{}, true
                }</span>
                <span class="cov8" title="1">var parsed map[string]any
                if err := json.Unmarshal([]byte(trimmed), &amp;parsed); err != nil </span><span class="cov0" title="0">{
                        return nil, false
                }</span>
                <span class="cov8" title="1">return parsed, true</span>
        default:<span class="cov8" title="1">
                return nil, false</span>
        }
}

func readStringAny(value any) string <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if str, ok := value.(string); ok </span><span class="cov8" title="1">{
                return strings.TrimSpace(str)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func normalizeToolName(name string) string <span class="cov8" title="1">{
        return strings.ToLower(strings.TrimSpace(name))
}</span>

func canonicalizeToolCall(name string, input map[string]any) (string, map[string]any) <span class="cov8" title="1">{
        canonical := normalizeToolName(name)
        normalizedInput := cloneAnyMap(input)
        switch canonical </span>{
        case "browser.search", "browser.browse", "browser.open", "browser.goto", "browser.visit", "browser.go":<span class="cov8" title="1">
                canonical = "browser.navigate"
                normalizedInput = normalizeBrowserNavigateInput(normalizedInput)</span>
        case "browser.screenshot", "browser.take_screenshot", "browser.capture":<span class="cov0" title="0">
                canonical = "browser.snapshot"</span>
        case "browser.extract_text", "browser.read", "browser.read_text", "browser.get_text":<span class="cov8" title="1">
                canonical = "browser.extract"
                if readStringAny(normalizedInput["mode"]) == "" </span><span class="cov8" title="1">{
                        normalizedInput["mode"] = "text"
                }</span>
        case "browser.extract_list":<span class="cov0" title="0">
                canonical = "browser.extract"
                normalizedInput["mode"] = "list"</span>
        case "browser.extract_table":<span class="cov0" title="0">
                canonical = "browser.extract"
                normalizedInput["mode"] = "table"</span>
        case "browser.extract_metadata":<span class="cov0" title="0">
                canonical = "browser.extract"
                normalizedInput["mode"] = "metadata"</span>
        }
        <span class="cov8" title="1">return canonical, normalizedInput</span>
}

func normalizeBrowserNavigateInput(input map[string]any) map[string]any <span class="cov8" title="1">{
        normalized := cloneAnyMap(input)
        if existingURL := readStringAny(normalized["url"]); existingURL != "" </span><span class="cov0" title="0">{
                return normalized
        }</span>
        <span class="cov8" title="1">for _, key := range []string{"target", "href", "link", "uri"} </span><span class="cov8" title="1">{
                value := readStringAny(normalized[key])
                if strings.HasPrefix(strings.ToLower(value), "http://") || strings.HasPrefix(strings.ToLower(value), "https://") </span><span class="cov8" title="1">{
                        normalized["url"] = value
                        return normalized
                }</span>
        }
        <span class="cov8" title="1">for _, key := range []string{"query", "q", "search", "term", "keywords"} </span><span class="cov8" title="1">{
                queryText := readStringAny(normalized[key])
                if queryText == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">normalized["url"] = "https://duckduckgo.com/?q=" + url.QueryEscape(queryText)
                return normalized</span>
        }
        <span class="cov0" title="0">return normalized</span>
}

func cloneAnyMap(input map[string]any) map[string]any <span class="cov8" title="1">{
        if len(input) == 0 </span><span class="cov0" title="0">{
                return map[string]any{}
        }</span>
        <span class="cov8" title="1">cloned := make(map[string]any, len(input))
        for key, value := range input </span><span class="cov8" title="1">{
                cloned[key] = value
        }</span>
        <span class="cov8" title="1">return cloned</span>
}

func isToolAllowed(name string) bool <span class="cov8" title="1">{
        _, ok := allowedToolNames[normalizeToolName(name)]
        return ok
}</span>

func isNoContentLLMError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">message := strings.ToLower(strings.TrimSpace(err.Error()))
        if message == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return strings.Contains(message, "no content") || strings.Contains(message, "response was empty")</span>
}

func isRetryableLLMError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">message := strings.ToLower(strings.TrimSpace(err.Error()))
        if message == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if strings.Contains(message, "timeout") || strings.Contains(message, "timed out") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if strings.Contains(message, "bad gateway") || strings.Contains(message, "temporarily unavailable") </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if strings.Contains(message, "connection reset") || strings.Contains(message, "connection refused") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if retryableStatusRE.MatchString(message) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func isTimeoutLLMError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if errors.Is(err, context.DeadlineExceeded) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">message := strings.ToLower(strings.TrimSpace(err.Error()))
        if message == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return strings.Contains(message, "timeout") || strings.Contains(message, "timed out")</span>
}

func clampConversationWindow(messages []llm.Message, maxMessages int, maxChars int) []llm.Message <span class="cov8" title="1">{
        if len(messages) == 0 </span><span class="cov0" title="0">{
                return messages
        }</span>
        <span class="cov8" title="1">if maxMessages &lt;= 0 &amp;&amp; maxChars &lt;= 0 </span><span class="cov0" title="0">{
                return messages
        }</span>

        <span class="cov8" title="1">prefixCount := 0
        for prefixCount &lt; len(messages) &amp;&amp; messages[prefixCount].Role == "system" </span><span class="cov8" title="1">{
                prefixCount++
        }</span>
        <span class="cov8" title="1">prefix := append([]llm.Message{}, messages[:prefixCount]...)
        tail := messages[prefixCount:]
        if len(tail) == 0 </span><span class="cov0" title="0">{
                return prefix
        }</span>

        <span class="cov8" title="1">selected := make([]llm.Message, 0, len(tail))
        totalChars := 0
        for i := len(tail) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                current := tail[i]
                currentChars := len([]rune(current.Content))
                if len(selected) &gt; 0 </span><span class="cov8" title="1">{
                        if maxMessages &gt; 0 &amp;&amp; len(selected) &gt;= maxMessages </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">if maxChars &gt; 0 &amp;&amp; totalChars+currentChars &gt; maxChars </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">selected = append(selected, current)
                totalChars += currentChars</span>
        }
        <span class="cov8" title="1">for i, j := 0, len(selected)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                selected[i], selected[j] = selected[j], selected[i]
        }</span>

        <span class="cov8" title="1">result := make([]llm.Message, 0, len(prefix)+len(selected))
        result = append(result, prefix...)
        result = append(result, selected...)
        return result</span>
}

func llmRetryDelay(attempt int) time.Duration <span class="cov8" title="1">{
        switch attempt </span>{
        case 2:<span class="cov8" title="1">
                return 250 * time.Millisecond</span>
        case 3:<span class="cov0" title="0">
                return 750 * time.Millisecond</span>
        default:<span class="cov8" title="1">
                return 0</span>
        }
}

func (a *RunActivities) generateWithRetry(ctx context.Context, runID string, providers []llmProviderCandidate, messages []llm.Message) (string, error) <span class="cov8" title="1">{
        if len(providers) == 0 </span><span class="cov0" title="0">{
                return "", errors.New("no llm providers configured")
        }</span>
        <span class="cov8" title="1">attempts := maxLLMGenerateAttempts
        if attempts &lt; 1 </span><span class="cov0" title="0">{
                attempts = 1
        }</span>
        <span class="cov8" title="1">budgetDeadline := time.Time{}
        if maxLLMPhaseBudget &gt; 0 </span><span class="cov8" title="1">{
                budgetDeadline = time.Now().Add(maxLLMPhaseBudget)
        }</span>
        <span class="cov8" title="1">var lastErr error
        for providerIndex, provider := range providers </span><span class="cov8" title="1">{
                for attempt := 1; attempt &lt;= attempts; attempt++ </span><span class="cov8" title="1">{
                        if delay := llmRetryDelay(attempt); delay &gt; 0 </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-time.After(delay):<span class="cov8" title="1"></span>
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return "", ctx.Err()</span>
                                }
                        }

                        <span class="cov8" title="1">generateCtx := ctx
                        cancel := func() </span>{<span class="cov0" title="0">}</span>
                        <span class="cov8" title="1">timeout := a.requestTimeout
                        if !budgetDeadline.IsZero() </span><span class="cov8" title="1">{
                                remaining := time.Until(budgetDeadline)
                                if remaining &lt;= 0 </span><span class="cov0" title="0">{
                                        if lastErr != nil </span><span class="cov0" title="0">{
                                                return "", lastErr
                                        }</span>
                                        <span class="cov0" title="0">return "", context.DeadlineExceeded</span>
                                }
                                <span class="cov8" title="1">if timeout &lt;= 0 || remaining &lt; timeout </span><span class="cov0" title="0">{
                                        timeout = remaining
                                }</span>
                        }
                        <span class="cov8" title="1">if timeout &gt; 0 </span><span class="cov8" title="1">{
                                generateCtx, cancel = context.WithTimeout(ctx, timeout)
                        }</span>
                        <span class="cov8" title="1">if runID != "" </span><span class="cov8" title="1">{
                                _ = a.postEvent(ctx, runID, "model.request.started", map[string]any{
                                        "provider":  provider.Name,
                                        "attempt":   attempt,
                                        "transient": true,
                                })
                        }</span>
                        <span class="cov8" title="1">response, err := provider.Provider.Generate(generateCtx, messages)
                        cancel()
                        if err == nil </span><span class="cov8" title="1">{
                                if strings.TrimSpace(response) == "" </span><span class="cov8" title="1">{
                                        err = errors.New("LLM response had no content")
                                }</span> else<span class="cov8" title="1"> {
                                        if runID != "" </span><span class="cov8" title="1">{
                                                _ = a.postEvent(ctx, runID, "model.request.completed", map[string]any{
                                                        "provider":  provider.Name,
                                                        "attempt":   attempt,
                                                        "transient": true,
                                                })
                                        }</span>
                                        <span class="cov8" title="1">return response, nil</span>
                                }
                        }
                        <span class="cov8" title="1">if runID != "" </span><span class="cov8" title="1">{
                                _ = a.postEvent(ctx, runID, "model.request.failed", map[string]any{
                                        "provider": provider.Name,
                                        "attempt":  attempt,
                                        "error":    truncateRunes(strings.TrimSpace(err.Error()), 200),
                                })
                        }</span>
                        <span class="cov8" title="1">lastErr = err
                        if !isRetryableLLMError(err) </span><span class="cov8" title="1">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">if shouldFailoverProvider(err) </span><span class="cov8" title="1">{
                                break</span>
                        }
                        // Timeouts are the slowest failure mode; cap these to two attempts.
                        <span class="cov8" title="1">if isTimeoutLLMError(err) &amp;&amp; attempt &gt;= 2 </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">if attempt == attempts </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">if providerIndex &lt; len(providers)-1 </span><span class="cov8" title="1">{
                        continue</span>
                }
        }
        <span class="cov8" title="1">if lastErr == nil </span><span class="cov0" title="0">{
                return "", errors.New("llm generation failed")
        }</span>
        <span class="cov8" title="1">return "", lastErr</span>
}

func shouldFailoverProvider(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">message := strings.ToLower(strings.TrimSpace(err.Error()))
        if message == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if strings.Contains(message, "bad gateway") || strings.Contains(message, "service unavailable") || strings.Contains(message, "gateway timeout") </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return strings.Contains(message, " 502") || strings.Contains(message, " 503") || strings.Contains(message, " 504")</span>
}

func buildNoContentFallback(successfulToolCalls []toolCall) string <span class="cov8" title="1">{
        if summary := summarizeWritePaths(successfulToolCalls); summary != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("I completed some tool actions (%s), but the model returned an empty response before I could finish. Please retry and I can continue from these changes.", summary)
        }</span>
        <span class="cov8" title="1">return "The model returned an empty response, so I could not finish this run. Please retry and I can continue from where we left off."</span>
}

func buildTransientLLMFallback(err error) string <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return "The model provider is temporarily unavailable, so I could not finish this run. Please retry in a moment."
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("The model provider is temporarily unavailable (%s). Please retry in a moment.", truncateRunes(strings.TrimSpace(err.Error()), 180))</span>
}

func buildToolExecutionFallback(successfulToolCalls []toolCall) string <span class="cov8" title="1">{
        if len(successfulToolCalls) &gt; 0 </span><span class="cov8" title="1">{
                return buildToolCompletionSummary(successfulToolCalls, false, nil)
        }</span>
        <span class="cov0" title="0">return "No tool actions were executed for this run. Retry this request and I will execute it."</span>
}

func buildNoContentRetryPrompt(mustExecuteTools bool, userRequest string) string <span class="cov8" title="1">{
        requestSnippet := truncateRunes(strings.TrimSpace(userRequest), 240)
        if mustExecuteTools </span><span class="cov8" title="1">{
                return fmt.Sprintf("The previous response was empty. Retry now and respond with exactly one fenced ```tool JSON block for request %q. No prose.", requestSnippet)
        }</span>
        <span class="cov8" title="1">return "The previous response was empty. Retry now with a concise assistant reply only."</span>
}

func buildToolCompletionSummary(successfulToolCalls []toolCall, hadToolErrors bool, cause error) string <span class="cov8" title="1">{
        parts := make([]string, 0, 3)
        if writes := summarizeWritePaths(successfulToolCalls); writes != "" </span><span class="cov8" title="1">{
                parts = append(parts, writes)
        }</span>
        <span class="cov8" title="1">if processSummary := summarizeProcessActions(successfulToolCalls); processSummary != "" </span><span class="cov8" title="1">{
                parts = append(parts, processSummary)
        }</span>
        <span class="cov8" title="1">if preview := summarizePreviewURLs(successfulToolCalls); preview != "" </span><span class="cov8" title="1">{
                parts = append(parts, preview)
        }</span>

        <span class="cov8" title="1">actionSummary := "completed tool actions"
        if len(parts) == 1 </span><span class="cov8" title="1">{
                actionSummary = parts[0]
        }</span> else<span class="cov8" title="1"> if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                actionSummary = strings.Join(parts, "; ")
        }</span>

        <span class="cov8" title="1">if hadToolErrors </span><span class="cov0" title="0">{
                return fmt.Sprintf("I partially completed this run (%s), but some tool steps failed. You can resume and I will continue from the current state.", actionSummary)
        }</span>
        <span class="cov8" title="1">if cause != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("I completed this run (%s), but the model provider became unavailable before I could generate a fuller narrative (%s).", actionSummary, truncateRunes(strings.TrimSpace(cause.Error()), 160))
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("I completed this run (%s).", actionSummary)</span>
}

func (a *RunActivities) composeBestEffortFinalResponse(
        ctx context.Context,
        runID string,
        providers []llmProviderCandidate,
        baseMessages []llm.Message,
        userRequest string,
        successfulToolCalls []toolCall,
        researchRequirements webResearchRequirements,
        hadToolErrors bool,
        cause error,
) string <span class="cov8" title="1">{
        if len(successfulToolCalls) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">if synthesized, synthErr := a.generateFinalSynthesis(ctx, runID, providers, baseMessages, userRequest, successfulToolCalls, researchRequirements); synthErr == nil </span><span class="cov8" title="1">{
                candidate := strings.TrimSpace(stripFencedToolBlocks(synthesized))
                if candidate != "" &amp;&amp; !(researchRequirements.Enabled &amp;&amp; responseHasLowResearchQuality(candidate)) </span><span class="cov8" title="1">{
                        return candidate
                }</span>
        }
        <span class="cov8" title="1">if researchRequirements.Enabled </span><span class="cov8" title="1">{
                if deterministic := buildDeterministicWebResearchSummaryForRequest(successfulToolCalls, researchRequirements, userRequest); deterministic != "" </span><span class="cov8" title="1">{
                        return deterministic
                }</span>
        }
        <span class="cov8" title="1">return buildToolCompletionSummary(successfulToolCalls, hadToolErrors, cause)</span>
}

func responseHasLowResearchQuality(content string) bool <span class="cov8" title="1">{
        normalized := strings.ToLower(strings.TrimSpace(content))
        if normalized == "" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if strings.Contains(normalized, "impact note unavailable") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if strings.Contains(normalized, "did not expose a clear summary sentence") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if strings.Contains(normalized, "compiled source diagnostics") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if strings.Contains(normalized, "low-quality extracts:") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if strings.Contains(normalized, "blocked sources:") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if strings.Contains(normalized, "coverage limitation: extracted") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if strings.Contains(normalized, "extractable source(s)") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if strings.Contains(normalized, "[object object]") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">lowSignalURLFragments := []string{
                "duckduckgo-help-pages",
                "apps.apple.com",
                "play.google.com/store/apps",
                "/privacy",
                "/terms",
                "/cookie",
        }
        for _, fragment := range lowSignalURLFragments </span><span class="cov8" title="1">{
                if strings.Contains(normalized, fragment) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">if countSourceLinks(content) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func enforceResearchQualityFallback(
        content string,
        successfulToolCalls []toolCall,
        requirements webResearchRequirements,
        userRequest string,
) string <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(content)
        if !requirements.Enabled </span><span class="cov8" title="1">{
                derived := deriveWebResearchRequirements(userRequest, true)
                if !derived.Enabled </span><span class="cov8" title="1">{
                        return trimmed
                }</span>
                <span class="cov0" title="0">requirements = derived</span>
        }
        <span class="cov8" title="1">if trimmed != "" &amp;&amp; !responseHasLowResearchQuality(trimmed) </span><span class="cov8" title="1">{
                return trimmed
        }</span>
        <span class="cov8" title="1">if deterministic := strings.TrimSpace(buildDeterministicWebResearchSummaryForRequest(successfulToolCalls, requirements, userRequest)); deterministic != "" </span><span class="cov8" title="1">{
                return deterministic
        }</span>
        <span class="cov0" title="0">if trimmed != "" </span><span class="cov0" title="0">{
                return trimmed
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(fmt.Sprintf("I could not extract enough evidence to complete this research request. Requested evidence threshold: %d usable sources.", requirements.MinimumItems))</span>
}

func buildInvalidToolPayloadFallback(successfulToolCalls []toolCall) string <span class="cov8" title="1">{
        if summary := summarizeWritePaths(successfulToolCalls); summary != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("I completed some tool actions (%s), but I could not parse valid follow-up tool instructions from the model. Please retry and I can continue from this state.", summary)
        }</span>
        <span class="cov8" title="1">return "I could not parse valid tool instructions from the model after several retries. Please retry and I will continue with stricter tool formatting."</span>
}

func summarizeWritePaths(successfulToolCalls []toolCall) string <span class="cov8" title="1">{
        paths := make([]string, 0, len(successfulToolCalls))
        for _, call := range successfulToolCalls </span><span class="cov8" title="1">{
                if call.ToolName != "editor.write" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">pathValue, ok := call.Input["path"]
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if pathText, ok := pathValue.(string); ok </span><span class="cov8" title="1">{
                        trimmed := strings.TrimSpace(pathText)
                        if trimmed != "" </span><span class="cov8" title="1">{
                                paths = append(paths, trimmed)
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(paths) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if len(paths) == 1 </span><span class="cov8" title="1">{
                return fmt.Sprintf("wrote %s", paths[0])
        }</span>
        <span class="cov8" title="1">if len(paths) == 2 </span><span class="cov0" title="0">{
                return fmt.Sprintf("wrote %s and %s", paths[0], paths[1])
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("wrote %s and %d more files", paths[0], len(paths)-1)</span>
}

func summarizeProcessActions(successfulToolCalls []toolCall) string <span class="cov8" title="1">{
        execCount := 0
        startedCount := 0
        for _, call := range successfulToolCalls </span><span class="cov8" title="1">{
                switch call.ToolName </span>{
                case "process.exec":<span class="cov8" title="1">
                        execCount++</span>
                case "process.start":<span class="cov8" title="1">
                        startedCount++</span>
                }
        }
        <span class="cov8" title="1">parts := make([]string, 0, 2)
        if execCount &gt; 0 </span><span class="cov8" title="1">{
                if execCount == 1 </span><span class="cov8" title="1">{
                        parts = append(parts, "ran 1 command")
                }</span> else<span class="cov0" title="0"> {
                        parts = append(parts, fmt.Sprintf("ran %d commands", execCount))
                }</span>
        }
        <span class="cov8" title="1">if startedCount &gt; 0 </span><span class="cov8" title="1">{
                if startedCount == 1 </span><span class="cov8" title="1">{
                        parts = append(parts, "started 1 process")
                }</span> else<span class="cov0" title="0"> {
                        parts = append(parts, fmt.Sprintf("started %d processes", startedCount))
                }</span>
        }
        <span class="cov8" title="1">return strings.Join(parts, " and ")</span>
}

func summarizePreviewURLs(successfulToolCalls []toolCall) string <span class="cov8" title="1">{
        unique := map[string]struct{}{}
        urls := make([]string, 0, 4)
        for _, call := range successfulToolCalls </span><span class="cov8" title="1">{
                raw := call.Input["preview_urls"]
                candidates := toStringSlice(raw)
                for _, url := range candidates </span><span class="cov8" title="1">{
                        trimmed := strings.TrimSpace(url)
                        if trimmed == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if _, exists := unique[trimmed]; exists </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">unique[trimmed] = struct{}{}
                        urls = append(urls, trimmed)</span>
                }
        }
        <span class="cov8" title="1">if len(urls) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if len(urls) == 1 </span><span class="cov8" title="1">{
                return fmt.Sprintf("preview available at %s", urls[0])
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("preview available at %s and %d more URLs", urls[0], len(urls)-1)</span>
}

type webResearchEvidence struct {
        URL          string
        Title        string
        Impact       string
        EvidenceText []string
        SeqHint      int
        Status       string
        ReasonCode   string
        ReasonDetail string
        WordCount    int
}

func (e webResearchEvidence) blocked() bool <span class="cov8" title="1">{
        switch strings.TrimSpace(strings.ToLower(e.ReasonCode)) </span>{
        case "blocked_by_bot_protection", "consent_wall", "login_wall":<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func (e webResearchEvidence) extractable() bool <span class="cov8" title="1">{
        return !e.blocked() &amp;&amp; strings.TrimSpace(strings.ToLower(e.ReasonCode)) != "no_extractable_content"
}</span>

func buildDeterministicWebResearchSummary(successfulToolCalls []toolCall, requirements webResearchRequirements) string <span class="cov8" title="1">{
        return buildDeterministicWebResearchSummaryForRequest(successfulToolCalls, requirements, "")
}</span>

func buildDeterministicWebResearchSummaryForRequest(successfulToolCalls []toolCall, requirements webResearchRequirements, userRequest string) string <span class="cov8" title="1">{
        evidence := collectWebResearchEvidence(successfulToolCalls)
        if len(evidence) == 0 </span><span class="cov0" title="0">{
                return "I could not extract enough article-grade source content for this request yet."
        }</span>
        <span class="cov8" title="1">requestKeywords := researchKeywordsFromRequest(userRequest)
        specificKeywords := specificResearchKeywords(requestKeywords)
        targetYear := ""
        targetMonth := ""
        for _, keyword := range requestKeywords </span><span class="cov8" title="1">{
                if len(keyword) == 4 &amp;&amp; strings.HasPrefix(keyword, "20") </span><span class="cov8" title="1">{
                        targetYear = keyword
                        break</span>
                }
        }
        <span class="cov8" title="1">for _, keyword := range requestKeywords </span><span class="cov8" title="1">{
                switch keyword </span>{
                case "january", "february", "march", "april", "may", "june",
                        "july", "august", "september", "october", "november", "december":<span class="cov8" title="1">
                        targetMonth = keyword</span>
                }
        }

        <span class="cov8" title="1">usable := make([]webResearchEvidence, 0, len(evidence))
        for _, item := range evidence </span><span class="cov8" title="1">{
                switch </span>{
                case item.blocked():<span class="cov8" title="1">
                        continue</span>
                case !item.extractable():<span class="cov8" title="1">
                        continue</span>
                case strings.TrimSpace(item.Impact) == "" || isLowValueImpactText(item.Impact):<span class="cov0" title="0">
                        continue</span>
                default:<span class="cov8" title="1">
                        usable = append(usable, item)</span>
                }
        }

        <span class="cov8" title="1">type scoredEvidence struct {
                item  webResearchEvidence
                score int
        }
        scoredUsable := make([]scoredEvidence, 0, len(usable))
        for _, item := range usable </span><span class="cov8" title="1">{
                score := researchEvidenceQualityScoreForRequest(item, specificKeywords, targetYear)
                scoredUsable = append(scoredUsable, scoredEvidence{item: item, score: score})
        }</span>
        <span class="cov8" title="1">sort.SliceStable(scoredUsable, func(i, j int) bool </span><span class="cov8" title="1">{
                return scoredUsable[i].score &gt; scoredUsable[j].score
        }</span>)
        <span class="cov8" title="1">usable = usable[:0]
        supplemental := make([]webResearchEvidence, 0, len(scoredUsable))
        for _, entry := range scoredUsable </span><span class="cov8" title="1">{
                if entry.score &lt; 18 </span><span class="cov8" title="1">{
                        if entry.score &gt; 0 </span><span class="cov0" title="0">{
                                supplemental = append(supplemental, entry.item)
                                continue</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">usable = append(usable, entry.item)</span>
        }
        <span class="cov8" title="1">if len(usable) &lt; requirements.MinimumItems &amp;&amp; len(supplemental) &gt; 0 </span><span class="cov0" title="0">{
                needed := requirements.MinimumItems - len(usable)
                if needed &lt; 1 </span><span class="cov0" title="0">{
                        needed = 1
                }</span>
                <span class="cov0" title="0">for _, candidate := range supplemental </span><span class="cov0" title="0">{
                        if needed &lt;= 0 </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">usable = append(usable, candidate)
                        needed--</span>
                }
        }
        <span class="cov8" title="1">if len(usable) == 0 </span><span class="cov8" title="1">{
                usable = append(usable, selectBestEffortExtractableEvidence(evidence, specificKeywords, targetYear, targetMonth, requirements.MinimumItems)...)
        }</span>

        <span class="cov8" title="1">limit := requirements.MinimumItems
        if limit &lt; 1 </span><span class="cov0" title="0">{
                limit = 8
        }</span>
        <span class="cov8" title="1">if limit &gt; len(usable) </span><span class="cov8" title="1">{
                limit = len(usable)
        }</span>
        <span class="cov8" title="1">requestedTopN := requestedTopNFromPrompt(userRequest, requirements.MinimumItems)
        if requestedTopN &gt; 0 &amp;&amp; requestedTopN &lt; limit </span><span class="cov0" title="0">{
                limit = requestedTopN
        }</span>

        <span class="cov8" title="1">if limit &lt;= 0 </span><span class="cov8" title="1">{
                return "I could not extract enough article-grade source pages to produce a reliable top-stories summary yet."
        }</span>

        <span class="cov8" title="1">var builder strings.Builder
        builder.WriteString("Here is the research summary based on extractable article sources.\n\n")
        builder.WriteString("Key themes:\n")
        builder.WriteString("1. Institutional participation and regulatory developments continue to shape the RWA/DeFi narrative.\n")
        builder.WriteString("2. Product launches, liquidity shifts, and risk repricing are driving short-term market structure changes.\n\n")
        builder.WriteString("Top stories:\n")
        for idx := 0; idx &lt; limit; idx++ </span><span class="cov8" title="1">{
                item := usable[idx]
                headline := strings.TrimSpace(item.Title)
                if headline == "" </span><span class="cov0" title="0">{
                        headline = hostFromURL(item.URL)
                }</span>
                <span class="cov8" title="1">dateLabel := extractResearchDateLabel(item)
                if dateLabel == "" </span><span class="cov8" title="1">{
                        dateLabel = "Date not explicit on page"
                }</span>
                <span class="cov8" title="1">summary := buildResearchItemSummary(item)
                builder.WriteString(fmt.Sprintf("%d. **%s**\n", idx+1, headline))
                builder.WriteString(fmt.Sprintf("   - Date: %s\n", dateLabel))
                builder.WriteString(fmt.Sprintf("   - Source: [%s](%s)\n", hostFromURL(item.URL), item.URL))
                builder.WriteString(fmt.Sprintf("   - Summary: %s\n", summary))</span>
        }
        <span class="cov8" title="1">return strings.TrimSpace(builder.String())</span>
}

func selectBestEffortExtractableEvidence(
        evidence []webResearchEvidence,
        specificKeywords []string,
        targetYear string,
        targetMonth string,
        limit int,
) []webResearchEvidence <span class="cov8" title="1">{
        if limit &lt; 1 </span><span class="cov0" title="0">{
                limit = 8
        }</span>
        <span class="cov8" title="1">type scoredEvidence struct {
                item  webResearchEvidence
                score int
        }
        scored := make([]scoredEvidence, 0, len(evidence))
        for _, item := range evidence </span><span class="cov8" title="1">{
                if !item.extractable() || item.blocked() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">if reason := nonArticleReasonForURL(item.URL); reason != "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if targetYear != "" </span><span class="cov0" title="0">{
                        combined := strings.ToLower(strings.TrimSpace(item.URL + " " + item.Title + " " + strings.Join(item.EvidenceText, " ")))
                        if !strings.Contains(combined, targetYear) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }
                <span class="cov0" title="0">if targetMonth != "" &amp;&amp; !evidenceMentionsTargetMonth(item, targetMonth) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if !evidenceMatchesSpecificKeywords(item, specificKeywords) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">score := researchEvidenceQualityScoreForRequest(item, specificKeywords, targetYear)
                if score &lt; 8 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">scored = append(scored, scoredEvidence{item: item, score: score})</span>
        }
        <span class="cov8" title="1">sort.SliceStable(scored, func(i, j int) bool </span><span class="cov0" title="0">{
                return scored[i].score &gt; scored[j].score
        }</span>)
        <span class="cov8" title="1">out := make([]webResearchEvidence, 0, min(limit, len(scored)))
        for _, entry := range scored </span><span class="cov0" title="0">{
                if len(out) &gt;= limit </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">out = append(out, entry.item)</span>
        }
        <span class="cov8" title="1">return out</span>
}

func researchEvidenceQualityScore(item webResearchEvidence) int <span class="cov8" title="1">{
        score := 0
        if item.WordCount &gt; 0 </span><span class="cov8" title="1">{
                score += min(item.WordCount, 120)
        }</span>
        <span class="cov8" title="1">title := strings.ToLower(strings.TrimSpace(item.Title))
        impact := strings.ToLower(strings.TrimSpace(item.Impact))
        urlText := strings.ToLower(strings.TrimSpace(item.URL))
        if strings.Contains(urlText, "/2026/") || strings.Contains(urlText, "feb") || strings.Contains(urlText, "march") </span><span class="cov8" title="1">{
                score += 18
        }</span>
        <span class="cov8" title="1">if matchedYear := anyYearRE.FindString(urlText + " " + title); matchedYear != "" &amp;&amp; matchedYear != "2026" </span><span class="cov0" title="0">{
                score -= 28
        }</span>
        <span class="cov8" title="1">relevanceSignals := []string{"rwa", "real world asset", "real-world asset", "defi", "crypto", "tokenization", "stablecoin", "bitcoin", "ethereum"}
        for _, signal := range relevanceSignals </span><span class="cov8" title="1">{
                if strings.Contains(title, signal) || strings.Contains(impact, signal) || strings.Contains(urlText, signal) </span><span class="cov8" title="1">{
                        score += 6
                }</span>
        }
        <span class="cov8" title="1">lowIntentSignals := []string{"press release", "event overview", "podcast", "newsletter", "conference", "sponsored", "top-100", "award", "price"}
        for _, signal := range lowIntentSignals </span><span class="cov8" title="1">{
                if strings.Contains(title, signal) || strings.Contains(urlText, signal) </span><span class="cov8" title="1">{
                        score -= 12
                }</span>
        }
        <span class="cov8" title="1">if isLowValueImpactText(impact) </span><span class="cov0" title="0">{
                score -= 16
        }</span>
        <span class="cov8" title="1">return score</span>
}

func researchEvidenceQualityScoreForRequest(item webResearchEvidence, specificKeywords []string, targetYear string) int <span class="cov8" title="1">{
        score := researchEvidenceQualityScore(item)
        haystack := strings.ToLower(strings.TrimSpace(item.Title + " " + item.Impact + " " + item.URL))
        if targetYear != "" </span><span class="cov8" title="1">{
                if strings.Contains(haystack, targetYear) </span><span class="cov8" title="1">{
                        score += 10
                }</span> else<span class="cov8" title="1"> if matchedYear := anyYearRE.FindString(haystack); matchedYear != "" &amp;&amp; matchedYear != targetYear </span><span class="cov0" title="0">{
                        score -= 20
                }</span>
        }
        <span class="cov8" title="1">if len(specificKeywords) &gt; 0 </span><span class="cov8" title="1">{
                matches := keywordMatchCount(specificKeywords, haystack)
                if matches == 0 </span><span class="cov8" title="1">{
                        score -= 30
                }</span> else<span class="cov8" title="1"> {
                        score += matches * 8
                }</span>
        }
        <span class="cov8" title="1">return score</span>
}

func keywordAliases(keyword string) []string <span class="cov8" title="1">{
        switch strings.TrimSpace(strings.ToLower(keyword)) </span>{
        case "rwa":<span class="cov8" title="1">
                return []string{
                        "rwa",
                        "real world asset",
                        "real-world asset",
                        "tokenization",
                        "tokenized",
                        "tokenize",
                        "on-chain treasury",
                        "onchain treasury",
                        "treasury token",
                }</span>
        case "defi":<span class="cov8" title="1">
                return []string{
                        "defi",
                        "decentralized finance",
                        "decentralised finance",
                }</span>
        default:<span class="cov8" title="1">
                trimmed := strings.TrimSpace(strings.ToLower(keyword))
                if trimmed == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">return []string{trimmed}</span>
        }
}

func keywordInText(keyword string, haystack string) bool <span class="cov8" title="1">{
        text := strings.ToLower(strings.TrimSpace(haystack))
        if text == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for _, alias := range keywordAliases(keyword) </span><span class="cov8" title="1">{
                if alias != "" &amp;&amp; strings.Contains(text, alias) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func keywordMatchCount(keywords []string, haystack string) int <span class="cov8" title="1">{
        count := 0
        for _, keyword := range keywords </span><span class="cov8" title="1">{
                if keywordInText(keyword, haystack) </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">return count</span>
}

func specificResearchKeywords(keywords []string) []string <span class="cov8" title="1">{
        if len(keywords) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">out := make([]string, 0, len(keywords))
        seen := map[string]struct{}{}
        for _, keyword := range keywords </span><span class="cov8" title="1">{
                keyword = strings.TrimSpace(strings.ToLower(keyword))
                if keyword == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">switch keyword </span>{
                case "crypto", "news", "latest", "current", "stories", "story",
                        "january", "february", "march", "april", "may", "june",
                        "july", "august", "september", "october", "november", "december":<span class="cov8" title="1">
                        continue</span>
                }
                <span class="cov8" title="1">if len(keyword) == 4 &amp;&amp; strings.HasPrefix(keyword, "20") </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, exists := seen[keyword]; exists </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">seen[keyword] = struct{}{}
                out = append(out, keyword)</span>
        }
        <span class="cov8" title="1">return out</span>
}

func collectWebResearchEvidence(successfulToolCalls []toolCall) []webResearchEvidence <span class="cov8" title="1">{
        type sourceIndex struct {
                idx int
        }
        byURL := map[string]sourceIndex{}
        sources := make([]webResearchEvidence, 0, len(successfulToolCalls))
        activeURL := ""
        ensureSource := func(urlValue string) int </span><span class="cov8" title="1">{
                normalized := strings.TrimSpace(urlValue)
                if normalized == "" </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov8" title="1">if existing, ok := byURL[normalized]; ok </span><span class="cov8" title="1">{
                        return existing.idx
                }</span>
                <span class="cov8" title="1">idx := len(sources)
                sources = append(sources, webResearchEvidence{URL: normalized, SeqHint: idx})
                byURL[normalized] = sourceIndex{idx: idx}
                return idx</span>
        }

        <span class="cov8" title="1">for _, call := range successfulToolCalls </span><span class="cov8" title="1">{
                switch call.ToolName </span>{
                case "browser.navigate":<span class="cov8" title="1">
                        urlValue := firstNonEmptyString(call.Input["url"], call.Input["current_url"], call.Input["final_url"])
                        idx := ensureSource(urlValue)
                        if idx &gt;= 0 </span><span class="cov8" title="1">{
                                activeURL = sources[idx].URL
                                if title := strings.TrimSpace(toString(call.Input["title"])); title != "" </span><span class="cov8" title="1">{
                                        sources[idx].Title = title
                                }</span>
                        }
                case "browser.extract":<span class="cov8" title="1">
                        mode := strings.ToLower(strings.TrimSpace(toString(call.Input["mode"])))
                        urlValue := strings.TrimSpace(toString(call.Input["url"]))
                        if urlValue == "" </span><span class="cov8" title="1">{
                                urlValue = activeURL
                        }</span>
                        <span class="cov8" title="1">idx := ensureSource(urlValue)
                        if idx &lt; 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">extracted := call.Input["extracted"]
                        diagnostics, _ := call.Input["diagnostics"].(map[string]any)
                        allowEvidenceFromExtract := true
                        if diagnostics != nil </span><span class="cov8" title="1">{
                                if status := strings.TrimSpace(toString(diagnostics["status"])); status != "" </span><span class="cov8" title="1">{
                                        sources[idx].Status = status
                                }</span>
                                <span class="cov8" title="1">if reasonCode := strings.TrimSpace(toString(diagnostics["reason_code"])); reasonCode != "" </span><span class="cov8" title="1">{
                                        sources[idx].ReasonCode = reasonCode
                                }</span>
                                <span class="cov8" title="1">if reasonDetail := strings.TrimSpace(toString(diagnostics["reason_detail"])); reasonDetail != "" </span><span class="cov8" title="1">{
                                        sources[idx].ReasonDetail = reasonDetail
                                }</span>
                                <span class="cov8" title="1">if wordCountRaw := strings.TrimSpace(toString(diagnostics["word_count"])); wordCountRaw != "" </span><span class="cov8" title="1">{
                                        if parsedWordCount, parseErr := strconv.Atoi(wordCountRaw); parseErr == nil </span><span class="cov8" title="1">{
                                                sources[idx].WordCount = parsedWordCount
                                        }</span>
                                }
                                <span class="cov8" title="1">status := strings.ToLower(strings.TrimSpace(toString(diagnostics["status"])))
                                reasonCode := strings.ToLower(strings.TrimSpace(toString(diagnostics["reason_code"])))
                                switch reasonCode </span>{
                                case "no_extractable_content", "blocked_by_bot_protection", "consent_wall", "login_wall":<span class="cov8" title="1">
                                        allowEvidenceFromExtract = false</span>
                                }
                                <span class="cov8" title="1">if status == "blocked" || status == "empty" </span><span class="cov8" title="1">{
                                        allowEvidenceFromExtract = false
                                }</span>
                        }
                        <span class="cov8" title="1">switch typed := extracted.(type) </span>{
                        case map[string]any:<span class="cov8" title="1">
                                if title := strings.TrimSpace(toString(typed["title"])); title != "" &amp;&amp; sources[idx].Title == "" </span><span class="cov0" title="0">{
                                        sources[idx].Title = title
                                }</span>
                                <span class="cov8" title="1">if urlText := strings.TrimSpace(toString(typed["url"])); urlText != "" &amp;&amp; sources[idx].URL == "" </span><span class="cov0" title="0">{
                                        sources[idx].URL = urlText
                                }</span>
                                <span class="cov8" title="1">if allowEvidenceFromExtract </span><span class="cov8" title="1">{
                                        if mode == "metadata" </span><span class="cov8" title="1">{
                                                description := strings.TrimSpace(toString(typed["description"]))
                                                firstParagraph := strings.TrimSpace(toString(typed["first_paragraph"]))
                                                contentPreview := strings.TrimSpace(toString(diagnostics["content_preview"]))
                                                if len(strings.Fields(description)) &gt;= 8 </span><span class="cov8" title="1">{
                                                        addEvidenceText(&amp;sources[idx], description)
                                                }</span>
                                                <span class="cov8" title="1">if len(strings.Fields(firstParagraph)) &gt;= 8 </span><span class="cov8" title="1">{
                                                        addEvidenceText(&amp;sources[idx], firstParagraph)
                                                }</span>
                                                <span class="cov8" title="1">if len(strings.Fields(contentPreview)) &gt;= 8 </span><span class="cov0" title="0">{
                                                        addEvidenceText(&amp;sources[idx], contentPreview)
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                addEvidenceText(
                                                        &amp;sources[idx],
                                                        toString(typed["description"]),
                                                        toString(typed["first_paragraph"]),
                                                        toString(typed["excerpt"]),
                                                        toString(typed["lead"]),
                                                        toString(typed["content"]),
                                                        toString(typed["article_body"]),
                                                        toString(typed["body"]),
                                                        toString(diagnostics["content_preview"]),
                                                )
                                        }</span>
                                }
                        case string:<span class="cov8" title="1">
                                if allowEvidenceFromExtract &amp;&amp; (mode == "text" || mode == "") </span><span class="cov8" title="1">{
                                        addEvidenceText(&amp;sources[idx], typed, toString(diagnostics["content_preview"]))
                                }</span>
                        case []any:<span class="cov0" title="0">
                                if !allowEvidenceFromExtract </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if len(typed) == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">parts := make([]string, 0, len(typed))
                                for _, value := range typed </span><span class="cov0" title="0">{
                                        text := strings.TrimSpace(toString(value))
                                        if text != "" </span><span class="cov0" title="0">{
                                                parts = append(parts, text)
                                        }</span>
                                        <span class="cov0" title="0">if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">addEvidenceText(&amp;sources[idx], strings.Join(parts, ". "), toString(diagnostics["content_preview"]))</span>
                        }

                        <span class="cov8" title="1">if sources[idx].ReasonCode == "" &amp;&amp; strings.EqualFold(strings.TrimSpace(toString(call.Input["reason_code"])), "no_extractable_content") </span><span class="cov0" title="0">{
                                sources[idx].ReasonCode = "no_extractable_content"
                        }</span>
                }
        }

        <span class="cov8" title="1">filtered := make([]webResearchEvidence, 0, len(sources))
        for _, source := range sources </span><span class="cov8" title="1">{
                if strings.TrimSpace(source.URL) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if impact := synthesizeImpactFromEvidence(source.Title, source.EvidenceText); impact != "" </span><span class="cov8" title="1">{
                        source.Impact = impact
                        if source.WordCount == 0 </span><span class="cov8" title="1">{
                                source.WordCount = len(strings.Fields(impact))
                        }</span>
                }
                <span class="cov8" title="1">if source.extractable() &amp;&amp; (looksLikeBotChallengeSnippet(source.Title, source.Impact) || isBotChallengeURL(source.URL)) </span><span class="cov8" title="1">{
                        source.ReasonCode = "blocked_by_bot_protection"
                        if source.ReasonDetail == "" </span><span class="cov8" title="1">{
                                source.ReasonDetail = "challenge_page_detected"
                        }</span>
                }
                <span class="cov8" title="1">if source.extractable() </span><span class="cov8" title="1">{
                        if detail := nonArticleReasonForURL(source.URL); detail != "" </span><span class="cov8" title="1">{
                                source.ReasonCode = "no_extractable_content"
                                if source.ReasonDetail == "" </span><span class="cov8" title="1">{
                                        source.ReasonDetail = detail
                                }</span>
                        }
                }
                <span class="cov8" title="1">if source.extractable() &amp;&amp; strings.Contains(strings.ToLower(source.URL), "/opinion/") </span><span class="cov8" title="1">{
                        source.ReasonCode = "no_extractable_content"
                        if source.ReasonDetail == "" </span><span class="cov8" title="1">{
                                source.ReasonDetail = "opinion_page"
                        }</span>
                }
                <span class="cov8" title="1">if source.extractable() </span><span class="cov8" title="1">{
                        joined := strings.ToLower(strings.TrimSpace(source.URL + " " + source.Title))
                        if strings.Contains(joined, "/sponsored/") || strings.Contains(joined, " sponsored") </span><span class="cov0" title="0">{
                                source.ReasonCode = "no_extractable_content"
                                if source.ReasonDetail == "" </span><span class="cov0" title="0">{
                                        source.ReasonDetail = "sponsored_content"
                                }</span>
                        }
                }
                <span class="cov8" title="1">if source.extractable() &amp;&amp; looksLikeLandingSnippet(source.Title, source.Impact) </span><span class="cov0" title="0">{
                        source.ReasonCode = "no_extractable_content"
                        if source.ReasonDetail == "" </span><span class="cov0" title="0">{
                                source.ReasonDetail = "landing_page_or_index_content"
                        }</span>
                }
                <span class="cov8" title="1">if source.extractable() &amp;&amp; looksLikeLegalPolicySnippet(source.URL, source.Title, source.Impact, source.EvidenceText) </span><span class="cov0" title="0">{
                        source.ReasonCode = "no_extractable_content"
                        if source.ReasonDetail == "" </span><span class="cov0" title="0">{
                                source.ReasonDetail = "legal_or_policy_page"
                        }</span>
                }
                <span class="cov8" title="1">if source.extractable() &amp;&amp; looksLikeNotFoundSnippet(source.Title, source.Impact, source.EvidenceText) </span><span class="cov8" title="1">{
                        source.ReasonCode = "no_extractable_content"
                        if source.ReasonDetail == "" </span><span class="cov8" title="1">{
                                source.ReasonDetail = "not_found_page"
                        }</span>
                }
                <span class="cov8" title="1">if source.extractable() &amp;&amp; strings.TrimSpace(source.Impact) == "" </span><span class="cov8" title="1">{
                        fallbackImpact := summarizeImpactText(strings.Join(source.EvidenceText, " "))
                        if fallbackImpact != "" </span><span class="cov0" title="0">{
                                source.Impact = fallbackImpact
                        }</span> else<span class="cov8" title="1"> {
                                source.ReasonCode = "no_extractable_content"
                                if source.ReasonDetail == "" </span><span class="cov8" title="1">{
                                        source.ReasonDetail = "missing_summary_text"
                                }</span>
                        }
                }
                <span class="cov8" title="1">if source.ReasonDetail == "" &amp;&amp; source.ReasonCode != "" </span><span class="cov0" title="0">{
                        source.ReasonDetail = source.ReasonCode
                }</span>
                <span class="cov8" title="1">filtered = append(filtered, source)</span>
        }
        <span class="cov8" title="1">return filtered</span>
}

func firstNonEmptyString(values ...any) string <span class="cov8" title="1">{
        for _, value := range values </span><span class="cov8" title="1">{
                text := strings.TrimSpace(toString(value))
                if text != "" </span><span class="cov8" title="1">{
                        return text
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func toString(value any) string <span class="cov8" title="1">{
        switch typed := value.(type) </span>{
        case string:<span class="cov8" title="1">
                return typed</span>
        case fmt.Stringer:<span class="cov0" title="0">
                return typed.String()</span>
        case nil:<span class="cov8" title="1">
                return ""</span>
        default:<span class="cov8" title="1">
                return fmt.Sprint(typed)</span>
        }
}

func addEvidenceText(source *webResearchEvidence, values ...string) <span class="cov8" title="1">{
        if source == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">for _, value := range values </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(value)
                if trimmed == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if len(trimmed) &gt; 5000 </span><span class="cov0" title="0">{
                        trimmed = truncateRunes(trimmed, 5000)
                }</span>
                <span class="cov8" title="1">if containsString(source.EvidenceText, trimmed) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">source.EvidenceText = append(source.EvidenceText, trimmed)</span>
        }
}

type scoredSentence struct {
        Text  string
        Score int
}

func synthesizeImpactFromEvidence(title string, evidence []string) string <span class="cov8" title="1">{
        if len(evidence) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">seen := map[string]struct{}{}
        sentences := make([]scoredSentence, 0, 24)
        for _, fragment := range evidence </span><span class="cov8" title="1">{
                for _, candidate := range candidateImpactSentences(fragment) </span><span class="cov8" title="1">{
                        normalized := strings.ToLower(strings.TrimSpace(candidate))
                        if normalized == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if _, exists := seen[normalized]; exists </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">seen[normalized] = struct{}{}
                        score := scoreImpactSentence(candidate, title)
                        if score &lt;= 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">sentences = append(sentences, scoredSentence{Text: candidate, Score: score})</span>
                }
        }

        <span class="cov8" title="1">if len(sentences) == 0 </span><span class="cov8" title="1">{
                return summarizeImpactText(strings.Join(evidence, " "))
        }</span>

        <span class="cov8" title="1">sort.SliceStable(sentences, func(i, j int) bool </span><span class="cov8" title="1">{
                return sentences[i].Score &gt; sentences[j].Score
        }</span>)

        <span class="cov8" title="1">selected := make([]string, 0, 2)
        for _, sentence := range sentences </span><span class="cov8" title="1">{
                if len(selected) &gt;= 2 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if sentenceTooSimilar(selected, sentence.Text) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">selected = append(selected, sentence.Text)</span>
        }
        <span class="cov8" title="1">if len(selected) == 0 </span><span class="cov0" title="0">{
                return summarizeImpactText(strings.Join(evidence, " "))
        }</span>
        <span class="cov8" title="1">return truncateRunes(strings.Join(selected, " "), 220)</span>
}

func candidateImpactSentences(raw string) []string <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(raw)
        if trimmed == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">cleaned := strings.Join(strings.Fields(trimmed), " ")
        if cleaned == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">parts := sentenceSplitRE.Split(cleaned, -1)
        out := make([]string, 0, len(parts))
        for _, sentence := range parts </span><span class="cov8" title="1">{
                candidate := strings.Trim(sentence, " \t\n\r\"'-")
                if candidate == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">wordCount := len(strings.Fields(candidate))
                if wordCount &lt; 8 || wordCount &gt; 48 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">out = append(out, candidate)</span>
        }
        <span class="cov8" title="1">if len(out) == 0 &amp;&amp; len(strings.Fields(cleaned)) &gt;= 8 </span><span class="cov0" title="0">{
                return []string{truncateRunes(cleaned, 220)}
        }</span>
        <span class="cov8" title="1">return out</span>
}

func scoreImpactSentence(sentence string, title string) int <span class="cov8" title="1">{
        candidate := strings.TrimSpace(sentence)
        if candidate == "" </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">lower := strings.ToLower(candidate)
        blockingSignals := []string{
                "are you a robot",
                "not a robot",
                "detected unusual activity",
                "detected unusual traffic",
                "unusual traffic from your computer network",
                "verify you are human",
                "attention required",
                "click the box below",
                "checking your browser",
                "just a moment",
                "cookie consent",
                "accept cookies",
        }
        for _, phrase := range blockingSignals </span><span class="cov8" title="1">{
                if strings.Contains(lower, phrase) </span><span class="cov8" title="1">{
                        return 0
                }</span>
        }

        <span class="cov8" title="1">if len(tickerSymbolRE.FindAllString(candidate, -1)) &gt;= 4 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">if isLowValueImpactText(lower) </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if strings.Contains(lower, "copyright") || strings.Contains(lower, "all rights reserved") </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">if len(tickerSymbolRE.FindAllString(candidate, -1)) &gt;= 3 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">score := len(strings.Fields(candidate))
        if datePathRE.MatchString(candidate) || strings.Contains(lower, "feb") || strings.Contains(lower, "2026") </span><span class="cov8" title="1">{
                score += 2
        }</span>
        <span class="cov8" title="1">if strings.Contains(candidate, "%") || strings.Contains(candidate, "$") </span><span class="cov0" title="0">{
                score += 1
        }</span>
        <span class="cov8" title="1">actionTerms := []string{
                "rose", "fell", "jumped", "dropped", "increased", "decreased",
                "launched", "announced", "approved", "expanded", "raised",
                "slashed", "repriced", "rotated", "boosted",
        }
        for _, term := range actionTerms </span><span class="cov8" title="1">{
                if strings.Contains(lower, term) </span><span class="cov8" title="1">{
                        score++
                        break</span>
                }
        }
        <span class="cov8" title="1">titleWords := strings.Fields(strings.ToLower(strings.TrimSpace(title)))
        titleMatchCount := 0
        for _, word := range titleWords </span><span class="cov8" title="1">{
                w := strings.Trim(word, ".,:;!?()[]{}\"'`")
                if len(w) &lt; 4 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.Contains(lower, w) </span><span class="cov8" title="1">{
                        titleMatchCount++
                }</span>
        }
        <span class="cov8" title="1">if titleMatchCount &gt;= 2 </span><span class="cov8" title="1">{
                score++
        }</span>
        <span class="cov8" title="1">return score</span>
}

func isLowValueImpactText(value string) bool <span class="cov8" title="1">{
        lower := strings.ToLower(strings.TrimSpace(value))
        if lower == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for _, phrase := range lowValueResearchSignals </span><span class="cov8" title="1">{
                if strings.Contains(lower, phrase) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func sentenceTooSimilar(existing []string, candidate string) bool <span class="cov8" title="1">{
        candidateSet := wordSet(candidate)
        if len(candidateSet) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">for _, item := range existing </span><span class="cov8" title="1">{
                existingSet := wordSet(item)
                if len(existingSet) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">intersection := 0
                for word := range candidateSet </span><span class="cov8" title="1">{
                        if _, ok := existingSet[word]; ok </span><span class="cov8" title="1">{
                                intersection++
                        }</span>
                }
                <span class="cov8" title="1">overlap := float64(intersection) / float64(min(len(candidateSet), len(existingSet)))
                if overlap &gt;= 0.75 </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func wordSet(raw string) map[string]struct{} <span class="cov8" title="1">{
        words := strings.Fields(strings.ToLower(raw))
        set := make(map[string]struct{}, len(words))
        for _, word := range words </span><span class="cov8" title="1">{
                normalized := strings.Trim(word, ".,:;!?()[]{}\"'`")
                if len(normalized) &lt; 3 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">set[normalized] = struct{}{}</span>
        }
        <span class="cov8" title="1">return set</span>
}

func min(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func containsString(items []string, target string) bool <span class="cov8" title="1">{
        for _, item := range items </span><span class="cov8" title="1">{
                if item == target </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func summarizeImpactText(raw string) string <span class="cov8" title="1">{
        sentences := candidateImpactSentences(raw)
        if len(sentences) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">for _, sentence := range sentences </span><span class="cov8" title="1">{
                if scoreImpactSentence(sentence, "") &gt; 0 </span><span class="cov8" title="1">{
                        return truncateRunes(sentence, 180)
                }</span>
        }
        <span class="cov8" title="1">return truncateRunes(sentences[0], 180)</span>
}

func inferImpactFromTitle(title string) string <span class="cov0" title="0">{
        cleanedTitle := strings.TrimSpace(title)
        if cleanedTitle == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("Headline indicates: %s.", truncateRunes(cleanedTitle, 140))</span>
}

func buildResearchItemSummary(item webResearchEvidence) string <span class="cov8" title="1">{
        impact := strings.TrimSpace(item.Impact)
        if impact == "" || isLowValueImpactText(impact) </span><span class="cov0" title="0">{
                impact = summarizeImpactText(strings.Join(item.EvidenceText, " "))
        }</span>
        <span class="cov8" title="1">if impact == "" || isLowValueImpactText(impact) </span><span class="cov0" title="0">{
                impact = inferImpactFromTitle(item.Title)
        }</span>
        <span class="cov8" title="1">if impact == "" </span><span class="cov0" title="0">{
                return "Extracted text was limited; no reliable story summary could be synthesized."
        }</span>
        <span class="cov8" title="1">return truncateRunes(impact, 260)</span>
}

func extractResearchDateLabel(item webResearchEvidence) string <span class="cov8" title="1">{
        combined := strings.TrimSpace(item.URL + " " + item.Title + " " + strings.Join(item.EvidenceText, " "))
        if combined == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">if pathMatch := datePathRE.FindString(strings.ToLower(item.URL)); pathMatch != "" </span><span class="cov8" title="1">{
                trimmed := strings.Trim(pathMatch, "/")
                parts := strings.Split(trimmed, "/")
                if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                        if len(parts) &gt;= 3 </span><span class="cov8" title="1">{
                                return fmt.Sprintf("%s-%s-%s", parts[0], parts[1], parts[2])
                        }</span>
                        <span class="cov0" title="0">return fmt.Sprintf("%s-%s", parts[0], parts[1])</span>
                }
        }
        <span class="cov8" title="1">if match := monthDateRE.FindString(combined); strings.TrimSpace(match) != "" </span><span class="cov0" title="0">{
                return strings.TrimSpace(match)
        }</span>
        <span class="cov8" title="1">if match := anyYearRE.FindString(combined); strings.TrimSpace(match) != "" </span><span class="cov8" title="1">{
                return strings.TrimSpace(match)
        }</span>
        <span class="cov8" title="1">return ""</span>
}

func hostFromURL(raw string) string <span class="cov8" title="1">{
        parsed, err := url.Parse(strings.TrimSpace(raw))
        if err != nil </span><span class="cov0" title="0">{
                return "Source"
        }</span>
        <span class="cov8" title="1">host := strings.TrimSpace(parsed.Host)
        if host == "" </span><span class="cov0" title="0">{
                return "Source"
        }</span>
        <span class="cov8" title="1">return host</span>
}

func nonArticleReasonForURL(raw string) string <span class="cov8" title="1">{
        parsed, err := url.Parse(strings.TrimSpace(raw))
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">host := strings.ToLower(strings.TrimSpace(parsed.Host))
        path := strings.ToLower(strings.TrimSpace(parsed.Path))
        if host == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(path, "/search") </span><span class="cov8" title="1">{
                return "search_results_page"
        }</span>
        <span class="cov8" title="1">if strings.Contains(host, "duckduckgo.com") &amp;&amp; parsed.Query().Has("q") </span><span class="cov0" title="0">{
                return "search_results_page"
        }</span>
        <span class="cov8" title="1">query := parsed.Query()
        if strings.Contains(path, "/find") &amp;&amp; (query.Has("q") || query.Has("query") || query.Has("s")) </span><span class="cov0" title="0">{
                return "search_results_page"
        }</span>
        <span class="cov8" title="1">if (query.Has("q") || query.Has("query") || query.Has("s") || query.Has("blob")) &amp;&amp; strings.Contains(path, "search") </span><span class="cov8" title="1">{
                return "search_results_page"
        }</span>
        <span class="cov8" title="1">if path == "" || path == "/" </span><span class="cov8" title="1">{
                return "homepage_not_article"
        }</span>
        <span class="cov8" title="1">trimmedPath := strings.Trim(path, "/")
        segments := strings.Split(trimmedPath, "/")
        if len(segments) == 0 </span><span class="cov0" title="0">{
                return "homepage_not_article"
        }</span>

        <span class="cov8" title="1">firstSegment := strings.ToLower(strings.TrimSpace(segments[0]))
        switch firstSegment </span>{
        case "privacy", "policy", "policies", "terms", "legal", "cookie", "cookies":<span class="cov8" title="1">
                return "legal_or_policy_page"</span>
        }
        <span class="cov8" title="1">if strings.Contains(path, "terms-and-privacy") || strings.Contains(path, "privacy-policy") || strings.Contains(path, "terms-of-service") </span><span class="cov8" title="1">{
                return "legal_or_policy_page"
        }</span>
        <span class="cov8" title="1">if strings.Contains(path, "/author/") || strings.Contains(path, "/authors/") </span><span class="cov8" title="1">{
                return "section_index_page"
        }</span>
        <span class="cov8" title="1">if strings.Contains(path, "/help/") || strings.Contains(path, "/support/") </span><span class="cov0" title="0">{
                return "section_index_page"
        }</span>
        <span class="cov8" title="1">if strings.Contains(path, "help-pages") </span><span class="cov8" title="1">{
                return "section_index_page"
        }</span>
        <span class="cov8" title="1">if strings.Contains(path, "/press-releases/") || strings.Contains(path, "/press-release/") </span><span class="cov8" title="1">{
                return "section_index_page"
        }</span>
        <span class="cov8" title="1">if strings.Contains(path, "/price/") || strings.HasPrefix(path, "/price/") </span><span class="cov0" title="0">{
                return "section_index_page"
        }</span>
        <span class="cov8" title="1">if strings.Contains(path, "/people/top-people") || strings.HasPrefix(path, "/people/") </span><span class="cov0" title="0">{
                return "section_index_page"
        }</span>
        <span class="cov8" title="1">switch firstSegment </span>{
        case "tag", "tags", "topic", "topics", "category", "categories", "newsletter", "newsletters", "price", "prices", "video", "videos", "podcast", "podcasts",
                "author", "authors", "help", "support", "docs", "documentation", "faq":<span class="cov8" title="1">
                return "section_index_page"</span>
        }
        <span class="cov8" title="1">if firstSegment == "search" </span><span class="cov0" title="0">{
                return "search_results_page"
        }</span>
        <span class="cov8" title="1">if firstSegment == "news" || firstSegment == "markets" || firstSegment == "latest" || firstSegment == "latest-news" </span><span class="cov8" title="1">{
                if !looksLikeArticlePath(segments) </span><span class="cov8" title="1">{
                        return "section_index_page"
                }</span>
        }
        <span class="cov8" title="1">if len(segments) == 1 &amp;&amp; !looksLikeArticlePath(segments) </span><span class="cov8" title="1">{
                switch firstSegment </span>{
                case "news", "markets", "latest", "latest-news", "latest-crypto-news", "research", "insights":<span class="cov0" title="0">
                        return "section_index_page"</span>
                }
        }
        <span class="cov8" title="1">return ""</span>
}

func looksLikeArticlePath(segments []string) bool <span class="cov8" title="1">{
        if len(segments) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">joined := strings.ToLower(strings.Join(segments, "/"))
        if datePathRE.MatchString("/" + joined) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if len(segments) &gt;= 3 </span><span class="cov0" title="0">{
                last := strings.TrimSpace(strings.ToLower(segments[len(segments)-1]))
                return len(last) &gt;= 10
        }</span>
        <span class="cov8" title="1">if len(segments) == 2 </span><span class="cov8" title="1">{
                second := strings.TrimSpace(strings.ToLower(segments[1]))
                if second == "" </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">if len(second) &gt;= 14 &amp;&amp; strings.Contains(second, "-") </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func looksLikeLandingSnippet(title string, impact string) bool <span class="cov8" title="1">{
        text := strings.ToLower(strings.TrimSpace(title + " " + impact))
        if text == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">signals := []string{
                "bitcoin, ethereum",
                "crypto news",
                "price indexes",
                "markets",
                "latest news",
                "news video prices",
                "data &amp; indices",
        }
        matches := 0
        for _, signal := range signals </span><span class="cov8" title="1">{
                if strings.Contains(text, signal) </span><span class="cov0" title="0">{
                        matches++
                }</span>
        }
        <span class="cov8" title="1">if matches &gt;= 2 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if looksLikeBotChallengeSnippet(title, impact) </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">return len(tickerSymbolRE.FindAllString(impact, -1)) &gt;= 4</span>
}

func looksLikeLegalPolicySnippet(rawURL string, title string, impact string, evidence []string) bool <span class="cov8" title="1">{
        if reason := nonArticleReasonForURL(rawURL); reason == "legal_or_policy_page" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">joinedTitle := strings.ToLower(strings.TrimSpace(title))
        if joinedTitle == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">signals := []string{
                "privacy policy",
                "terms of service",
                "terms and privacy",
                "privacy &amp; terms",
                "cookie policy",
                "legal notice",
                "manage cookies",
        }
        matchCount := 0
        for _, signal := range signals </span><span class="cov8" title="1">{
                if strings.Contains(joinedTitle, signal) </span><span class="cov0" title="0">{
                        matchCount++
                }</span>
        }
        <span class="cov8" title="1">if matchCount &gt; 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        // Some article pages include cookie/legal boilerplate in body text/impact; ignore that unless
        // page URL or title clearly indicates legal/policy content.
        <span class="cov8" title="1">_ = evidence
        _ = impact
        return false</span>
}

func looksLikeBotChallengeSnippet(title string, impact string) bool <span class="cov8" title="1">{
        text := strings.ToLower(strings.TrimSpace(title + " " + impact))
        if text == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">signals := []string{
                "are you a robot",
                "not a robot",
                "detected unusual activity",
                "detected unusual traffic",
                "unusual traffic from your computer network",
                "verify you are human",
                "just a moment",
                "attention required",
                "checking your browser",
                "access denied",
                "captcha",
                "security check",
                "click the box below",
        }
        for _, signal := range signals </span><span class="cov8" title="1">{
                if strings.Contains(text, signal) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func looksLikeNotFoundSnippet(title string, impact string, evidence []string) bool <span class="cov8" title="1">{
        text := strings.ToLower(strings.TrimSpace(title + " " + impact + " " + strings.Join(evidence, " ")))
        if text == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">signals := []string{
                "page not found",
                "404",
                "this page could not be found",
                "could've sworn the page was around here somewhere",
        }
        matches := 0
        for _, signal := range signals </span><span class="cov8" title="1">{
                if strings.Contains(text, signal) </span><span class="cov8" title="1">{
                        matches++
                }</span>
        }
        <span class="cov8" title="1">if strings.Contains(strings.ToLower(strings.TrimSpace(title)), "404") || strings.Contains(strings.ToLower(strings.TrimSpace(title)), "page not found") </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return matches &gt;= 2</span>
}

func isBotChallengeURL(raw string) bool <span class="cov8" title="1">{
        parsed, err := url.Parse(strings.TrimSpace(raw))
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">host := strings.ToLower(strings.TrimSpace(parsed.Hostname()))
        path := strings.ToLower(strings.TrimSpace(parsed.Path))
        if host == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if strings.Contains(host, "google.") &amp;&amp; strings.HasPrefix(path, "/sorry") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if strings.Contains(path, "captcha") || strings.Contains(path, "challenge") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func toStringSlice(value any) []string <span class="cov8" title="1">{
        switch typed := value.(type) </span>{
        case []string:<span class="cov0" title="0">
                return typed</span>
        case []any:<span class="cov8" title="1">
                converted := make([]string, 0, len(typed))
                for _, item := range typed </span><span class="cov8" title="1">{
                        text, ok := item.(string)
                        if ok </span><span class="cov8" title="1">{
                                converted = append(converted, text)
                        }</span>
                }
                <span class="cov8" title="1">return converted</span>
        default:<span class="cov8" title="1">
                return nil</span>
        }
}

func latestUserMessage(messages []store.Message) string <span class="cov8" title="1">{
        for i := len(messages) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if messages[i].Role != "user" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">content := strings.TrimSpace(messages[i].Content)
                if content != "" </span><span class="cov8" title="1">{
                        return content
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func shouldRepromptToolExecution(toolRunnerAvailable bool, userRequest string, modelResponse string, repromptCount int) bool <span class="cov8" title="1">{
        if !toolRunnerAvailable || repromptCount &gt;= maxToolIntentReprompts </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if !requestLikelyNeedsTools(userRequest) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return responseLooksLikeExecutionPromise(modelResponse)</span>
}

func requestLikelyNeedsTools(userRequest string) bool <span class="cov8" title="1">{
        text := strings.ToLower(strings.TrimSpace(userRequest))
        if text == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">keywords := []string{
                "browse", "search", "look up", "research", "latest", "news",
                "create", "build", "write", "edit", "update", "fix", "implement", "generate", "scaffold",
                "nextjs", "website", "app", "code", "file", "run ", "npm ", "pnpm ", "yarn ",
        }
        for _, keyword := range keywords </span><span class="cov8" title="1">{
                if strings.Contains(text, keyword) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func responseLooksLikeExecutionPromise(response string) bool <span class="cov8" title="1">{
        text := strings.ToLower(strings.TrimSpace(response))
        text = strings.ReplaceAll(text, "", "'")
        text = strings.ReplaceAll(text, "", "'")
        if text == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if strings.Contains(text, "```") || strings.Contains(text, "\"tool_calls\"") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if len([]rune(text)) &gt; 280 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">promisePhrases := []string{
                "i'll ", "i will ", "let me ", "i'm going to ", "i can ",
        }
        for _, phrase := range promisePhrases </span><span class="cov8" title="1">{
                if strings.Contains(text, phrase) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func buildToolOnlyRetryPrompt(userRequest string) string <span class="cov8" title="1">{
        trimmed := truncateRunes(strings.TrimSpace(userRequest), 240)
        return fmt.Sprintf("You must execute this request now. For request: %q, respond with exactly one fenced ```tool JSON block and no prose. Include concrete first-step tool calls immediately.", trimmed)
}</span>

func buildMissingToolCallsFallback() string <span class="cov8" title="1">{
        return "I could not start execution because the model repeatedly returned prose instead of tool calls. Retry this run and I will continue with strict tool-only execution."
}</span>

type webResearchRequirements struct {
        Enabled      bool
        MinimumItems int
}

func deriveWebResearchRequirements(userRequest string, mustExecuteTools bool) webResearchRequirements <span class="cov8" title="1">{
        if !mustExecuteTools </span><span class="cov8" title="1">{
                return webResearchRequirements{}
        }</span>
        <span class="cov8" title="1">text := strings.ToLower(strings.TrimSpace(userRequest))
        if text == "" </span><span class="cov0" title="0">{
                return webResearchRequirements{}
        }</span>
        <span class="cov8" title="1">if !requestLikelyNeedsTools(text) </span><span class="cov8" title="1">{
                return webResearchRequirements{}
        }</span>
        <span class="cov8" title="1">if !strings.Contains(text, "browse") &amp;&amp;
                !strings.Contains(text, "search") &amp;&amp;
                !strings.Contains(text, "research") &amp;&amp;
                !strings.Contains(text, "news") &amp;&amp;
                !strings.Contains(text, "source") &amp;&amp;
                !strings.Contains(text, "link") </span><span class="cov8" title="1">{
                return webResearchRequirements{}
        }</span>

        <span class="cov8" title="1">minItems := 3
        if matches := topNRequestRE.FindStringSubmatch(text); len(matches) == 2 </span><span class="cov8" title="1">{
                if parsed, err := strconv.Atoi(matches[1]); err == nil </span><span class="cov8" title="1">{
                        if parsed &lt; 1 </span><span class="cov0" title="0">{
                                parsed = 1
                        }</span>
                        <span class="cov8" title="1">minSources := parsed
                        if minSources &lt; 3 </span><span class="cov8" title="1">{
                                minSources = 3
                        }</span>
                        <span class="cov8" title="1">if minSources &gt; 8 </span><span class="cov0" title="0">{
                                minSources = 8
                        }</span>
                        <span class="cov8" title="1">minItems = minSources</span>
                }
        }
        <span class="cov8" title="1">return webResearchRequirements{
                Enabled:      true,
                MinimumItems: minItems,
        }</span>
}

func requestedTopNFromPrompt(userRequest string, minimumFallback int) int <span class="cov8" title="1">{
        text := strings.ToLower(strings.TrimSpace(userRequest))
        if matches := topNRequestRE.FindStringSubmatch(text); len(matches) == 2 </span><span class="cov8" title="1">{
                if parsed, err := strconv.Atoi(matches[1]); err == nil </span><span class="cov8" title="1">{
                        if parsed &lt; minimumFallback </span><span class="cov8" title="1">{
                                return minimumFallback
                        }</span>
                        <span class="cov8" title="1">if parsed &gt; 12 </span><span class="cov0" title="0">{
                                return 12
                        }</span>
                        <span class="cov8" title="1">return parsed</span>
                }
        }
        <span class="cov8" title="1">if minimumFallback &lt; 1 </span><span class="cov8" title="1">{
                return 1
        }</span>
        <span class="cov8" title="1">return minimumFallback</span>
}

func buildWebResearchExecutionPrompt(requirements webResearchRequirements) string <span class="cov8" title="1">{
        return fmt.Sprintf(
                "This task requires web research. Gather evidence before finishing: visit and extract from at least %d distinct source URLs. Use browser.navigate and browser.extract (mode=metadata and text) on article pages. Prefer deep-link article/source pages and do not count homepages, search results, section index pages, or legal/privacy/terms pages as usable evidence. Avoid Google/Bing search-result pages unless no alternatives exist because they often trigger anti-bot pages. Do not stop at the first page of a domain: when you land on search/homepage/index pages, use browser.evaluate to collect in-page article links, then navigate those links and extract. If extraction fails, record the exact reason code (blocked_by_bot_protection, consent_wall, no_extractable_content) and continue with alternative sources. Build your own summary from extracted article body text; do not rely on a page-provided summary field. Final user response must include only high-confidence story findings with source links and synthesized summaries; do not include blocked/low-quality diagnostics unless explicitly requested.",
                requirements.MinimumItems,
        )
}</span>

func evidenceMatchesSpecificKeywords(item webResearchEvidence, specificKeywords []string) bool <span class="cov8" title="1">{
        if len(specificKeywords) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">primary := strings.ToLower(strings.TrimSpace(item.Title + " " + item.Impact + " " + item.URL))
        for _, keyword := range specificKeywords </span><span class="cov8" title="1">{
                if keywordInText(keyword, primary) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">fullText := strings.ToLower(strings.TrimSpace(strings.Join(item.EvidenceText, " ")))
        if fullText == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for _, keyword := range specificKeywords </span><span class="cov0" title="0">{
                if keywordInText(keyword, fullText) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func filterUsableWebResearchEvidenceForRequest(successfulToolCalls []toolCall, userRequest string) []webResearchEvidence <span class="cov8" title="1">{
        evidence := collectWebResearchEvidence(successfulToolCalls)
        if len(evidence) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">requestKeywords := researchKeywordsFromRequest(userRequest)
        specificKeywords := specificResearchKeywords(requestKeywords)
        targetYear := ""
        targetMonth := ""
        for _, keyword := range requestKeywords </span><span class="cov8" title="1">{
                if len(keyword) == 4 &amp;&amp; strings.HasPrefix(keyword, "20") </span><span class="cov8" title="1">{
                        targetYear = keyword
                        break</span>
                }
        }
        <span class="cov8" title="1">for _, keyword := range requestKeywords </span><span class="cov8" title="1">{
                switch keyword </span>{
                case "january", "february", "march", "april", "may", "june",
                        "july", "august", "september", "october", "november", "december":<span class="cov8" title="1">
                        targetMonth = keyword</span>
                }
        }
        <span class="cov8" title="1">usable := make([]webResearchEvidence, 0, len(evidence))
        for _, item := range evidence </span><span class="cov8" title="1">{
                if !item.extractable() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if detail := nonArticleReasonForURL(item.URL); detail != "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if len(item.EvidenceText) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">combined := strings.ToLower(strings.TrimSpace(item.URL + " " + item.Title + " " + strings.Join(item.EvidenceText, " ")))
                if targetYear != "" &amp;&amp; !strings.Contains(combined, targetYear) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if targetMonth != "" &amp;&amp; !evidenceMentionsTargetMonth(item, targetMonth) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">bodyWordCount := item.WordCount
                if bodyWordCount == 0 </span><span class="cov0" title="0">{
                        bodyWordCount = len(strings.Fields(strings.Join(item.EvidenceText, " ")))
                }</span>
                <span class="cov8" title="1">if bodyWordCount &lt; 40 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">if strings.TrimSpace(item.Impact) == "" || isLowValueImpactText(item.Impact) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if !evidenceMatchesSpecificKeywords(item, specificKeywords) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">score := researchEvidenceQualityScoreForRequest(item, specificKeywords, targetYear)
                if score &lt; 24 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">usable = append(usable, item)</span>
        }
        <span class="cov8" title="1">return usable</span>
}

func evidenceMentionsTargetMonth(item webResearchEvidence, targetMonth string) bool <span class="cov8" title="1">{
        month := strings.TrimSpace(strings.ToLower(targetMonth))
        if month == "" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">combined := strings.ToLower(strings.TrimSpace(item.URL + " " + item.Title + " " + strings.Join(item.EvidenceText, " ")))
        if strings.Contains(combined, month) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">monthByName := map[string]string{
                "january":   "/01/",
                "february":  "/02/",
                "march":     "/03/",
                "april":     "/04/",
                "may":       "/05/",
                "june":      "/06/",
                "july":      "/07/",
                "august":    "/08/",
                "september": "/09/",
                "october":   "/10/",
                "november":  "/11/",
                "december":  "/12/",
        }
        if marker, ok := monthByName[month]; ok &amp;&amp; strings.Contains(strings.ToLower(item.URL), marker) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func summarizeWebResearchEvidence(successfulToolCalls []toolCall) (int, int) <span class="cov0" title="0">{
        return summarizeWebResearchEvidenceForRequest(successfulToolCalls, "")
}</span>

func summarizeWebResearchEvidenceForRequest(successfulToolCalls []toolCall, userRequest string) (int, int) <span class="cov8" title="1">{
        evidence := filterUsableWebResearchEvidenceForRequest(successfulToolCalls, userRequest)
        usableSources := map[string]struct{}{}
        extractCount := 0
        for _, source := range evidence </span><span class="cov0" title="0">{
                usableSources[strings.TrimSpace(source.URL)] = struct{}{}
                extractCount++
        }</span>
        <span class="cov8" title="1">return len(usableSources), extractCount</span>
}

func countSourceLinks(content string) int <span class="cov8" title="1">{
        return len(sourceLinkRE.FindAllString(content, -1))
}</span>

func shouldRepromptForWebResearch(requirements webResearchRequirements, uniqueSources int, extractCount int, linkCount int) bool <span class="cov8" title="1">{
        if !requirements.Enabled </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">requiredExtracts := requiredWebResearchExtracts(requirements.MinimumItems)
        if uniqueSources &lt; requirements.MinimumItems </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov0" title="0">if extractCount &lt; requiredExtracts </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return linkCount &lt; requirements.MinimumItems</span>
}

func buildWebResearchRetryPrompt(requirements webResearchRequirements, uniqueSources int, extractCount int, linkCount int) string <span class="cov8" title="1">{
        requiredExtracts := requiredWebResearchExtracts(requirements.MinimumItems)
        return fmt.Sprintf(
                "Continue web research with tools before finalizing. Current usable evidence: %d/%d distinct source URLs, %d/%d extract calls, and %d/%d source links in the draft. Homepages/search pages/index pages/privacy pages/terms pages are low quality and must be replaced with deep-link source pages. Avoid Google/Bing search-result pages unless no alternatives exist because they often trigger anti-bot pages. On index/search pages, use browser.evaluate to collect candidate article links, then navigate into those links and run browser.extract in both metadata and text mode. Do not stop at a site landing page: navigate through additional pages on that site until you reach extractable article pages, or move to another domain if blocked. Derive impact notes from article body text, not metadata-only snippets. Do not wait for a page-provided summary sentence. Skip blocked/consent pages unless you annotate their reason codes, then collect alternative extractable sources. Respond with exactly one fenced ```tool JSON block using browser.navigate/browser.evaluate/browser.extract to collect the missing evidence.",
                uniqueSources,
                requirements.MinimumItems,
                extractCount,
                requiredExtracts,
                linkCount,
                requirements.MinimumItems,
        )
}</span>

type researchLinkCandidate struct {
        URL        string
        AnchorText string
        Score      int
}

const discoverArticleLinksScript = `(function () {
  const nodes = Array.from(document.querySelectorAll('a[href]'));
  const out = [];
  for (const node of nodes) {
    const href = typeof node.href === 'string' ? node.href : '';
    if (!href) continue;
    out.push({
      href,
      text: (node.textContent || '').replace(/\s+/g, ' ').trim(),
    });
  }
  return out.slice(0, 500);
})()`

func buildClickArticleLinkScript(targetURL string, anchorText string) string <span class="cov8" title="1">{
        target := strconv.Quote(strings.TrimSpace(targetURL))
        text := strconv.Quote(strings.TrimSpace(anchorText))
        return fmt.Sprintf(`(function () {
  const targetHref = %s;
  const hintText = %s.toLowerCase();
  const targetPath = (() =&gt; {
    try { return new URL(targetHref, window.location.href).pathname || ""; } catch { return ""; }
  })();
  const links = Array.from(document.querySelectorAll('a[href]'));
  for (const link of links) {
    const href = typeof link.href === 'string' ? link.href : '';
    if (!href) continue;
    const text = (link.textContent || '').replace(/\s+/g, ' ').trim().toLowerCase();
    const path = (() =&gt; {
      try { return new URL(href, window.location.href).pathname || ""; } catch { return ""; }
    })();
    const directMatch = href === targetHref || (targetPath &amp;&amp; path === targetPath);
    const textMatch = hintText &amp;&amp; text &amp;&amp; (text.includes(hintText) || hintText.includes(text));
    if (!directMatch &amp;&amp; !textMatch) continue;
    try {
      link.scrollIntoView({ behavior: 'instant', block: 'center' });
      link.click();
      return { clicked: true, href, text };
    } catch (err) {
      return { clicked: false, href, error: String(err || '') };
    }
  }
  return { clicked: false, href: '', error: 'link_not_found' };
})()`, target, text)
}</span>

func (a *RunActivities) autoDeepenWebResearch(
        ctx context.Context,
        runID string,
        userRequest string,
        successfulToolCalls []toolCall,
        browserUserTab browserUserTabConfig,
) ([]toolCall, bool) <span class="cov8" title="1">{
        restrictSeeds := requestLikelyCryptoResearch(userRequest)
        seeds := mergeResearchSeeds(
                maxAutoResearchSeedPages,
                collectResearchSeedURLs(successfulToolCalls, restrictSeeds),
                fallbackResearchSeedURLsFromRequest(userRequest),
                5,
        )
        if len(seeds) == 0 </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov8" title="1">requestKeywords := researchKeywordsFromRequest(userRequest)
        _ = a.emitEvent(ctx, runID, "research.deepening", map[string]any{
                "status":           "started",
                "seed_urls":        seeds,
                "request_keywords": requestKeywords,
        })

        recovered := make([]toolCall, 0, 24)
        hadErrors := false
        visited := map[string]struct{}{}
        hostFailures := map[string]int{}
        hostSuccesses := map[string]int{}
        recordHostOutcome := func(rawURL string, reasonCode string) </span><span class="cov8" title="1">{
                host := hostFromURL(rawURL)
                if host == "" </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">code := strings.ToLower(strings.TrimSpace(reasonCode))
                switch code </span>{
                case "blocked_by_bot_protection", "consent_wall", "login_wall", "no_extractable_content":<span class="cov8" title="1">
                        hostFailures[host]++</span>
                default:<span class="cov8" title="1">
                        hostSuccesses[host]++</span>
                }
        }
        <span class="cov8" title="1">shouldSkipHost := func(rawURL string) bool </span><span class="cov8" title="1">{
                host := hostFromURL(rawURL)
                if host == "" </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">return hostFailures[host] &gt;= 2 &amp;&amp; hostSuccesses[host] == 0</span>
        }
        <span class="cov8" title="1">for _, item := range collectWebResearchEvidence(successfulToolCalls) </span><span class="cov8" title="1">{
                if normalized := normalizeResearchURL(item.URL); normalized != "" </span><span class="cov8" title="1">{
                        visited[normalized] = struct{}{}
                }</span>
                <span class="cov8" title="1">host := hostFromURL(item.URL)
                if host == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if item.extractable() &amp;&amp; !item.blocked() </span><span class="cov8" title="1">{
                        hostSuccesses[host]++
                }</span> else<span class="cov8" title="1"> {
                        hostFailures[host]++
                }</span>
        }

        <span class="cov8" title="1">totalArticleLinks := 0
        for _, seedURL := range seeds </span><span class="cov8" title="1">{
                if totalArticleLinks &gt;= maxAutoResearchLinks </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">if shouldSkipHost(seedURL) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, ok := a.executeAutoResearchToolCall(ctx, runID, toolCall{
                        ToolName: "browser.navigate",
                        Input:    map[string]any{"url": seedURL},
                }, browserUserTab, &amp;recovered, &amp;hadErrors); !ok </span><span class="cov8" title="1">{
                        recordHostOutcome(seedURL, "no_extractable_content")
                        continue</span>
                }

                <span class="cov8" title="1">topEvalOutput, ok := a.executeAutoResearchToolCall(ctx, runID, toolCall{
                        ToolName: "browser.evaluate",
                        Input:    map[string]any{"script": discoverArticleLinksScript},
                }, browserUserTab, &amp;recovered, &amp;hadErrors)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">linkCandidates := parseResearchLinkCandidates(topEvalOutput)
                for pass := 0; pass &lt; autoResearchScrollPasses; pass++ </span><span class="cov8" title="1">{
                        _, _ = a.executeAutoResearchToolCall(ctx, runID, toolCall{
                                ToolName: "browser.scroll",
                                Input:    map[string]any{"direction": "down", "amount": autoResearchScrollAmount},
                        }, browserUserTab, &amp;recovered, &amp;hadErrors)
                        scrolledEvalOutput, _ := a.executeAutoResearchToolCall(ctx, runID, toolCall{
                                ToolName: "browser.evaluate",
                                Input:    map[string]any{"script": discoverArticleLinksScript},
                        }, browserUserTab, &amp;recovered, &amp;hadErrors)
                        linkCandidates = append(linkCandidates, parseResearchLinkCandidates(scrolledEvalOutput)...)
                }</span>

                <span class="cov8" title="1">candidates := rankArticleLinkCandidates(seedURL, linkCandidates, visited, requestKeywords)
                usedForSeed := 0
                for _, candidate := range candidates </span><span class="cov8" title="1">{
                        if totalArticleLinks &gt;= maxAutoResearchLinks || usedForSeed &gt;= maxAutoResearchPerSeed </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">if shouldSkipHost(candidate.URL) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if _, exists := visited[candidate.URL]; exists </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">visited[candidate.URL] = struct{}{}

                        clickOutput, _ := a.executeAutoResearchToolCall(ctx, runID, toolCall{
                                ToolName: "browser.evaluate",
                                Input: map[string]any{
                                        "script": buildClickArticleLinkScript(candidate.URL, candidate.AnchorText),
                                },
                        }, browserUserTab, &amp;recovered, &amp;hadErrors)
                        clicked := evaluateClickSucceeded(clickOutput)

                        metadataOutput, metaOK := a.executeAutoResearchToolCall(ctx, runID, toolCall{
                                ToolName: "browser.extract",
                                Input:    map[string]any{"mode": "metadata"},
                        }, browserUserTab, &amp;recovered, &amp;hadErrors)
                        if !metaOK || !clicked || !metadataPointsToTarget(metadataOutput, candidate.URL, seedURL) </span><span class="cov8" title="1">{
                                if _, ok := a.executeAutoResearchToolCall(ctx, runID, toolCall{
                                        ToolName: "browser.navigate",
                                        Input:    map[string]any{"url": candidate.URL},
                                }, browserUserTab, &amp;recovered, &amp;hadErrors); !ok </span><span class="cov0" title="0">{
                                        recordHostOutcome(candidate.URL, "no_extractable_content")
                                        continue</span>
                                }
                                <span class="cov8" title="1">metadataOutput, _ = a.executeAutoResearchToolCall(ctx, runID, toolCall{
                                        ToolName: "browser.extract",
                                        Input:    map[string]any{"mode": "metadata"},
                                }, browserUserTab, &amp;recovered, &amp;hadErrors)</span>
                        }

                        <span class="cov8" title="1">textOutput, _ := a.executeAutoResearchToolCall(ctx, runID, toolCall{
                                ToolName: "browser.extract",
                                Input:    map[string]any{"mode": "text"},
                        }, browserUserTab, &amp;recovered, &amp;hadErrors)
                        _, _ = a.executeAutoResearchToolCall(ctx, runID, toolCall{
                                ToolName: "browser.scroll",
                                Input:    map[string]any{"direction": "down", "amount": 900},
                        }, browserUserTab, &amp;recovered, &amp;hadErrors)
                        _, _ = a.executeAutoResearchToolCall(ctx, runID, toolCall{
                                ToolName: "browser.extract",
                                Input:    map[string]any{"mode": "text"},
                        }, browserUserTab, &amp;recovered, &amp;hadErrors)

                        reasonCode, reasonDetail := extractReasonFromToolOutput(textOutput)
                        if reasonCode == "" </span><span class="cov8" title="1">{
                                reasonCode, reasonDetail = extractReasonFromToolOutput(metadataOutput)
                        }</span>
                        <span class="cov8" title="1">recordHostOutcome(candidate.URL, reasonCode)
                        if shouldDeepenResearchOnPage(reasonCode, reasonDetail) &amp;&amp; totalArticleLinks &lt; maxAutoResearchLinks </span><span class="cov0" title="0">{
                                deeperEvalOutput, deeperOK := a.executeAutoResearchToolCall(ctx, runID, toolCall{
                                        ToolName: "browser.evaluate",
                                        Input:    map[string]any{"script": discoverArticleLinksScript},
                                }, browserUserTab, &amp;recovered, &amp;hadErrors)
                                if deeperOK </span><span class="cov0" title="0">{
                                        deeperCandidates := rankArticleLinkCandidates(candidate.URL, parseResearchLinkCandidates(deeperEvalOutput), visited, requestKeywords)
                                        deeperUsed := 0
                                        for _, deeperCandidate := range deeperCandidates </span><span class="cov0" title="0">{
                                                if totalArticleLinks &gt;= maxAutoResearchLinks || usedForSeed &gt;= maxAutoResearchPerSeed || deeperUsed &gt;= 2 </span><span class="cov0" title="0">{
                                                        break</span>
                                                }
                                                <span class="cov0" title="0">if shouldSkipHost(deeperCandidate.URL) </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">if _, exists := visited[deeperCandidate.URL]; exists </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">visited[deeperCandidate.URL] = struct{}{}
                                                if _, ok := a.executeAutoResearchToolCall(ctx, runID, toolCall{
                                                        ToolName: "browser.navigate",
                                                        Input:    map[string]any{"url": deeperCandidate.URL},
                                                }, browserUserTab, &amp;recovered, &amp;hadErrors); !ok </span><span class="cov0" title="0">{
                                                        recordHostOutcome(deeperCandidate.URL, "no_extractable_content")
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">_, _ = a.executeAutoResearchToolCall(ctx, runID, toolCall{
                                                        ToolName: "browser.extract",
                                                        Input:    map[string]any{"mode": "metadata"},
                                                }, browserUserTab, &amp;recovered, &amp;hadErrors)
                                                _, _ = a.executeAutoResearchToolCall(ctx, runID, toolCall{
                                                        ToolName: "browser.extract",
                                                        Input:    map[string]any{"mode": "text"},
                                                }, browserUserTab, &amp;recovered, &amp;hadErrors)
                                                recordHostOutcome(deeperCandidate.URL, "")
                                                _, _ = a.executeAutoResearchToolCall(ctx, runID, toolCall{
                                                        ToolName: "browser.scroll",
                                                        Input:    map[string]any{"direction": "down", "amount": 900},
                                                }, browserUserTab, &amp;recovered, &amp;hadErrors)
                                                _, _ = a.executeAutoResearchToolCall(ctx, runID, toolCall{
                                                        ToolName: "browser.extract",
                                                        Input:    map[string]any{"mode": "text"},
                                                }, browserUserTab, &amp;recovered, &amp;hadErrors)
                                                deeperUsed++
                                                usedForSeed++
                                                totalArticleLinks++</span>
                                        }
                                }
                        }

                        <span class="cov8" title="1">usedForSeed++
                        totalArticleLinks++</span>
                }
        }

        <span class="cov8" title="1">status := "completed"
        if len(recovered) == 0 </span><span class="cov8" title="1">{
                status = "noop"
        }</span> else<span class="cov8" title="1"> if hadErrors </span><span class="cov8" title="1">{
                status = "partial"
        }</span>
        <span class="cov8" title="1">_ = a.emitEvent(ctx, runID, "research.deepening", map[string]any{
                "status":                 status,
                "seed_count":             len(seeds),
                "candidate_articles":     totalArticleLinks,
                "tool_calls_executed":    len(recovered),
                "had_execution_failures": hadErrors,
        })
        return recovered, hadErrors</span>
}

func (a *RunActivities) executeAutoResearchToolCall(
        ctx context.Context,
        runID string,
        call toolCall,
        browserUserTab browserUserTabConfig,
        recovered *[]toolCall,
        hadErrors *bool,
) (map[string]any, bool) <span class="cov8" title="1">{
        output, err := a.executeToolCall(ctx, runID, call, browserUserTab)
        if err != nil </span><span class="cov8" title="1">{
                *hadErrors = true
                _ = a.postEvent(ctx, runID, "tool.failed", buildToolFailurePayload(call.ToolName, err))
                return nil, false
        }</span>
        <span class="cov8" title="1">*recovered = append(*recovered, toolCall{ToolName: call.ToolName, Input: output})
        return output, true</span>
}

func collectResearchSeedURLs(successfulToolCalls []toolCall, restrictToKnownHosts bool) []string <span class="cov8" title="1">{
        evidence := collectWebResearchEvidence(successfulToolCalls)
        seeds := make([]string, 0, maxAutoResearchSeedPages)
        seenHosts := map[string]struct{}{}

        appendSeed := func(rawURL string) </span><span class="cov8" title="1">{
                if len(seeds) &gt;= maxAutoResearchSeedPages </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">normalized := normalizeResearchURL(rawURL)
                if normalized == "" </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">parsed, err := url.Parse(normalized)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">host := strings.ToLower(strings.TrimSpace(parsed.Hostname()))
                if host == "" </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">if restrictToKnownHosts &amp;&amp; !isKnownResearchNewsHost(host) &amp;&amp; !isSyntheticResearchHost(host) </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">if isSearchSeedHost(host) || isDisallowedResearchHost(host) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">if _, exists := seenHosts[host]; exists </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">seenHosts[host] = struct{}{}
                seeds = append(seeds, normalized)</span>
        }

        <span class="cov8" title="1">for _, item := range evidence </span><span class="cov8" title="1">{
                reason := strings.ToLower(strings.TrimSpace(item.ReasonDetail))
                code := strings.ToLower(strings.TrimSpace(item.ReasonCode))
                if code == "blocked_by_bot_protection" || code == "consent_wall" || code == "login_wall" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if code == "no_extractable_content" || reason == "homepage_not_article" || reason == "section_index_page" || reason == "missing_summary_text" </span><span class="cov8" title="1">{
                        appendSeed(item.URL)
                }</span>
        }
        <span class="cov8" title="1">if len(seeds) &gt;= maxAutoResearchSeedPages </span><span class="cov0" title="0">{
                return seeds
        }</span>
        <span class="cov8" title="1">for _, item := range evidence </span><span class="cov8" title="1">{
                appendSeed(item.URL)
                if len(seeds) &gt;= maxAutoResearchSeedPages </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return seeds</span>
}

func isSyntheticResearchHost(host string) bool <span class="cov8" title="1">{
        normalized := strings.ToLower(strings.TrimSpace(host))
        if normalized == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if normalized == "localhost" || normalized == "127.0.0.1" || normalized == "::1" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if normalized == "example.com" || normalized == "example.org" || normalized == "example.net" </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return strings.HasSuffix(normalized, ".example.com") || strings.HasSuffix(normalized, ".example.org") || strings.HasSuffix(normalized, ".example.net")</span>
}

func requestLikelyCryptoResearch(userRequest string) bool <span class="cov8" title="1">{
        text := strings.ToLower(strings.TrimSpace(userRequest))
        if text == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">cues := []string{
                "crypto",
                "defi",
                "rwa",
                "real world asset",
                "real-world asset",
                "tokenization",
                "bitcoin",
                "ethereum",
                "stablecoin",
                "web3",
                "on-chain",
                "onchain",
        }
        for _, cue := range cues </span><span class="cov8" title="1">{
                if strings.Contains(text, cue) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func fallbackResearchSeedURLsFromRequest(userRequest string) []string <span class="cov8" title="1">{
        query := researchSeedQueryFromRequest(userRequest)
        if query == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">candidates := []string{
                "https://www.reuters.com/site-search/?query=" + url.QueryEscape(query),
                "https://www.reuters.com/markets/",
                "https://www.forbes.com/search/?q=" + url.QueryEscape(query),
                "https://finance.yahoo.com/search?p=" + url.QueryEscape(query),
                "https://thedefiant.io/news",
                "https://www.ledgerinsights.com/tag/tokenization/",
                "https://www.ledgerinsights.com/category/tokenization/",
                "https://cointelegraph.com/tags/rwa",
                "https://cointelegraph.com/tags/tokenization",
                "https://www.coindesk.com/tag/real-world-assets/",
                "https://www.coindesk.com/markets/",
                "https://www.coindesk.com/business/",
        }
        seen := map[string]struct{}{}
        out := make([]string, 0, len(candidates))
        for _, candidate := range candidates </span><span class="cov8" title="1">{
                normalized := normalizeResearchURL(candidate)
                if normalized == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, exists := seen[normalized]; exists </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">seen[normalized] = struct{}{}
                out = append(out, normalized)
                if len(out) &gt;= maxAutoResearchSeedPages </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return out</span>
}

func mergeResearchSeeds(maxItems int, primary []string, fallback []string, minFallback int) []string <span class="cov8" title="1">{
        if maxItems &lt; 1 </span><span class="cov0" title="0">{
                maxItems = maxAutoResearchSeedPages
        }</span>
        <span class="cov8" title="1">if minFallback &lt; 0 </span><span class="cov0" title="0">{
                minFallback = 0
        }</span>
        <span class="cov8" title="1">if minFallback &gt; maxItems </span><span class="cov0" title="0">{
                minFallback = maxItems
        }</span>
        <span class="cov8" title="1">seen := map[string]struct{}{}
        out := make([]string, 0, maxItems)
        primaryCap := maxItems - minFallback
        if primaryCap &lt; 0 </span><span class="cov0" title="0">{
                primaryCap = 0
        }</span>
        <span class="cov8" title="1">appendUnique := func(seed string) bool </span><span class="cov8" title="1">{
                normalized := normalizeResearchURL(seed)
                if normalized == "" </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">if _, exists := seen[normalized]; exists </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">seen[normalized] = struct{}{}
                out = append(out, normalized)
                return true</span>
        }

        <span class="cov8" title="1">for _, seed := range primary </span><span class="cov8" title="1">{
                if len(out) &gt;= primaryCap </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">appendUnique(seed)</span>
        }
        <span class="cov8" title="1">for _, seed := range fallback </span><span class="cov8" title="1">{
                if len(out) &gt;= maxItems </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">appendUnique(seed)</span>
        }
        <span class="cov8" title="1">for _, seed := range primary </span><span class="cov8" title="1">{
                if len(out) &gt;= maxItems </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">appendUnique(seed)</span>
        }
        <span class="cov8" title="1">return out</span>
}

func researchKeywordsFromRequest(userRequest string) []string <span class="cov8" title="1">{
        normalized := strings.ToLower(strings.TrimSpace(userRequest))
        if normalized == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">stopwords := map[string]struct{}{
                "browse": {}, "web": {}, "give": {}, "top": {}, "current": {}, "news": {}, "stories": {},
                "surrounding": {}, "with": {}, "from": {}, "and": {}, "for": {}, "the": {}, "that": {},
                "summary": {}, "comprehensive": {}, "items": {}, "item": {}, "real": {}, "world": {}, "asset": {}, "assets": {},
        }
        parts := strings.FieldsFunc(normalized, func(r rune) bool </span><span class="cov8" title="1">{
                return (r &lt; 'a' || r &gt; 'z') &amp;&amp; (r &lt; '0' || r &gt; '9')
        }</span>)
        <span class="cov8" title="1">seen := map[string]struct{}{}
        keywords := make([]string, 0, 8)
        if strings.Contains(normalized, "real world asset") || strings.Contains(normalized, "real-world asset") </span><span class="cov0" title="0">{
                seen["rwa"] = struct{}{}
                keywords = append(keywords, "rwa")
        }</span>
        <span class="cov8" title="1">for _, part := range parts </span><span class="cov8" title="1">{
                part = strings.TrimSpace(part)
                if len(part) &lt; 3 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">switch part </span>{
                case "rwas":<span class="cov8" title="1">
                        part = "rwa"</span>
                case "defis":<span class="cov0" title="0">
                        part = "defi"</span>
                }
                <span class="cov8" title="1">if _, stop := stopwords[part]; stop </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, exists := seen[part]; exists </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">seen[part] = struct{}{}
                keywords = append(keywords, part)
                if len(keywords) &gt;= 8 </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return keywords</span>
}

func researchSeedQueryFromRequest(userRequest string) string <span class="cov8" title="1">{
        keywords := researchKeywordsFromRequest(userRequest)
        if len(keywords) &gt; 0 </span><span class="cov8" title="1">{
                return strings.Join(keywords, " ")
        }</span>
        <span class="cov0" title="0">parts := strings.Fields(strings.TrimSpace(strings.ToLower(userRequest)))
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if len(parts) &gt; 10 </span><span class="cov0" title="0">{
                parts = parts[:10]
        }</span>
        <span class="cov0" title="0">return strings.Join(parts, " ")</span>
}

func normalizeResearchURL(raw string) string <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(raw)
        if trimmed == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">parsed, err := url.Parse(trimmed)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">if parsed.Scheme != "http" &amp;&amp; parsed.Scheme != "https" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">parsed.Fragment = ""
        query := parsed.Query()
        for _, key := range []string{
                "utm_source", "utm_medium", "utm_campaign", "utm_term", "utm_content",
                "gclid", "fbclid", "yclid", "mc_cid", "mc_eid",
        } </span><span class="cov8" title="1">{
                query.Del(key)
        }</span>
        <span class="cov8" title="1">parsed.RawQuery = query.Encode()
        return parsed.String()</span>
}

func parseResearchLinkCandidates(output map[string]any) []researchLinkCandidate <span class="cov8" title="1">{
        rawResult := output["result"]
        if rawResult == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">items, ok := rawResult.([]any)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">candidates := make([]researchLinkCandidate, 0, len(items))
        for _, item := range items </span><span class="cov8" title="1">{
                switch typed := item.(type) </span>{
                case string:<span class="cov0" title="0">
                        candidates = append(candidates, researchLinkCandidate{URL: typed})</span>
                case map[string]any:<span class="cov8" title="1">
                        candidates = append(candidates, researchLinkCandidate{
                                URL:        firstNonEmptyString(typed["href"], typed["url"]),
                                AnchorText: strings.TrimSpace(toString(typed["text"])),
                        })</span>
                }
        }
        <span class="cov8" title="1">return candidates</span>
}

func resolveResearchCandidateURL(candidateURL string, seedURL string) string <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(candidateURL)
        if trimmed == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">base, baseErr := url.Parse(strings.TrimSpace(seedURL))
        parsed, err := url.Parse(trimmed)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">if !parsed.IsAbs() &amp;&amp; baseErr == nil &amp;&amp; base != nil </span><span class="cov0" title="0">{
                parsed = base.ResolveReference(parsed)
        }</span>
        <span class="cov8" title="1">host := strings.ToLower(strings.TrimSpace(parsed.Hostname()))
        if host == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">query := parsed.Query()
        if strings.Contains(host, "google.") </span><span class="cov8" title="1">{
                if parsed.Path == "/url" </span><span class="cov8" title="1">{
                        if redirected := strings.TrimSpace(firstNonEmptyString(query.Get("url"), query.Get("q"))); redirected != "" </span><span class="cov8" title="1">{
                                return normalizeResearchURL(redirected)
                        }</span>
                }
                <span class="cov8" title="1">if redirected := strings.TrimSpace(query.Get("url")); redirected != "" </span><span class="cov0" title="0">{
                        return normalizeResearchURL(redirected)
                }</span>
        }
        <span class="cov8" title="1">if strings.Contains(host, "duckduckgo.com") </span><span class="cov8" title="1">{
                if redirected := strings.TrimSpace(query.Get("uddg")); redirected != "" </span><span class="cov0" title="0">{
                        if unescaped, unescapeErr := url.QueryUnescape(redirected); unescapeErr == nil </span><span class="cov0" title="0">{
                                redirected = unescaped
                        }</span>
                        <span class="cov0" title="0">return normalizeResearchURL(redirected)</span>
                }
        }
        <span class="cov8" title="1">return normalizeResearchURL(parsed.String())</span>
}

func isSearchSeedHost(host string) bool <span class="cov8" title="1">{
        normalized := strings.ToLower(strings.TrimSpace(host))
        if normalized == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">searchHosts := []string{
                "google.com",
                "news.google.com",
                "duckduckgo.com",
                "bing.com",
                "search.yahoo.com",
                "yahoo.com",
        }
        for _, candidate := range searchHosts </span><span class="cov8" title="1">{
                if normalized == candidate || strings.HasSuffix(normalized, "."+candidate) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func isDisallowedResearchHost(host string) bool <span class="cov8" title="1">{
        normalized := strings.ToLower(strings.TrimSpace(host))
        if normalized == "" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">blocked := []string{
                "accounts.google.com",
                "policies.google.com",
                "support.google.com",
                "consent.google.com",
                "myaccount.google.com",
        }
        for _, candidate := range blocked </span><span class="cov8" title="1">{
                if normalized == candidate || strings.HasSuffix(normalized, "."+candidate) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func isUtilityResearchHost(host string) bool <span class="cov8" title="1">{
        normalized := strings.ToLower(strings.TrimSpace(host))
        if normalized == "" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">utilityHosts := []string{
                "duckduckgo.com",
                "help.duckduckgo.com",
                "apps.apple.com",
                "play.google.com",
                "chromewebstore.google.com",
                "support.google.com",
                "policies.google.com",
        }
        for _, candidate := range utilityHosts </span><span class="cov8" title="1">{
                if normalized == candidate || strings.HasSuffix(normalized, "."+candidate) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func isKnownResearchNewsHost(host string) bool <span class="cov8" title="1">{
        normalized := strings.ToLower(strings.TrimSpace(host))
        if normalized == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">newsHosts := []string{
                "reuters.com",
                "forbes.com",
                "bloomberg.com",
                "coindesk.com",
                "cointelegraph.com",
                "theblock.co",
                "decrypt.co",
                "thedefiant.io",
                "ledgerinsights.com",
                "binance.com",
                "coinmarketcap.com",
                "coingecko.com",
                "finance.yahoo.com",
                "prnewswire.com",
                "rwa.xyz",
                "protos.com",
        }
        for _, candidate := range newsHosts </span><span class="cov8" title="1">{
                if normalized == candidate || strings.HasSuffix(normalized, "."+candidate) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func rankArticleLinkCandidates(seedURL string, candidates []researchLinkCandidate, visited map[string]struct{}, requestKeywords []string) []researchLinkCandidate <span class="cov8" title="1">{
        seedParsed, err := url.Parse(seedURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">seedHost := strings.ToLower(strings.TrimSpace(seedParsed.Hostname()))
        if seedHost == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">allowCrossDomain := isSearchSeedHost(seedHost)
        targetYear := ""
        targetMonth := ""
        specificKeywords := make([]string, 0, len(requestKeywords))
        for _, keyword := range requestKeywords </span><span class="cov8" title="1">{
                if len(keyword) == 4 &amp;&amp; strings.HasPrefix(keyword, "20") </span><span class="cov8" title="1">{
                        targetYear = keyword
                        continue</span>
                }
                <span class="cov8" title="1">switch keyword </span>{
                case "january", "february", "march", "april", "may", "june",
                        "july", "august", "september", "october", "november", "december":<span class="cov8" title="1">
                        targetMonth = keyword</span>
                case "crypto", "news", "latest", "current", "stories", "story":<span class="cov8" title="1"></span>
                        // Generic terms are not strong topical filters.
                default:<span class="cov8" title="1">
                        specificKeywords = append(specificKeywords, keyword)</span>
                }
        }

        <span class="cov8" title="1">filtered := make([]researchLinkCandidate, 0, len(candidates))
        seen := map[string]struct{}{}
        for _, candidate := range candidates </span><span class="cov8" title="1">{
                normalized := resolveResearchCandidateURL(candidate.URL, seedURL)
                if normalized == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, exists := visited[normalized]; exists </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, exists := seen[normalized]; exists </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">parsed, err := url.Parse(normalized)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">host := strings.ToLower(strings.TrimSpace(parsed.Hostname()))
                if host == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if isDisallowedResearchHost(host) || isUtilityResearchHost(host) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if allowCrossDomain &amp;&amp; isSearchSeedHost(host) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if !allowCrossDomain &amp;&amp; host != seedHost &amp;&amp; !strings.HasSuffix(host, "."+seedHost) &amp;&amp; !strings.HasSuffix(seedHost, "."+host) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">path := strings.ToLower(strings.TrimSpace(parsed.Path))
                if path == "" || path == "/" || strings.HasPrefix(path, "/search") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">query := parsed.Query()
                if query.Has("q") || query.Has("query") || query.Has("s") || query.Has("blob") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">switch detail := nonArticleReasonForURL(normalized); detail </span>{
                case "search_results_page", "homepage_not_article", "section_index_page", "legal_or_policy_page":<span class="cov8" title="1">
                        continue</span>
                }
                <span class="cov8" title="1">segments := strings.Split(strings.Trim(path, "/"), "/")
                if len(segments) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">lastSegment := segments[len(segments)-1]
                if strings.Contains(lastSegment, ".") </span><span class="cov0" title="0">{
                        suffix := strings.ToLower(lastSegment[strings.LastIndex(lastSegment, "."):])
                        switch suffix </span>{
                        case ".jpg", ".jpeg", ".png", ".gif", ".svg", ".webp", ".pdf":<span class="cov0" title="0">
                                continue</span>
                        }
                }

                <span class="cov8" title="1">anchorText := strings.TrimSpace(candidate.AnchorText)
                anchorLower := strings.ToLower(anchorText)
                if strings.Contains(anchorLower, "privacy") || strings.Contains(anchorLower, "terms") || strings.Contains(anchorLower, "cookie") || strings.Contains(anchorLower, "consent") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">haystack := strings.ToLower(path + " " + anchorText)

                score := 0
                if datePathRE.MatchString(path) </span><span class="cov8" title="1">{
                        score += 5
                }</span>
                <span class="cov8" title="1">if len(segments) &gt;= 3 </span><span class="cov8" title="1">{
                        score += 2
                }</span> else<span class="cov8" title="1"> {
                        score++
                }</span>
                <span class="cov8" title="1">if strings.Contains(lastSegment, "-") </span><span class="cov8" title="1">{
                        score += 2
                }</span>
                <span class="cov8" title="1">if len(lastSegment) &gt;= 24 </span><span class="cov8" title="1">{
                        score++
                }</span>
                <span class="cov8" title="1">if len(strings.Fields(anchorText)) &gt;= 4 </span><span class="cov8" title="1">{
                        score++
                }</span>

                <span class="cov8" title="1">keywordMatches := 0
                if len(requestKeywords) &gt; 0 </span><span class="cov8" title="1">{
                        for _, keyword := range requestKeywords </span><span class="cov8" title="1">{
                                if keyword != "" &amp;&amp; strings.Contains(haystack, keyword) </span><span class="cov8" title="1">{
                                        keywordMatches++
                                }</span>
                        }
                        <span class="cov8" title="1">if keywordMatches &gt; 0 </span><span class="cov8" title="1">{
                                score += keywordMatches * 2
                        }</span> else<span class="cov8" title="1"> {
                                score--
                        }</span>
                }

                <span class="cov8" title="1">if strings.Contains(path, "/press-releases/") || strings.Contains(path, "/press-release/") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.Contains(path, "/sponsored/") </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.Contains(path, "/opinion/") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.Contains(path, "/people/") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.Contains(path, "/price/") || strings.Contains(path, "/prices/") || strings.Contains(path, "/video/") || strings.Contains(path, "/videos/") || strings.Contains(path, "/podcast/") || strings.Contains(path, "/podcasts/") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.Contains(path, "/tag/") || strings.Contains(path, "/tags/") || strings.Contains(path, "/topic/") || strings.Contains(path, "/topics/") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if targetYear != "" </span><span class="cov8" title="1">{
                        matchedYear := anyYearRE.FindString(haystack)
                        if strings.Contains(haystack, targetYear) </span><span class="cov8" title="1">{
                                score += 3
                        }</span> else<span class="cov8" title="1"> if matchedYear != "" &amp;&amp; matchedYear != targetYear </span><span class="cov0" title="0">{
                                continue</span>
                        } else<span class="cov8" title="1"> if legacyYearRE.MatchString(haystack) </span><span class="cov0" title="0">{
                                score -= 10
                        }</span>
                }
                <span class="cov8" title="1">if targetMonth != "" &amp;&amp; strings.Contains(haystack, targetMonth) </span><span class="cov8" title="1">{
                        score += 2
                }</span>

                <span class="cov8" title="1">specificMatches := 0
                if len(specificKeywords) &gt; 0 </span><span class="cov8" title="1">{
                        specificMatches = keywordMatchCount(specificKeywords, haystack)
                        if specificMatches &gt; 0 </span><span class="cov8" title="1">{
                                score += specificMatches * 2
                        }</span> else<span class="cov8" title="1"> {
                                continue</span>
                        }
                }

                <span class="cov8" title="1">if allowCrossDomain &amp;&amp; host != seedHost </span><span class="cov8" title="1">{
                        if !isKnownResearchNewsHost(host) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">score += 2
                        score += 2</span>
                }

                <span class="cov8" title="1">if score &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">seen[normalized] = struct{}{}
                filtered = append(filtered, researchLinkCandidate{
                        URL:        normalized,
                        AnchorText: strings.TrimSpace(candidate.AnchorText),
                        Score:      score,
                })</span>
        }

        <span class="cov8" title="1">sort.SliceStable(filtered, func(i, j int) bool </span><span class="cov8" title="1">{
                return filtered[i].Score &gt; filtered[j].Score
        }</span>)
        <span class="cov8" title="1">return filtered</span>
}

func evaluateClickSucceeded(output map[string]any) bool <span class="cov8" title="1">{
        result, ok := output["result"]
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">switch typed := result.(type) </span>{
        case bool:<span class="cov0" title="0">
                return typed</span>
        case map[string]any:<span class="cov0" title="0">
                switch clicked := typed["clicked"].(type) </span>{
                case bool:<span class="cov0" title="0">
                        return clicked</span>
                case string:<span class="cov0" title="0">
                        return strings.EqualFold(strings.TrimSpace(clicked), "true")</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

func metadataPointsToTarget(metadataOutput map[string]any, targetURL string, seedURL string) bool <span class="cov8" title="1">{
        currentURL := extractURLFromToolOutput(metadataOutput)
        currentNorm := normalizeResearchURL(currentURL)
        targetNorm := normalizeResearchURL(targetURL)
        seedNorm := normalizeResearchURL(seedURL)
        if currentNorm == "" || targetNorm == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if currentNorm == targetNorm </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if currentNorm == seedNorm </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">currentParsed, currentErr := url.Parse(currentNorm)
        targetParsed, targetErr := url.Parse(targetNorm)
        if currentErr != nil || targetErr != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if !strings.EqualFold(strings.TrimSpace(currentParsed.Hostname()), strings.TrimSpace(targetParsed.Hostname())) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">currentPath := strings.Trim(strings.ToLower(strings.TrimSpace(currentParsed.Path)), "/")
        targetPath := strings.Trim(strings.ToLower(strings.TrimSpace(targetParsed.Path)), "/")
        if currentPath == "" || targetPath == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if currentPath == targetPath </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">currentSegments := strings.Split(currentPath, "/")
        targetSegments := strings.Split(targetPath, "/")
        if len(currentSegments) == 0 || len(targetSegments) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return currentSegments[len(currentSegments)-1] == targetSegments[len(targetSegments)-1]</span>
}

func extractURLFromToolOutput(output map[string]any) string <span class="cov8" title="1">{
        if output == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">if direct := strings.TrimSpace(toString(output["url"])); direct != "" </span><span class="cov8" title="1">{
                return direct
        }</span>
        <span class="cov0" title="0">if extracted, ok := output["extracted"].(map[string]any); ok </span><span class="cov0" title="0">{
                if nested := strings.TrimSpace(toString(extracted["url"])); nested != "" </span><span class="cov0" title="0">{
                        return nested
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func extractReasonFromToolOutput(output map[string]any) (string, string) <span class="cov8" title="1">{
        if output == nil </span><span class="cov0" title="0">{
                return "", ""
        }</span>
        <span class="cov8" title="1">readDiagnostics := func(value any) (string, string) </span><span class="cov8" title="1">{
                diagnostics, _ := value.(map[string]any)
                if diagnostics == nil </span><span class="cov8" title="1">{
                        return "", ""
                }</span>
                <span class="cov8" title="1">return strings.TrimSpace(toString(diagnostics["reason_code"])), strings.TrimSpace(toString(diagnostics["reason_detail"]))</span>
        }
        <span class="cov8" title="1">code, detail := readDiagnostics(output["diagnostics"])
        if code != "" || detail != "" </span><span class="cov0" title="0">{
                return code, detail
        }</span>
        <span class="cov8" title="1">code, detail = readDiagnostics(output["extracted"])
        if code != "" || detail != "" </span><span class="cov0" title="0">{
                return code, detail
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(toString(output["reason_code"])), strings.TrimSpace(toString(output["reason_detail"]))</span>
}

func shouldDeepenResearchOnPage(reasonCode string, reasonDetail string) bool <span class="cov8" title="1">{
        if strings.TrimSpace(strings.ToLower(reasonCode)) != "no_extractable_content" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">switch strings.TrimSpace(strings.ToLower(reasonDetail)) </span>{
        case "section_index_page", "homepage_not_article", "search_results_page", "landing_page_or_index_content", "missing_summary_text":<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func looksLikeInProgressResearchNarrative(response string) bool <span class="cov8" title="1">{
        text := strings.ToLower(strings.TrimSpace(response))
        if text == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">cues := []string{
                "let me try",
                "i'll try",
                "i will try",
                "i can try",
                "i can continue",
                "i'll continue",
                "i will continue",
                "alternative sources",
                "try alternative",
                "next, i",
                "next i",
        }
        for _, cue := range cues </span><span class="cov8" title="1">{
                if strings.Contains(text, cue) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return strings.Contains(text, "i'll") &amp;&amp; strings.Contains(text, "try")</span>
}

func buildInsufficientWebResearchFallback(successfulToolCalls []toolCall, requirements webResearchRequirements, userRequest string, lastResponse string) string <span class="cov8" title="1">{
        if deterministic := strings.TrimSpace(buildDeterministicWebResearchSummaryForRequest(successfulToolCalls, requirements, userRequest)); deterministic != "" </span><span class="cov8" title="1">{
                return deterministic
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(fmt.Sprintf("I could not reach the requested evidence threshold of %d usable sources with extractable article pages.", requirements.MinimumItems))</span>
}

func requiredWebResearchExtracts(minimumItems int) int <span class="cov8" title="1">{
        requiredExtracts := minimumItems / 2
        if requiredExtracts &lt; 2 </span><span class="cov8" title="1">{
                requiredExtracts = 2
        }</span>
        <span class="cov8" title="1">return requiredExtracts</span>
}

func hasSufficientWebResearchEvidence(successfulToolCalls []toolCall, requirements webResearchRequirements) bool <span class="cov0" title="0">{
        return hasSufficientWebResearchEvidenceForRequest(successfulToolCalls, requirements, "")
}</span>

func hasSufficientWebResearchEvidenceForRequest(successfulToolCalls []toolCall, requirements webResearchRequirements, userRequest string) bool <span class="cov8" title="1">{
        if !requirements.Enabled </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">uniqueSources, extractCount := summarizeWebResearchEvidenceForRequest(successfulToolCalls, userRequest)
        if uniqueSources &lt; requirements.MinimumItems </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">return extractCount &gt;= requiredWebResearchExtracts(requirements.MinimumItems)</span>
}

func buildResearchDiagnosticsDigest(successfulToolCalls []toolCall) string <span class="cov8" title="1">{
        evidence := collectWebResearchEvidence(successfulToolCalls)
        if len(evidence) == 0 </span><span class="cov0" title="0">{
                return "Research diagnostics: no extractable source diagnostics captured."
        }</span>
        <span class="cov8" title="1">var builder strings.Builder
        builder.WriteString("Research diagnostics:\n")
        for idx, item := range evidence </span><span class="cov8" title="1">{
                label := strings.TrimSpace(item.Title)
                if label == "" </span><span class="cov0" title="0">{
                        label = hostFromURL(item.URL)
                }</span>
                <span class="cov8" title="1">status := "ok"
                if item.blocked() </span><span class="cov0" title="0">{
                        status = "blocked"
                }</span> else<span class="cov8" title="1"> if !item.extractable() </span><span class="cov8" title="1">{
                        status = "low_quality"
                }</span>
                <span class="cov8" title="1">impact := strings.TrimSpace(item.Impact)
                reasonCode := strings.TrimSpace(item.ReasonCode)
                if reasonCode == "" </span><span class="cov8" title="1">{
                        reasonCode = "none"
                }</span>
                <span class="cov8" title="1">detail := strings.TrimSpace(item.ReasonDetail)
                if detail == "" &amp;&amp; reasonCode != "none" </span><span class="cov0" title="0">{
                        detail = reasonCode
                }</span>
                <span class="cov8" title="1">builder.WriteString(
                        fmt.Sprintf(
                                "%d. %s (%s) url=%s reason=%s detail=%s impact=%s\n",
                                idx+1,
                                label,
                                status,
                                item.URL,
                                reasonCode,
                                detail,
                                impact,
                        ),
                )</span>
        }
        <span class="cov8" title="1">return strings.TrimSpace(builder.String())</span>
}

func (a *RunActivities) generateFinalSynthesis(
        ctx context.Context,
        runID string,
        providers []llmProviderCandidate,
        baseMessages []llm.Message,
        userRequest string,
        successfulToolCalls []toolCall,
        researchRequirements webResearchRequirements,
) (string, error) <span class="cov8" title="1">{
        summary := buildToolCompletionSummary(successfulToolCalls, false, nil)
        researchDigest := ""
        requestedTopN := requestedTopNFromPrompt(userRequest, researchRequirements.MinimumItems)
        if researchRequirements.Enabled </span><span class="cov8" title="1">{
                researchDigest = buildResearchDiagnosticsDigest(successfulToolCalls)
        }</span>
        <span class="cov8" title="1">instruction := "Now produce the final user-facing answer only. Do not output tool JSON, fenced blocks, or additional tool calls."
        if researchRequirements.Enabled </span><span class="cov8" title="1">{
                instruction = fmt.Sprintf(
                        "Now produce the final user-facing answer only. Use at least %d cited source links and concise impact notes. Prefer a numbered Top %d list when the request asks for top items. For each item include: headline, date, source link, and a 2-4 sentence summary synthesized from extracted article body text (not metadata-only snippets). Start with a short overview and key themes section before the numbered items. Only cite deep-link article/source pages (not homepages/search/index pages). Do not include blocked/low-quality/source-diagnostics sections unless the user explicitly requested diagnostics. Do not output tool JSON, fenced blocks, or additional tool calls.",
                        researchRequirements.MinimumItems,
                        requestedTopN,
                )
        }</span>
        <span class="cov8" title="1">synthesisMessages := append([]llm.Message{}, baseMessages...)
        synthesisMessages = append(synthesisMessages,
                llm.Message{
                        Role: "system",
                        Content: fmt.Sprintf(
                                "Execution summary: %s\nOriginal request: %s\n%s\n%s",
                                summary,
                                truncateRunes(strings.TrimSpace(userRequest), 360),
                                researchDigest,
                                instruction,
                        ),
                },
        )
        synthesisMessages = clampConversationWindow(synthesisMessages, maxConversationMessages, maxConversationChars)
        return a.generateWithRetry(ctx, runID, providers, synthesisMessages)</span>
}

func formatToolResult(toolName string, output map[string]any, err error) string <span class="cov8" title="1">{
        payload := map[string]any{"tool_name": toolName}
        if err != nil </span><span class="cov8" title="1">{
                payload["error"] = err.Error()
        }</span>
        <span class="cov8" title="1">if output != nil </span><span class="cov8" title="1">{
                payload["output"] = output
        }</span>
        <span class="cov8" title="1">encoded, errMarshal := json.Marshal(payload)
        if errMarshal != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Tool result (%s): %v", toolName, err)
        }</span>
        <span class="cov8" title="1">text := string(encoded)
        if maxToolResultChars &gt; 0 </span><span class="cov8" title="1">{
                text = truncateRunes(text, maxToolResultChars)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("Tool result: %s", text)</span>
}

func buildToolFailurePayload(toolName string, err error) map[string]any <span class="cov8" title="1">{
        payload := map[string]any{
                "tool_name": toolName,
                "error":     strings.TrimSpace(err.Error()),
        }
        var execErr *toolExecutionError
        if errors.As(err, &amp;execErr) </span><span class="cov8" title="1">{
                if invocationID := strings.TrimSpace(execErr.InvocationID); invocationID != "" </span><span class="cov8" title="1">{
                        payload["tool_invocation_id"] = invocationID
                }</span>
        }
        <span class="cov8" title="1">if reasonCode := inferToolFailureReasonCode(err); reasonCode != "" </span><span class="cov8" title="1">{
                payload["reason_code"] = reasonCode
        }</span>
        <span class="cov8" title="1">return payload</span>
}

func inferToolFailureReasonCode(err error) string <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">message := strings.ToLower(strings.TrimSpace(err.Error()))
        switch </span>{
        case strings.Contains(message, "blocked_by_bot_protection"):<span class="cov8" title="1">
                return "blocked_by_bot_protection"</span>
        case strings.Contains(message, "consent_wall"):<span class="cov0" title="0">
                return "consent_wall"</span>
        case strings.Contains(message, "no_extractable_content"):<span class="cov0" title="0">
                return "no_extractable_content"</span>
        case strings.Contains(message, "user_tab_mode_unavailable"):<span class="cov0" title="0">
                return "user_tab_mode_unavailable"</span>
        case strings.Contains(message, "timeout"):<span class="cov0" title="0">
                return "timeout"</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}

func (a *RunActivities) executeToolCall(ctx context.Context, runID string, call toolCall, browserUserTab browserUserTabConfig) (map[string]any, error) <span class="cov8" title="1">{
        if a.toolRunner == "" </span><span class="cov0" title="0">{
                return nil, &amp;toolExecutionError{Message: "tool runner url not configured"}
        }</span>
        <span class="cov8" title="1">invocationID := uuid.New().String()
        toolInput := cloneAnyMap(call.Input)
        if browserUserTab.Enabled &amp;&amp; strings.HasPrefix(strings.ToLower(strings.TrimSpace(call.ToolName)), "browser.") </span><span class="cov8" title="1">{
                toolInput["_browser_mode"] = "user_tab"
                toolInput["_browser_guardrails"] = map[string]any{
                        "interaction_allowed": browserUserTab.InteractionAllowed,
                        "create_tab_group":    true,
                        "allowlist_domains":   browserUserTab.DomainAllowlist,
                        "preferred_browser":   browserUserTab.PreferredBrowser,
                        "browser_user_agent":  browserUserTab.BrowserUserAgent,
                }
        }</span>
        <span class="cov8" title="1">payload := map[string]any{
                "contract_version": "tool_contract_v2",
                "run_id":           runID,
                "invocation_id":    invocationID,
                "idempotency_key":  invocationID,
                "tool_name":        call.ToolName,
                "input":            toolInput,
        }
        if a.toolTimeout &gt; 0 </span><span class="cov8" title="1">{
                payload["timeout_ms"] = int(a.toolTimeout / time.Millisecond)
        }</span>
        <span class="cov8" title="1">body, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;toolExecutionError{InvocationID: invocationID, Message: err.Error()}
        }</span>
        <span class="cov8" title="1">requestCtx := ctx
        if a.toolTimeout &gt; 0 </span><span class="cov8" title="1">{
                var cancel context.CancelFunc
                requestCtx, cancel = context.WithTimeout(ctx, a.toolTimeout)
                defer cancel()
        }</span>
        <span class="cov8" title="1">req, err := http.NewRequestWithContext(requestCtx, http.MethodPost, a.toolRunner+"/tools/execute", bytes.NewReader(body))
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;toolExecutionError{InvocationID: invocationID, Message: err.Error()}
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        resp, err := a.httpClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, &amp;toolExecutionError{InvocationID: invocationID, Message: err.Error()}
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov8" title="1">{
                responseBody, _ := io.ReadAll(resp.Body)
                message := parseToolRunnerErrorMessage(resp.StatusCode, responseBody)
                return nil, &amp;toolExecutionError{InvocationID: invocationID, Message: message}
        }</span>
        <span class="cov8" title="1">var result toolRunnerResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;toolExecutionError{InvocationID: invocationID, Message: err.Error()}
        }</span>
        <span class="cov8" title="1">if result.Error != "" </span><span class="cov0" title="0">{
                return nil, &amp;toolExecutionError{InvocationID: invocationID, Message: strings.TrimSpace(result.Error)}
        }</span>
        <span class="cov8" title="1">return result.Output, nil</span>
}

func parseToolRunnerErrorMessage(statusCode int, responseBody []byte) string <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(string(responseBody))
        if trimmed == "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("tool runner returned status %d", statusCode)
        }</span>

        <span class="cov8" title="1">payload := map[string]any{}
        if err := json.Unmarshal(responseBody, &amp;payload); err != nil </span><span class="cov8" title="1">{
                return trimmed
        }</span>

        <span class="cov8" title="1">reasonCode := strings.TrimSpace(toString(payload["reason_code"]))
        if diagnostics, ok := payload["diagnostics"].(map[string]any); ok </span><span class="cov0" title="0">{
                if reasonCode == "" </span><span class="cov0" title="0">{
                        reasonCode = strings.TrimSpace(toString(diagnostics["reason_code"]))
                }</span>
                <span class="cov0" title="0">if reasonDetail := strings.TrimSpace(toString(diagnostics["reason_detail"])); reasonDetail != "" </span><span class="cov0" title="0">{
                        if detail := strings.TrimSpace(toString(payload["error"])); detail == "" </span><span class="cov0" title="0">{
                                payload["error"] = reasonDetail
                        }</span>
                }
        }

        <span class="cov8" title="1">errorText := firstNonEmptyString(payload["error"], payload["message"], payload["detail"])
        if errorText == "" </span><span class="cov0" title="0">{
                errorText = trimmed
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(strings.TrimSpace(errorText), "{") </span><span class="cov8" title="1">{
                nested := map[string]any{}
                if err := json.Unmarshal([]byte(errorText), &amp;nested); err == nil </span><span class="cov8" title="1">{
                        if reasonCode == "" </span><span class="cov8" title="1">{
                                reasonCode = strings.TrimSpace(toString(nested["reason_code"]))
                        }</span>
                        <span class="cov8" title="1">errorText = firstNonEmptyString(nested["error"], nested["message"], nested["detail"], errorText)</span>
                }
        }
        <span class="cov8" title="1">if reasonCode != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s (%s)", errorText, reasonCode)
        }</span>
        <span class="cov0" title="0">return errorText</span>
}

func (a *RunActivities) cleanupRunResources(ctx context.Context, runID string) error <span class="cov8" title="1">{
        if strings.TrimSpace(a.toolRunner) == "" || strings.TrimSpace(runID) == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">payloadBody, err := json.Marshal(map[string]any{"force": true})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">requestCtx, cancel := context.WithTimeout(ctx, 8*time.Second)
        defer cancel()
        req, err := http.NewRequestWithContext(
                requestCtx,
                http.MethodPost,
                fmt.Sprintf("%s/runs/%s/processes/cleanup", strings.TrimRight(a.toolRunner, "/"), url.PathEscape(runID)),
                bytes.NewReader(payloadBody),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        resp, err := a.httpClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov8" title="1">{
                body, _ := io.ReadAll(resp.Body)
                message := strings.TrimSpace(string(body))
                if message == "" </span><span class="cov8" title="1">{
                        message = fmt.Sprintf("cleanup failed with status %d", resp.StatusCode)
                }</span>
                <span class="cov8" title="1">return errors.New(message)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func shouldAutoGenerateResearchDoc(content string) bool <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(sanitizeResearchUserResponse(content))
        if trimmed == "" </span><span class="cov0" title="0">{
                trimmed = strings.TrimSpace(content)
        }</span>
        <span class="cov8" title="1">if trimmed == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">normalized := strings.ToLower(trimmed)
        if strings.Contains(normalized, "could not extract enough article-grade source") </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if strings.Contains(normalized, "low-quality extracts:") || strings.Contains(normalized, "blocked sources:") </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">hasStoryStructure := strings.Contains(normalized, "top stories:") || topStoryLineRE.MatchString(trimmed)
        if !hasStoryStructure </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return countSourceLinks(trimmed) &gt;= 3</span>
}

func sanitizeResearchUserResponse(content string) string <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(strings.ReplaceAll(content, "\r\n", "\n"))
        if trimmed == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">lines := strings.Split(trimmed, "\n")
        filtered := make([]string, 0, len(lines))
        for _, line := range lines </span><span class="cov8" title="1">{
                lower := strings.ToLower(strings.TrimSpace(line))
                if lower == "" </span><span class="cov8" title="1">{
                        filtered = append(filtered, line)
                        continue</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(lower, "overview:") &amp;&amp; strings.Contains(lower, "extractable source(s)") </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(lower, "usable sources:") &amp;&amp; strings.Contains(lower, "requested") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(lower, "coverage limitation:") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(lower, "stopped before finalizing") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.Contains(lower, "i can continue gathering alternatives") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.Contains(lower, "model kept returning intent text instead of executable tool json") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">filtered = append(filtered, line)</span>
        }

        <span class="cov8" title="1">sanitized := strings.TrimSpace(strings.Join(filtered, "\n"))
        if sanitized == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">lowered := strings.ToLower(sanitized)
        diagnosticsMarkers := []string{
                "\nlow-quality extracts:",
                "\nblocked sources:",
                "\nper-source diagnostics:",
        }
        cut := len(sanitized)
        for _, marker := range diagnosticsMarkers </span><span class="cov8" title="1">{
                if idx := strings.Index(lowered, marker); idx &gt;= 0 &amp;&amp; idx &lt; cut </span><span class="cov8" title="1">{
                        cut = idx
                }</span>
        }
        <span class="cov8" title="1">if strings.HasPrefix(lowered, "low-quality extracts:") ||
                strings.HasPrefix(lowered, "blocked sources:") ||
                strings.HasPrefix(lowered, "per-source diagnostics:") </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">if cut &lt; len(sanitized) </span><span class="cov8" title="1">{
                sanitized = strings.TrimSpace(sanitized[:cut])
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(sanitized)</span>
}

func normalizeResearchDocLine(line string) string <span class="cov8" title="1">{
        normalized := markdownLinkRE.ReplaceAllString(line, "$1 ($2)")
        replacer := strings.NewReplacer(
                "**", "",
                "__", "",
                "`", "",
                "### ", "",
                "## ", "",
                "# ", "",
        )
        normalized = replacer.Replace(normalized)
        return strings.TrimSpace(normalized)
}</span>

func researchDocSectionHeading(line string) string <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(line)
        if trimmed == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">normalized := strings.ToLower(strings.TrimSpace(strings.TrimSuffix(trimmed, ":")))
        switch normalized </span>{
        case "overview":<span class="cov8" title="1">
                return "Overview"</span>
        case "key themes":<span class="cov0" title="0">
                return "Key Themes"</span>
        case "top stories", "major headlines":<span class="cov8" title="1">
                return "Top Stories"</span>
        case "references", "sources":<span class="cov0" title="0">
                return "References"</span>
        }
        <span class="cov8" title="1">if strings.HasPrefix(trimmed, "## ") </span><span class="cov0" title="0">{
                return strings.TrimSpace(strings.TrimPrefix(trimmed, "## "))
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(trimmed, "# ") </span><span class="cov0" title="0">{
                return strings.TrimSpace(strings.TrimPrefix(trimmed, "# "))
        }</span>
        <span class="cov8" title="1">return ""</span>
}

func deriveResearchDocTitle(content string) string <span class="cov0" title="0">{
        if match := strings.TrimSpace(monthYearRE.FindString(content)); match != "" </span><span class="cov0" title="0">{
                words := strings.Fields(strings.ToLower(match))
                for idx, word := range words </span><span class="cov0" title="0">{
                        if word == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">words[idx] = strings.ToUpper(word[:1]) + word[1:]</span>
                }
                <span class="cov0" title="0">return fmt.Sprintf("Research Report - %s", strings.Join(words, " "))</span>
        }
        <span class="cov0" title="0">return "Web Research Report"</span>
}

func buildResearchDocSections(content string) []map[string]any <span class="cov8" title="1">{
        lines := strings.Split(strings.ReplaceAll(content, "\r\n", "\n"), "\n")
        sections := make([]map[string]any, 0, 8)
        currentHeading := "Summary"
        currentLines := make([]string, 0, 16)
        flush := func() </span><span class="cov8" title="1">{
                if len(currentLines) == 0 </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">joined := strings.TrimSpace(strings.Join(currentLines, "\n"))
                if joined == "" </span><span class="cov0" title="0">{
                        currentLines = currentLines[:0]
                        return
                }</span>
                <span class="cov8" title="1">sections = append(sections, map[string]any{
                        "heading": truncateRunes(currentHeading, 120),
                        "content": truncateRunes(joined, 12000),
                })
                currentLines = currentLines[:0]</span>
        }

        <span class="cov8" title="1">for _, rawLine := range lines </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(rawLine)
                if heading := researchDocSectionHeading(trimmed); heading != "" </span><span class="cov8" title="1">{
                        flush()
                        currentHeading = heading
                        continue</span>
                }
                <span class="cov8" title="1">if trimmed == "" </span><span class="cov8" title="1">{
                        if len(currentLines) &gt; 0 &amp;&amp; currentLines[len(currentLines)-1] != "" </span><span class="cov8" title="1">{
                                currentLines = append(currentLines, "")
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">currentLines = append(currentLines, normalizeResearchDocLine(trimmed))</span>
        }
        <span class="cov8" title="1">flush()
        if len(sections) &gt; 8 </span><span class="cov0" title="0">{
                return sections[:8]
        }</span>
        <span class="cov8" title="1">return sections</span>
}

func (a *RunActivities) toolRunnerSupportsTool(ctx context.Context, toolName string) bool <span class="cov0" title="0">{
        if strings.TrimSpace(a.toolRunner) == "" || strings.TrimSpace(toolName) == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">requestCtx, cancel := context.WithTimeout(ctx, 3*time.Second)
        defer cancel()
        capabilitiesURL := fmt.Sprintf("%s/tools/capabilities", strings.TrimRight(a.toolRunner, "/"))
        req, err := http.NewRequestWithContext(requestCtx, http.MethodGet, capabilitiesURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">resp, err := a.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">payload := map[string]any{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;payload); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return containsString(toStringSlice(payload["tools"]), toolName)</span>
}

func (a *RunActivities) maybeCreateResearchDocxArtifact(runID string, content string) <span class="cov8" title="1">{
        if strings.TrimSpace(runID) == "" || strings.TrimSpace(content) == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !shouldAutoGenerateResearchDoc(content) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(a.toolRunner) == "" </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 20*time.Second)
        defer cancel()
        if !a.toolRunnerSupportsTool(ctx, "document.create_docx") </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">sections := buildResearchDocSections(content)
        if len(sections) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">_, _ = a.executeToolCall(ctx, runID, toolCall{
                ToolName: "document.create_docx",
                Input: map[string]any{
                        "title":    deriveResearchDocTitle(content),
                        "sections": sections,
                },
        }, browserUserTabConfig{})</span>
}

func (a *RunActivities) postMessage(ctx context.Context, runID string, content string) error <span class="cov8" title="1">{
        sanitizedContent := strings.TrimSpace(sanitizeResearchUserResponse(content))
        if sanitizedContent == "" </span><span class="cov0" title="0">{
                sanitizedContent = strings.TrimSpace(content)
        }</span>
        <span class="cov8" title="1">if sanitizedContent == "" </span><span class="cov0" title="0">{
                return errors.New("assistant message content empty")
        }</span>
        <span class="cov8" title="1">url := fmt.Sprintf("%s/runs/%s/messages", a.controlPlane, runID)
        body, err := marshalJSON(map[string]string{
                "role":    "assistant",
                "content": sanitizedContent,
        })
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">requestCtx, cancel := context.WithTimeout(ctx, a.requestTimeout)
        defer cancel()
        req, err := http.NewRequestWithContext(requestCtx, http.MethodPost, url, bytes.NewReader(body))
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        resp, err := a.httpClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode &gt;= 400 </span><span class="cov8" title="1">{
                return fmt.Errorf("control plane message failed: %s", resp.Status)
        }</span>
        <span class="cov8" title="1">a.maybeCreateResearchDocxArtifact(runID, sanitizedContent)
        return nil</span>
}

func (a *RunActivities) postEvent(ctx context.Context, runID string, eventType string, payload map[string]any) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/runs/%s/events", a.controlPlane, runID)
        body, err := marshalJSON(map[string]any{
                "type":      eventType,
                "source":    "llm",
                "timestamp": time.Now().UTC().Format(time.RFC3339Nano),
                "trace_id":  uuid.New().String(),
                "payload":   payload,
        })
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">requestCtx, cancel := context.WithTimeout(ctx, a.requestTimeout)
        defer cancel()
        req, err := http.NewRequestWithContext(requestCtx, http.MethodPost, url, bytes.NewReader(body))
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        resp, err := a.httpClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if resp.StatusCode &gt;= 400 </span><span class="cov8" title="1">{
                return fmt.Errorf("control plane event failed: %s", resp.Status)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package workflows

import (
        "time"

        "go.temporal.io/sdk/temporal"
        "go.temporal.io/sdk/workflow"
)

type RunInput struct {
        RunID   string
        Message string
}

type RunResult struct {
        Status string
}

func RunWorkflow(ctx workflow.Context, input RunInput) (RunResult, error) <span class="cov8" title="1">{
        activityOptions := workflow.ActivityOptions{
                StartToCloseTimeout: 20 * time.Minute,
                RetryPolicy: &amp;temporal.RetryPolicy{
                        MaximumAttempts: 1,
                },
        }
        ctx = workflow.WithActivityOptions(ctx, activityOptions)

        logger := workflow.GetLogger(ctx)
        messageCh := workflow.GetSignalChannel(ctx, MessageSignalName)

        for </span><span class="cov8" title="1">{
                selector := workflow.NewSelector(ctx)
                selector.AddReceive(messageCh, func(c workflow.ReceiveChannel, more bool) </span><span class="cov8" title="1">{
                        var msg string
                        c.Receive(ctx, &amp;msg)
                        logger.Info("received message", "message", msg)
                        planResult := PlanOutput{}
                        if err := workflow.ExecuteActivity(ctx, "PlanExecution", PlanInput{
                                RunID:   input.RunID,
                                Message: msg,
                        }).Get(ctx, &amp;planResult); err != nil </span><span class="cov8" title="1">{
                                logger.Error("planning activity failed", "error", err)
                                failureInput := RunFailureInput{
                                        RunID: input.RunID,
                                        Error: "planning: " + err.Error(),
                                }
                                if failureErr := workflow.ExecuteActivity(ctx, "HandleRunFailure", failureInput).Get(ctx, nil); failureErr != nil </span><span class="cov8" title="1">{
                                        logger.Error("failed to persist run failure event", "error", failureErr)
                                }</span>
                                <span class="cov8" title="1">return</span>
                        }

                        <span class="cov8" title="1">executeResult := ExecuteOutput{}
                        if err := workflow.ExecuteActivity(ctx, "ExecutePlan", ExecuteInput{
                                RunID:   input.RunID,
                                Message: msg,
                                PlanID:  planResult.PlanID,
                        }).Get(ctx, &amp;executeResult); err != nil </span><span class="cov8" title="1">{
                                logger.Error("execution activity failed", "error", err)
                                failureInput := RunFailureInput{
                                        RunID: input.RunID,
                                        Error: "execution: " + err.Error(),
                                }
                                if failureErr := workflow.ExecuteActivity(ctx, "HandleRunFailure", failureInput).Get(ctx, nil); failureErr != nil </span><span class="cov0" title="0">{
                                        logger.Error("failed to persist run failure event", "error", failureErr)
                                }</span>
                                <span class="cov8" title="1">return</span>
                        }

                        <span class="cov8" title="1">verifyResult := VerifyOutput{}
                        if err := workflow.ExecuteActivity(ctx, "VerifyExecution", VerifyInput{
                                RunID:   input.RunID,
                                Message: msg,
                                PlanID:  executeResult.PlanID,
                        }).Get(ctx, &amp;verifyResult); err != nil </span><span class="cov0" title="0">{
                                logger.Error("verification activity failed", "error", err)
                                failureInput := RunFailureInput{
                                        RunID: input.RunID,
                                        Error: "verification: " + err.Error(),
                                }
                                if failureErr := workflow.ExecuteActivity(ctx, "HandleRunFailure", failureInput).Get(ctx, nil); failureErr != nil </span><span class="cov0" title="0">{
                                        logger.Error("failed to persist run failure event", "error", failureErr)
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                })
                <span class="cov8" title="1">selector.Select(ctx)

                if ctx.Err() != nil </span><span class="cov8" title="1">{
                        return RunResult{Status: "cancelled"}, nil
                }</span>
        }

}
</pre>
		
		<pre class="file" id="file33" style="display: none">package workflows

import (
        "context"
        "fmt"
        "strings"

        "go.temporal.io/sdk/client"
)

const (
        MessageSignalName = "message"
)

type Service struct {
        client    client.Client
        taskQueue string
}

func NewService(client client.Client, taskQueue string) *Service <span class="cov8" title="1">{
        if taskQueue == "" </span><span class="cov0" title="0">{
                taskQueue = "gavryn-runs"
        }</span>
        <span class="cov8" title="1">return &amp;Service{client: client, taskQueue: taskQueue}</span>
}

func (s *Service) StartRun(ctx context.Context, runID string) error <span class="cov8" title="1">{
        options := client.StartWorkflowOptions{
                ID:        workflowID(runID),
                TaskQueue: s.taskQueue,
        }
        _, err := s.client.ExecuteWorkflow(ctx, options, RunWorkflow, RunInput{RunID: runID})
        return err
}</span>

func (s *Service) SignalMessage(ctx context.Context, runID string, message string) error <span class="cov8" title="1">{
        return s.client.SignalWorkflow(ctx, workflowID(runID), "", MessageSignalName, message)
}</span>

func (s *Service) ResumeRun(ctx context.Context, runID string, message string) error <span class="cov8" title="1">{
        message = strings.TrimSpace(message)
        if message == "" </span><span class="cov8" title="1">{
                message = "Continue from checkpoint."
        }</span>
        <span class="cov8" title="1">options := client.StartWorkflowOptions{
                ID:        workflowID(runID),
                TaskQueue: s.taskQueue,
        }
        _, err := s.client.SignalWithStartWorkflow(
                ctx,
                workflowID(runID),
                MessageSignalName,
                message,
                options,
                RunWorkflow,
                RunInput{RunID: runID},
        )
        return err</span>
}

func (s *Service) CancelRun(ctx context.Context, runID string) error <span class="cov8" title="1">{
        return s.client.CancelWorkflow(ctx, workflowID(runID), "")
}</span>

func workflowID(runID string) string <span class="cov8" title="1">{
        return fmt.Sprintf("run:%s", runID)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
